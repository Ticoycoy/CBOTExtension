// CB-PHAA Content Script - Automation Engine
// This script runs in the context of the web page

(function() {
  // Use a more obfuscation-resistant global check
  const GLOBAL_KEY = '__CBPHAA_CONTENT_INJECTED';
  if (window[GLOBAL_KEY]) return;
  window[GLOBAL_KEY] = true;
  
  // CRITICAL: Validate URL before proceeding - prevent crashes on browser/extension pages
  function isValidPage() {
    try {
      const url = window.location.href;
      const protocol = window.location.protocol;
      
      // Block browser internal pages
      if (protocol === 'chrome:' || protocol === 'chrome-extension:' || 
          protocol === 'moz-extension:' || protocol === 'edge:' ||
          url.startsWith('about:') || url.startsWith('chrome://') || 
          url.startsWith('chrome-extension://') || url.startsWith('moz-extension://') ||
          url.startsWith('edge://') || url.startsWith('opera://')) {
        console.log('üö´ [URL_VALIDATION] Skipping browser/extension page:', url);
        return false;
      }
      
      // Only allow HTTP/HTTPS pages
      if (protocol !== 'http:' && protocol !== 'https:') {
        console.log('üö´ [URL_VALIDATION] Skipping non-HTTP(S) page:', url);
        return false;
      }
      
      // Additional safety: check if we can access document
      if (!document || !document.body) {
        console.log('üö´ [URL_VALIDATION] Document not accessible');
        return false;
      }
      
      return true;
    } catch (error) {
      console.error('üö´ [URL_VALIDATION] Error validating page:', error);
      return false;
    }
  }
  
  // Early exit if page is invalid
  if (!isValidPage()) {
    console.log('üö´ [CB-PHAA] Content script skipped - invalid page type');
    return;
  }
  
  console.log('CB-PHAA content script loaded!');

  // --- Storage Change Listener for CampaignData Updates ---
  // Only set up storage listener if we're on a valid page
  if (isValidPage() && chrome && chrome.storage && chrome.storage.onChanged) {
    try {
      chrome.storage.onChanged.addListener((changes, areaName) => {
      if (areaName === 'local' && changes.CampaignData) {
        console.log('üîÑ [STORAGE] CampaignData updated in chrome.storage.local');
        console.log('üìä [STORAGE] New CampaignData:', changes.CampaignData.newValue);
        
        if (changes.CampaignData.oldValue) {
          const oldCitations = changes.CampaignData.oldValue?.citations;
          const oldCount = Array.isArray(oldCitations) 
            ? oldCitations.length 
            : (oldCitations?.length || 0);
          const oldSites = Array.isArray(oldCitations) 
            ? oldCitations.map((c) => c?.site).filter(Boolean)
            : [];
          console.log('üìä [STORAGE] Old CampaignData had', oldCount, 'citations');
          if (oldSites.length > 0) {
            console.log('üìä [STORAGE] Old citation sites:', oldSites);
          }
        }
        
        if (changes.CampaignData.newValue) {
          const newCitations = changes.CampaignData.newValue?.citations;
          const newCount = Array.isArray(newCitations) 
            ? newCitations.length 
            : (newCitations?.length || 0);
          const newSites = Array.isArray(newCitations) 
            ? newCitations.map((c) => c?.site).filter(Boolean)
            : [];
          console.log('üìä [STORAGE] New CampaignData has', newCount, 'citations');
          if (newSites.length > 0) {
            console.log('üìä [STORAGE] New citation sites:', newSites);
            console.log('üìä [STORAGE] Citation sites summary:', newSites.join(', '));
          }
        }
      }
    });
    } catch (error) {
      console.error('üö´ [STORAGE] Error setting up storage listener:', error);
    }
  }

  // --- Utility Functions ---
  // Tab ID tracking
  let currentTabId = null;
  
  // Get current tab ID
  async function getCurrentTabId() {
    if (currentTabId) return currentTabId;
    
    try {
      const response = await new Promise((resolve) => {
        CHROME_API.runtime.sendMessage({ type: "GET_TAB_ID" }, (response) => {
          if (CHROME_API.lastError) {
            console.warn("Could not get tab ID:", CHROME_API.lastError.message);
            resolve(null);
          } else {
            resolve(response);
          }
        });
      });
      
      if (response && response.tabId) {
        currentTabId = response.tabId;
        console.log(`üè∑Ô∏è [TAB] Current tab ID: ${currentTabId}`);
        return currentTabId;
      }
    } catch (error) {
      console.warn("Error getting tab ID:", error);
    }
    
    return null;
  }

  // Smart domain extraction function - intelligently extracts base domain
  // Handles cases like: welcome.all.biz -> all.biz, www.example.com -> example.com
  function extractBaseDomain(hostname) {
    if (!hostname) return "";
    
    // Convert to lowercase for consistency
    let domain = hostname.toLowerCase().trim();
    
    // Remove www prefix if present
    domain = domain.replace(/^www\./, "");
    
    // List of common multi-part TLDs (country code + generic)
    const multiPartTLDs = [
      'co.uk', 'com.au', 'com.br', 'com.mx', 'com.ar', 'com.co',
      'co.za', 'co.nz', 'com.sg', 'com.hk', 'com.tw', 'com.my',
      'com.ph', 'com.vn', 'com.th', 'com.id', 'co.in', 'com.in',
      'net.au', 'org.uk', 'gov.uk', 'ac.uk', 'edu.au', 'gov.au',
      'com.cn', 'cn.com', 'net.cn', 'org.cn', 'com.tr', 'com.ua',
      'com.pl', 'com.de', 'com.fr', 'com.es', 'com.it', 'com.nl',
      'com.be', 'com.ch', 'com.at', 'com.se', 'com.no', 'com.dk',
      'com.fi', 'com.gr', 'com.pt', 'com.ro', 'com.bg', 'com.cz',
      'com.sk', 'com.hu', 'com.ie', 'com.lu', 'com.ee', 'com.lv',
      'com.lt', 'com.si', 'com.hr', 'com.rs', 'com.ba', 'com.mk',
      'com.al', 'com.me', 'com.mt', 'com.cy', 'com.is', 'com.li',
      'com.mc', 'com.ad', 'com.sm', 'com.va', 'com.je', 'com.gg',
      'com.im', 'com.fo', 'com.gl', 'com.sj', 'com.ax', 'com.yt',
      'com.pm', 'com.wf', 'com.tf', 'com.re', 'com.bl', 'com.mf',
      'com.gp', 'com.mq', 'com.gf', 'com.pf', 'com.nc', 'com.vu',
      'com.nc', 'com.pf', 'com.wf', 'com.pm', 'com.yt', 'com.tf',
      'com.re', 'com.bl', 'com.mf', 'com.gp', 'com.mq', 'com.gf',
      'com.biz', 'com.info', 'com.name', 'com.pro', 'com.mobi',
      'com.tel', 'com.asia', 'com.travel', 'com.jobs', 'com.mobi',
      'net.au', 'org.au', 'edu.au', 'gov.au', 'asn.au', 'id.au',
      'net.nz', 'org.nz', 'co.nz', 'govt.nz', 'ac.nz', 'school.nz',
      'net.za', 'org.za', 'co.za', 'gov.za', 'ac.za', 'edu.za',
      'law.za', 'mil.za', 'nom.za', 'alt.za', 'net.za', 'web.za',
      'net.uk', 'org.uk', 'ltd.uk', 'plc.uk', 'me.uk', 'sch.uk',
      'ac.uk', 'gov.uk', 'mod.uk', 'nhs.uk', 'police.uk', 'co.uk',
      'net.uk', 'org.uk', 'ltd.uk', 'plc.uk', 'me.uk', 'sch.uk'
    ];
    
    // Split domain into parts
    const parts = domain.split('.');
    
    // If domain has 2 parts (e.g., example.com), return as is
    if (parts.length === 2) {
      return domain;
    }
    
    // Check for multi-part TLDs
    for (const tld of multiPartTLDs) {
      if (domain.endsWith('.' + tld)) {
        // Extract domain + multi-part TLD
        const tldParts = tld.split('.');
        const domainParts = parts.slice(-(tldParts.length + 1));
        return domainParts.join('.');
      }
    }
    
    // For domains with more than 2 parts, try to identify the base domain
    // Common pattern: prefix.domain.tld (e.g., welcome.all.biz)
    // Strategy: Take the last 2 parts as domain.tld
    if (parts.length > 2) {
      // Check if it's a known pattern like "welcome.all.biz"
      // We'll take the last 2 parts: "all.biz"
      const lastTwoParts = parts.slice(-2).join('.');
      
      // Additional check: if the second-to-last part is a common domain word
      // and the last part is a TLD, we might want to include one more part
      const commonTLDs = ['com', 'org', 'net', 'edu', 'gov', 'mil', 'int',
                          'biz', 'info', 'name', 'pro', 'coop', 'aero',
                          'museum', 'jobs', 'mobi', 'tel', 'travel', 'asia',
                          'io', 'co', 'me', 'tv', 'cc', 'ws', 'name', 'biz',
                          'us', 'uk', 'ca', 'au', 'de', 'fr', 'it', 'es',
                          'nl', 'be', 'ch', 'at', 'se', 'no', 'dk', 'fi',
                          'gr', 'pt', 'ro', 'bg', 'cz', 'sk', 'hu', 'ie',
                          'lu', 'ee', 'lv', 'lt', 'si', 'hr', 'rs', 'ba',
                          'mk', 'al', 'me', 'mt', 'cy', 'is', 'li', 'mc',
                          'ad', 'sm', 'va', 'je', 'gg', 'im', 'fo', 'gl',
                          'sj', 'ax', 'yt', 'pm', 'wf', 'tf', 're', 'bl',
                          'mf', 'gp', 'mq', 'gf', 'pf', 'nc', 'vu', 'cn',
                          'jp', 'kr', 'in', 'id', 'ph', 'th', 'vn', 'my',
                          'sg', 'hk', 'tw', 'nz', 'za', 'tr', 'ua', 'pl',
                          'ru', 'br', 'mx', 'ar', 'co', 'cl', 'pe', 'ec',
                          've', 'uy', 'py', 'bo', 'cr', 'pa', 'gt', 'hn',
                          'ni', 'sv', 'bz', 'jm', 'tt', 'bb', 'gd', 'lc',
                          'vc', 'ag', 'dm', 'kn', 'bs', 'cu', 'do', 'ht',
                          'pr', 'aw', 'cw', 'sx', 'bq', 'ai', 'vg', 'ky',
                          'bm', 'tc', 'ms', 'fk', 'gi', 'ad', 'mc', 'sm',
                          'va', 'li', 'je', 'gg', 'im', 'fo', 'gl', 'sj',
                          'ax', 'yt', 'pm', 'wf', 'tf', 're', 'bl', 'mf',
                          'gp', 'mq', 'gf', 'pf', 'nc', 'vu'];
      
      const secondLastPart = parts[parts.length - 2];
      const lastPart = parts[parts.length - 1];
      
      // If second-to-last is a common TLD and last is also a TLD, 
      // it might be a multi-part TLD we missed, so take last 2 parts
      // Otherwise, if last part is a TLD, take last 2 parts
      if (commonTLDs.includes(lastPart.toLowerCase())) {
        return lastTwoParts;
      }
      
      // If we have 3+ parts and the pattern looks like prefix.domain.tld,
      // try to be smart: if middle parts look like domain names (not TLDs),
      // take the last 2 parts
      return lastTwoParts;
    }
    
    // Fallback: return the domain as-is (shouldn't reach here normally)
    return domain;
  }

  function getResumeIndexKey() {
    const domain = extractBaseDomain(window.location.hostname);
    return `resumeIndex_${domain}`;
  }
  
  function getTabSpecificResumeIndexKey() {
    const domain = extractBaseDomain(window.location.hostname);
    // Use domain-only tracking instead of tab-specific to avoid confusion
    return `resumeIndex_${domain}`;
  }

  // Get domain-specific completion key
  function getTabSpecificCompletionKey() {
    const domain = extractBaseDomain(window.location.hostname);
    return `automationCompleted_${domain}`;
  }
  
  // Utility function to clean up old automation data from other domains
  function cleanupOldAutomationData() {
    const currentDomain = extractBaseDomain(window.location.hostname);
    CHROME_API.storage.local.get(null, (allData) => {
      const keysToRemove = [];
      
      // Find old automation status keys from other domains (domain-only keys)
      Object.keys(allData).forEach(key => {
        if (key.startsWith('automationStatus_') && !key.includes(currentDomain)) {
          keysToRemove.push(key);
        }
        if (key.startsWith('resumeIndex_') && !key.includes(currentDomain)) {
          // Only remove if it's very old (older than 1 hour) or reset to 0
          const keyData = allData[key];
          if (typeof keyData === 'number' && keyData === 0) {
            keysToRemove.push(key);
          }
        }
        // Remove old tab-specific keys (legacy cleanup)
        if (key.includes('_tab_') && !key.includes(currentDomain)) {
          keysToRemove.push(key);
        }
      });
      
      if (keysToRemove.length > 0) {
        console.log(`üßπ Cleaning up ${keysToRemove.length} old automation keys from other domains:`, keysToRemove);
        CHROME_API.storage.local.remove(keysToRemove, () => {
          console.log(`‚úÖ Cleaned up old automation data`);
        });
      }
    });
  }
  const normalize = (path) => path.replace(/\/(\d+|[A-Za-z0-9-_]{8,})/g, "/:id");

  // State Variables
  let paused = false, resumeSignal = null;
  let automationRunning = false;
  let automationStarting = false;
  let automationStatus = {
    isRunning: false,
    currentStep: 0,
    totalSteps: 0,
    lastUpdated: null,
    errors: [],
    tabId: null
  };

  // Utility: Safe Chrome API call wrapper
  // Obfuscation-resistant Chrome API wrapper
  const CHROME_API = {
    runtime: chrome?.runtime,
    storage: chrome?.storage,
    lastError: null
  };

  function safeChromeCall(apiCall, fallback = null) {
    try {
      // Check if Chrome APIs are available and context is valid
      if (CHROME_API.runtime && CHROME_API.runtime.id) {
        // Clear any previous errors
        CHROME_API.lastError = null;
        return apiCall();
      } else {
        console.warn("Chrome API not available or extension context invalidated");
        return fallback;
      }
    } catch (err) {
      console.warn("Chrome API call failed:", err.message);
      return fallback;
    }
  }

  // Utility: Check if extension context is valid
  function isExtensionContextValid() {
    try {
      return !!(CHROME_API.runtime && CHROME_API.runtime.id);
    } catch (err) {
      return false;
    }
  }

  // Utility: Show extension context error notification
  function showExtensionContextError() {
    console.error("üö® Extension context invalidated! Please reload the extension or refresh the page.");
    showToast("Extension context invalidated. Please reload the extension.");
  }

  // Obfuscation-resistant DOM utilities
  const DOM_UTILS = {
    querySelector: (selector) => document.querySelector(selector),
    querySelectorAll: (selector) => document.querySelectorAll(selector),
    getElementById: (id) => document.getElementById(id),
    createElement: (tag) => document.createElement(tag),
    setTextContent: (element, text) => { if (element) element.textContent = text; },
    setInnerHTML: (element, html) => { if (element) element.innerHTML = html; },
    appendChild: (parent, child) => { if (parent && child) parent.appendChild(child); },
    removeChild: (parent, child) => { if (parent && child) parent.removeChild(child); }
  };

  // Obfuscation-resistant automation state wrapper
  const AUTOMATION_STATE = {
    get: () => window.__AUTOMATION_STATE__,
    set: (state) => { window.__AUTOMATION_STATE__ = state; },
    update: (updates) => { 
      if (window.__AUTOMATION_STATE__) {
        Object.assign(window.__AUTOMATION_STATE__, updates);
      }
    },
    isAborted: () => window.__AUTOMATION_STATE__?.aborted || false,
    isPaused: () => window.__AUTOMATION_STATE__?.paused || false,
    isCompleted: () => window.__AUTOMATION_STATE__?.isCompleted || false
  };
  
  // Global utility function to check element attributes that contain element references or HTML
  // Usage: window.__CBPHAA_checkElementAttributes(element) or __CBPHAA_checkElementAttributes(document.querySelector('#myElement'))
  window.__CBPHAA_checkElementAttributes = function(element) {
    if (!element) {
      console.warn('‚ö†Ô∏è No element provided');
      return null;
    }
    
    // Attributes that typically contain element IDs (space-separated)
    const elementReferenceAttributes = [
      'aria-controls',      // IDs of elements controlled by this element
      'aria-labelledby',     // IDs of elements that label this element
      'aria-describedby',    // IDs of elements that describe this element
      'aria-owns',           // IDs of elements owned by this element
      'aria-activedescendant', // ID of the active descendant
      'aria-flowto',         // IDs of elements that follow this one
      'for'                  // ID of the element this label is for (on <label>)
    ];
    
    // Attributes that might contain HTML content
    const htmlContentAttributes = [
      'data-content',        // Custom data attribute that might contain HTML
      'data-html',           // Custom data attribute for HTML
      'title',              // Tooltip that might contain HTML entities
      'aria-label'          // Accessible label (usually plain text, but might have entities)
    ];
    
    // Attributes that are plain text (no element references or HTML)
    const plainTextAttributes = [
      'placeholder',         // Placeholder text (plain text only)
      'value',               // Form value (plain text)
      'name',                // Form field name
      'id',                  // Element ID
      'class',               // CSS classes
      'type'                 // Input type
    ];
    
    const checkAttribute = (attrName) => {
      const attrValue = element.getAttribute(attrName);
      if (!attrValue) return null;
      
      const result = {
        attribute: attrName,
        value: attrValue,
        containsElementReferences: false,
        containsHTML: false,
        referencedElements: [],
        isPlainText: false
      };
      
      // Check if attribute contains element references
      if (elementReferenceAttributes.includes(attrName)) {
        result.containsElementReferences = true;
        // Split by spaces to get individual IDs
        const elementIds = attrValue.trim().split(/\s+/).filter(id => id.length > 0);
        result.referencedElements = elementIds.map(id => {
          try {
            const refElement = document.getElementById(id) || 
                              document.querySelector(`[id="${id}"]`) ||
                              document.querySelector(`[name="${id}"]`);
            return {
              id: id,
              found: !!refElement,
              element: refElement,
              tagName: refElement ? refElement.tagName : null,
              textContent: refElement ? refElement.textContent?.trim().substring(0, 50) : null
            };
          } catch (e) {
            return { id: id, found: false, error: e.message };
          }
        });
      }
      
      // Check if attribute might contain HTML
      if (htmlContentAttributes.includes(attrName)) {
        // Check for HTML tags in the attribute value
        const htmlTagPattern = /<[^>]+>/;
        result.containsHTML = htmlTagPattern.test(attrValue);
      }
      
      // Check if it's a plain text attribute
      if (plainTextAttributes.includes(attrName)) {
        result.isPlainText = true;
      }
      
      return result;
    };
    
    const attributesToCheck = [
      ...elementReferenceAttributes,
      ...htmlContentAttributes,
      ...plainTextAttributes
    ];
    
    const results = [];
    attributesToCheck.forEach(attrName => {
      const result = checkAttribute(attrName);
      if (result && result.value) {
        results.push(result);
      }
    });
    
    // Log results in a readable format
    console.group(`üîç Element Attributes Analysis: ${element.tagName}${element.id ? '#' + element.id : ''}${element.className ? '.' + element.className.split(' ').join('.') : ''}`);
    if (results.length === 0) {
      console.log('No relevant attributes found');
    } else {
      results.forEach(result => {
        console.group(`üìã ${result.attribute} = "${result.value}"`);
        if (result.containsElementReferences) {
          console.log('‚úÖ Contains element references');
          if (result.referencedElements.length > 0) {
            result.referencedElements.forEach(ref => {
              if (ref.found) {
                console.log(`   ‚úì Found element: #${ref.id} (${ref.tagName}) - "${ref.textContent}..."`);
              } else {
                console.log(`   ‚úó Element not found: #${ref.id}`);
              }
            });
          }
        }
        if (result.containsHTML) {
          console.log('‚úÖ Contains HTML tags');
        }
        if (result.isPlainText) {
          console.log('üìù Plain text attribute');
        }
        console.groupEnd();
      });
    }
    console.groupEnd();
    
    return results;
  };

  // Utility: Delay function that works even when tab is in background
  // Uses actual time tracking to ensure delays complete even if setTimeout is throttled
  async function delay(ms) {
    const startTime = Date.now();
    const targetTime = startTime + ms;
    
    // Use small chunks to check pause state and actual elapsed time
    const chunkSize = 100; // Check every 100ms
    let remaining = ms;
    
    while (remaining > 0) {
      // Check if aborted
      if (AUTOMATION_STATE.isAborted() || !automationRunning) {
        console.log(`üõë Automation aborted during delay - stopping`);
        return; // Exit delay immediately
      }
      
      // Check if paused
      const state = AUTOMATION_STATE.get();
      if (state && state.paused) {
        console.log(`‚è∏Ô∏è Automation paused during delay - waiting for resume`);
        // Wait for resume signal
        await new Promise((r) => {
          resumeSignal = () => {
            r();
          };
        });
        // Check if aborted during pause
        if (AUTOMATION_STATE.isAborted() || !automationRunning) {
          console.log(`üõë Automation aborted during pause - stopping`);
          return;
        }
        // Recalculate remaining time after resume
        const currentTime = Date.now();
        remaining = Math.max(0, targetTime - currentTime);
        if (remaining > 0) {
          console.log(`‚ñ∂Ô∏è Automation resumed - ${remaining}ms remaining in delay`);
        }
      }
      
      // Check actual elapsed time to account for throttling
      const currentTime = Date.now();
      const actualRemaining = targetTime - currentTime;
      
      if (actualRemaining <= 0) {
        // Enough time has actually passed (accounting for throttling)
        break;
      }
      
      // Use the smaller of: remaining time or chunk size
      const chunkDelay = Math.min(chunkSize, actualRemaining);
      
      // Ping Chrome runtime to keep extension context active (helps prevent throttling)
      if (CHROME_API.runtime && CHROME_API.runtime.id) {
        try {
          CHROME_API.runtime.sendMessage({ type: 'KEEP_ALIVE' }, () => {
            // Ignore errors - this is just a keep-alive ping
          });
        } catch (e) {
          // Ignore errors
        }
      }
      
      await new Promise((r) => setTimeout(r, chunkDelay));
      
      // Update remaining based on actual elapsed time
      remaining = Math.max(0, targetTime - Date.now());
    }
  }

  // Utility: Show toast notification
  function showToast(message) {
    let toast = DOM_UTILS.createElement('div');
    DOM_UTILS.setTextContent(toast, message);
    toast.style.position = 'fixed';
    toast.style.bottom = '32px';
    toast.style.left = '50%';
    toast.style.transform = 'translateX(-50%)';
    toast.style.background = '#388e3c';
    toast.style.color = '#fff';
    toast.style.padding = '12px 24px';
    toast.style.borderRadius = '8px';
    toast.style.fontSize = '16px';
    toast.style.zIndex = 99999;
    toast.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
    DOM_UTILS.appendChild(document.body, toast);
    setTimeout(() => DOM_UTILS.removeChild(document.body, toast), 3500);
  }

  // Utility: Flatten nested objects to a flat key-value map
  function flattenObject(obj, prefix = '', res = {}) {
    for (const key in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
      const value = obj[key];
      const flatKey = prefix ? `${prefix}.${key}` : key;
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        flattenObject(value, flatKey, res);
      } else {
        res[key] = value;
        res[flatKey] = value;
      }
    }
    return res;
  }

  // Utility: Convert 12-hour format to 24-hour format
  function convertTo24Hour(time12h) {
    if (!time12h || typeof time12h !== 'string') return time12h;
    
    // Handle various time formats
    const time = time12h.trim().toUpperCase();
    
    // If already in 24-hour format, return as is
    if (/^\d{1,2}:\d{2}$/.test(time)) {
      return time.padStart(5, '0');
    }
    
    // Handle 12-hour format with AM/PM
    const match = time.match(/^(\d{1,2}):?(\d{2})\s*(AM|PM)$/);
    if (match) {
      let [_, hours, minutes, period] = match;
      hours = parseInt(hours);
      
      if (period === 'PM' && hours !== 12) {
        hours += 12;
      } else if (period === 'AM' && hours === 12) {
        hours = 0;
      }
      
      return `${hours.toString().padStart(2, '0')}:${minutes}`;
    }
    
    return time12h; // Return original if no conversion possible
  }

  // Utility: Format business hours based on specified format
  function formatBusinessHours(businessHoursData, format = 'standard') {
    if (!businessHoursData || typeof businessHoursData !== 'object') {
      return '';
    }

    const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    const shortDayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

    // Extract and convert times
    const hours = {};
    days.forEach(day => {
      const am = convertTo24Hour(businessHoursData[`${day}Am`] || '');
      const pm = convertTo24Hour(businessHoursData[`${day}Pm`] || '');
      
      if (am && pm) {
        hours[day] = { open: am, close: pm, closed: false };
      } else {
        hours[day] = { closed: true };
      }
    });

    switch (format) {
      case '24hour':
        // Only times, no day name
        const firstDay = days.find(day => !hours[day].closed);
        return firstDay ? `${hours[firstDay].open} - ${hours[firstDay].close}` : '';

      case 'compact':
        // Short time format, no spaces
        const compactDay = days.find(day => !hours[day].closed);
        return compactDay ? `${hours[compactDay].open}-${hours[compactDay].close}` : '';

      case 'consolidated':
        // Group days with same hours and collapse closed days
        const groups = [];
        let currentGroup = null;
        
        days.forEach((day, index) => {
          const dayHours = hours[day];
          
          if (dayHours.closed) {
            if (currentGroup) {
              groups.push(currentGroup);
              currentGroup = null;
            }
          } else {
            const timeKey = `${dayHours.open}-${dayHours.close}`;
            
            if (!currentGroup || currentGroup.timeKey !== timeKey) {
              if (currentGroup) groups.push(currentGroup);
              currentGroup = {
                startDay: day,
                endDay: day,
                timeKey,
                hours: dayHours
              };
            } else {
              currentGroup.endDay = day;
            }
          }
        });
        
        if (currentGroup) groups.push(currentGroup);
        
        return groups.map(group => {
          const startName = shortDayNames[days.indexOf(group.startDay)];
          const endName = shortDayNames[days.indexOf(group.endDay)];
          const dayRange = group.startDay === group.endDay ? startName : `${startName}-${endName}`;
          return `${dayRange}: ${group.hours.open}-${group.hours.close}`;
        }).join(', ');

      case 'detailed':
        // Keep days and convert times
        return days.map((day, index) => {
          const dayHours = hours[day];
          if (dayHours.closed) {
            return `${dayNames[index]}: Closed`;
          }
          return `${dayNames[index]}: ${dayHours.open}-${dayHours.close}`;
        }).join('\n');

      case 'simple':
        // Just the time range
        const simpleDay = days.find(day => !hours[day].closed);
        return simpleDay ? `${hours[simpleDay].open} - ${hours[simpleDay].close}` : '';

      case 'standard':
      default:
        // Keep structure, convert times only
        return days.map((day, index) => {
          const dayHours = hours[day];
          if (dayHours.closed) {
            return `${dayNames[index]}: Closed`;
          }
          return `${dayNames[index]}: ${dayHours.open} - ${dayHours.close}`;
        }).join('\n');
    }
  }

  // Utility: Wait for DOMContentLoaded
  function onReady(fn) {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', fn);
    } else {
      fn();
    }
  }

  // Enhanced element finder that checks multiple contexts
  // Helper function to detect if an element is clickable
  function isClickableElement(element) {
    if (!element) return false;
    
    const tagName = element.tagName.toLowerCase();
    const role = element.getAttribute('role');
    
    // Direct clickable elements (label activates associated control on click)
    if (['button', 'a', 'input', 'select', 'textarea', 'label'].includes(tagName)) {
      return true;
    }
    
    // Elements with clickable roles
    if (role && ['button', 'link', 'menuitem', 'tab', 'option'].includes(role)) {
      return true;
    }
    
    // Elements with click handlers
    if (element.onclick || element.getAttribute('onclick')) {
      return true;
    }
    
    // Elements with cursor pointer style
    const computedStyle = window.getComputedStyle(element);
    if (computedStyle.cursor === 'pointer') {
      return true;
    }
    
    // Elements with data attributes that suggest clickability
    if (element.getAttribute('data-testid') || 
        element.getAttribute('data-cy') || 
        element.getAttribute('data-qa') ||
        element.getAttribute('data-test')) {
      return true;
    }
    
    return false;
  }

  // Helper function to find the closest clickable parent
  function findClosestClickableParent(element) {
    if (!element) return null;
    
    let current = element;
    while (current && current !== document.body) {
      if (isClickableElement(current)) {
        return current;
      }
      current = current.parentElement;
    }
    
    return null;
  }

  // Helper function to simulate a real mouse click on any element
  function simulateMouseClick(element) {
    if (!element) return Promise.resolve(false);
    
    try {
      // Scroll element into view if needed
      element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
      
      // Wait a bit for scroll to complete
      return new Promise((resolve) => {
        setTimeout(() => {
          try {
            // Get element's bounding rectangle for click coordinates
            const rect = element.getBoundingClientRect();
            
            // Handle case where element might have zero dimensions
            let centerX, centerY;
            if (rect.width > 0 && rect.height > 0) {
              centerX = rect.left + rect.width / 2;
              centerY = rect.top + rect.height / 2;
            } else {
              // Fallback: use element position even if dimensions are zero
              centerX = rect.left;
              centerY = rect.top;
            }
            
            // Create mouse event options
            const mouseEventOptions = {
              bubbles: true,
              cancelable: true,
              view: window,
              detail: 1,
              screenX: centerX + (window.screenX || 0),
              screenY: centerY + (window.screenY || 0),
              clientX: centerX,
              clientY: centerY,
              button: 0,
              buttons: 1,
              which: 1,
              ctrlKey: false,
              altKey: false,
              shiftKey: false,
              metaKey: false
            };
            
            // Dispatch mouseover event (simulates mouse moving over element)
            const mouseOverEvent = new MouseEvent('mouseover', {
              ...mouseEventOptions,
              relatedTarget: null
            });
            element.dispatchEvent(mouseOverEvent);
            
            // Small delay before mousedown
            setTimeout(() => {
              // Dispatch mousedown event
              const mouseDownEvent = new MouseEvent('mousedown', mouseEventOptions);
              const mousedownResult = element.dispatchEvent(mouseDownEvent);
              
              // Small delay between mousedown and mouseup (simulates real click)
              setTimeout(() => {
                // Dispatch mouseup event
                const mouseUpEvent = new MouseEvent('mouseup', {
                  ...mouseEventOptions,
                  buttons: 0
                });
                element.dispatchEvent(mouseUpEvent);
                
                // Dispatch click event
                const clickEvent = new MouseEvent('click', mouseEventOptions);
                const clickResult = element.dispatchEvent(clickEvent);
                console.log(`üñ±Ô∏è [DEBUG] click dispatch result: ${clickResult}, mousedown result: ${mousedownResult}`);
                
                // Dispatch mouseout event (simulates mouse leaving element)
                const mouseOutEvent = new MouseEvent('mouseout', {
                  ...mouseEventOptions,
                  relatedTarget: null
                });
                element.dispatchEvent(mouseOutEvent);
                
                // Also try focus for focusable elements
                if (element.focus && typeof element.focus === 'function') {
                  try {
                    element.focus();
                  } catch (e) {
                    // Some elements might not be focusable, that's okay
                  }
                }
                
                // Also call native click() as fallback for elements that require it
                resolve(!!(clickResult && mousedownResult));
              }, 10);
            }, 5);
          } catch (error) {
            console.warn(`‚ö†Ô∏è Error in mouse click simulation: ${error.message}`);
            // Fallback to simple click
            try {
              if (element.click && typeof element.click === 'function') {
                element.click();
                resolve(true);
              } else {
                resolve(false);
              }
            } catch (e) {
              resolve(false);
            }
          }
        }, 100);
      });
    } catch (error) {
      console.warn(`‚ö†Ô∏è Error simulating mouse click: ${error.message}`);
      // Fallback to simple click
      try {
        if (element.click && typeof element.click === 'function') {
          element.click();
          return Promise.resolve(true);
        } else {
          return Promise.resolve(false);
        }
      } catch (e) {
        return Promise.resolve(false);
      }
    }
  }

  // Helper function to find an element within a parent container
  /**
   * Find an element within a parent element
   * @param {string} selector - CSS selector for the target element
   * @param {HTMLElement} parentElement - Parent element to search within
   * @returns {HTMLElement|null} - Found element or null
   */
  function findElementInParent(selector, parentElement) {
    if (!parentElement) return null;
    
    try {
      let el = parentElement.querySelector(selector);
      if (el) {
        console.log(`‚úÖ Element found within parent: ${selector}`);
        
        // Check if the found element is clickable
        if (isClickableElement(el)) {
          console.log(`üéØ Element is directly clickable: ${selector}`);
          return el;
        }
        
        // If not clickable, try to find the closest clickable parent
        const clickableParent = findClosestClickableParent(el);
        if (clickableParent) {
          console.log(`üéØ Found clickable parent for inner element: ${selector} -> ${clickableParent.tagName.toLowerCase()}${clickableParent.className ? '.' + clickableParent.className.split(' ').join('.') : ''}`);
          return clickableParent;
        }
        
        // Return original element if no clickable parent found
        console.log(`‚ö†Ô∏è Element found but no clickable parent detected: ${selector}`);
        return el;
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è Error finding element in parent: ${error.message}`);
    }
    
    return null;
  }
  
  /**
   * Find an element using multiple parent selectors (array)
   * Searches through each parent sequentially until element is found
   * @param {string} selector - CSS selector for the target element
   * @param {string[]} parentSelectors - Array of parent CSS selectors to try
   * @param {number} timeout - Timeout in milliseconds for each parent search
   * @returns {Promise<{element: HTMLElement|null, parentIndex: number, parentSelector: string|null}>}
   */
  async function findElementInMultipleParents(selector, parentSelectors, timeout = 5000) {
    if (!Array.isArray(parentSelectors) || parentSelectors.length === 0) {
      return { element: null, parentIndex: -1, parentSelector: null };
    }
    
    for (let i = 0; i < parentSelectors.length; i++) {
      const parentSelector = parentSelectors[i];
      
      if (!parentSelector || typeof parentSelector !== 'string') {
        console.warn(`‚ö†Ô∏è Invalid parent selector at index ${i}, skipping...`);
        continue;
      }
      
      try {
        // Wait for parent element
        const parentEl = await waitFor(parentSelector, timeout);
        
        if (!parentEl) {
          console.log(`‚ö†Ô∏è Parent ${i + 1} not found: "${parentSelector}"`);
          continue;
        }
        
        // Find element within parent
        const el = findElementInParent(selector, parentEl);
        
        if (el) {
          return {
            element: el,
            parentIndex: i,
            parentSelector: parentSelector
          };
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Error with parent ${i + 1} "${parentSelector}": ${error.message}`);
      }
    }
    
    return { element: null, parentIndex: -1, parentSelector: null };
  }
  
  // Global utility function to test parentSelectors from console
  // Usage: window.__CBPHAA_testParentSelectors(selector, parentSelectors)
  window.__CBPHAA_testParentSelectors = async function(selector, parentSelectors) {
    if (!selector || !parentSelectors) {
      console.error('‚ùå Usage: __CBPHAA_testParentSelectors(selector, parentSelectors)');
      console.error('   selector: string - CSS selector for target element');
      console.error('   parentSelectors: string[] - Array of parent CSS selectors');
      return null;
    }
    
    if (!Array.isArray(parentSelectors)) {
      console.error('‚ùå parentSelectors must be an array');
      return null;
    }
    
    console.group(`üß™ Testing parentSelectors for: "${selector}"`);
    console.log(`üìã Parent selectors (${parentSelectors.length}):`, parentSelectors);
    
    const result = await findElementInMultipleParents(selector, parentSelectors, 5000);
    
    if (result.element) {
      console.log(`‚úÖ SUCCESS! Found element in parent ${result.parentIndex + 1}: "${result.parentSelector}"`);
      console.log('üìç Element:', result.element);
      console.log('üè∑Ô∏è Tag:', result.element.tagName);
      console.log('üÜî ID:', result.element.id || 'none');
      console.log('üìù Classes:', result.element.className || 'none');
      return result.element;
    } else {
      console.error(`‚ùå FAILED! Element not found in any of the ${parentSelectors.length} parent(s)`);
      return null;
    }
    
    console.groupEnd();
  };

  // Helper function to parse HTML element selector (e.g., "<strong>Add Text</strong>")
  function parseHtmlSelector(selector) {
    // Check if selector looks like HTML (starts with < and ends with >)
    if (typeof selector !== 'string' || !selector.trim().startsWith('<') || !selector.trim().endsWith('>')) {
      return null;
    }
    
    try {
      // Remove whitespace and parse
      const html = selector.trim();
      
      // Extract tag name (e.g., "strong" from "<strong>")
      const tagMatch = html.match(/^<(\w+)/);
      if (!tagMatch) return null;
      
      const tagName = tagMatch[1].toLowerCase();
      
      // Extract text content (e.g., "Add Text" from "<strong>Add Text</strong>")
      // Handle both self-closing and normal tags
      const textMatch = html.match(/>([^<]+)</);
      const textContent = textMatch ? textMatch[1].trim() : '';
      
      return {
        tagName: tagName,
        textContent: textContent,
        isHtmlSelector: true
      };
    } catch (e) {
      console.warn(`‚ö†Ô∏è Failed to parse HTML selector: ${selector}`, e);
      return null;
    }
  }
  
  // Helper function to find element by text content
  function findElementByText(tagName, textContent, root = document) {
    if (!tagName || !textContent) return null;
    
    // Get all elements of the specified tag
    const elements = root.querySelectorAll(tagName);
    
    // Try exact match first (case-insensitive)
    for (const el of elements) {
      const elText = el.textContent.trim();
      if (elText.toLowerCase() === textContent.toLowerCase()) {
        return el;
      }
    }
    
    // Try partial match (contains)
    for (const el of elements) {
      const elText = el.textContent.trim();
      if (elText.toLowerCase().includes(textContent.toLowerCase()) || 
          textContent.toLowerCase().includes(elText.toLowerCase())) {
        return el;
      }
    }
    
    // Try word-based matching for multi-word text
    const searchWords = textContent.toLowerCase().split(/\s+/).filter(w => w.length > 0);
    for (const el of elements) {
      const elText = el.textContent.trim().toLowerCase();
      const elWords = elText.split(/\s+/).filter(w => w.length > 0);
      
      // Check if all search words appear in element text
      if (searchWords.every(word => elWords.some(elWord => elWord.includes(word) || word.includes(elWord)))) {
        return el;
      }
    }
    
    return null;
  }

  // Helper function to find clickable elements by text/label/value
  function findClickableElementByText(textContent, root = document, exactOnly = false) {
    if (!textContent || !root) return null;

    const targetText = String(textContent).trim().toLowerCase();
    if (!targetText) return null;

    const candidateSelector = [
      'button',
      'a',
      'label',
      'input[type="button"]',
      'input[type="submit"]',
      'input[type="image"]',
      '[role="button"]',
      '[role="link"]',
      '[role="option"]',
      '[role="menuitem"]',
      '[role="tab"]',
      '[aria-label]',
      '[title]',
      'div[role="button"]',
      'span[role="button"]',
      'div[role="option"]',
      'span[role="option"]',
      'div[role="menuitem"]',
      'span[role="menuitem"]',
      'li[role="option"]',
      'li[role="menuitem"]'
    ].join(',');

    const candidates = Array.from(root.querySelectorAll(candidateSelector))
      .filter(el => {
        const style = window.getComputedStyle(el);
        const visible = style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
        return visible && (isClickableElement(el) || el.getAttribute('role') === 'button' || el.getAttribute('role') === 'option' || el.getAttribute('role') === 'menuitem' || style.cursor === 'pointer');
      });

    const getCandidateText = (el) => {
      const text = (el.textContent || '').trim();
      const value = (el.value || '').trim();
      const aria = (el.getAttribute('aria-label') || '').trim();
      const title = (el.getAttribute('title') || '').trim();
      const alt = (el.getAttribute('alt') || '').trim();
      return text || value || aria || title || alt;
    };

    const normalize = (val) => String(val || '').toLowerCase().replace(/\s+/g, ' ').trim().replace(/[^a-z0-9]/g, '');

    // Exact match (case-insensitive, trim)
    for (const el of candidates) {
      const candidateText = getCandidateText(el);
      if (candidateText && candidateText.trim().toLowerCase() === targetText) {
        return isClickableElement(el) ? el : findClosestClickableParent(el) || el;
      }
    }

    if (exactOnly) return null;

    // Partial match (contains)
    for (const el of candidates) {
      const candidateText = getCandidateText(el);
      if (candidateText) {
        const candidateLower = candidateText.toLowerCase().trim();
        if (candidateLower.includes(targetText) || targetText.includes(candidateLower)) {
          return isClickableElement(el) ? el : findClosestClickableParent(el) || el;
        }
      }
    }

    // Fuzzy match (normalize spaces and punctuation)
    const cleanTarget = normalize(targetText);
    if (cleanTarget) {
      for (const el of candidates) {
        const candidateText = getCandidateText(el);
        if (!candidateText) continue;
        const cleanCandidate = normalize(candidateText);
        if (cleanCandidate.includes(cleanTarget) || cleanTarget.includes(cleanCandidate)) {
          return isClickableElement(el) ? el : findClosestClickableParent(el) || el;
        }
      }
    }

    // Fallback: find any element whose text equals or contains target, then use clickable parent (for div/span/label with text but no role)
    const fallbackSelector = 'button, a, label, [role="button"], [role="option"], [role="menuitem"], [role="link"], div, span, li';
    const allWithText = root.querySelectorAll(fallbackSelector);
    const maxFallback = 2000;
    for (let i = 0; i < Math.min(allWithText.length, maxFallback); i++) {
      const el = allWithText[i];
      const candidateText = (el.textContent || '').trim();
      if (!candidateText) continue;
      const candidateLower = candidateText.toLowerCase();
      if (candidateLower === targetText || candidateLower.includes(targetText) || targetText.includes(candidateLower)) {
        const clickable = isClickableElement(el) ? el : findClosestClickableParent(el);
        if (clickable) return clickable;
      }
    }

    return null;
  }

  // Helper function to find checkbox by label/value text
  function findCheckboxByText(textContent, root = document, exactOnly = false) {
    if (!textContent || !root) return null;
    const targetText = String(textContent).trim().toLowerCase();
    if (!targetText) return null;

    const checkboxes = Array.from(root.querySelectorAll('input[type="checkbox"]'));
    const normalize = (val) => String(val || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    const cleanTarget = normalize(targetText);

    for (const checkbox of checkboxes) {
      let label = checkbox.closest('label');
      let labelText = label ? label.textContent.trim() : '';
      if (!labelText && checkbox.id) {
        const associatedLabel = root.querySelector('label[for="' + CSS.escape(checkbox.id) + '"]');
        if (associatedLabel) {
          label = associatedLabel;
          labelText = associatedLabel.textContent.trim();
        }
      }
      // Sibling text: e.g. <input type="checkbox">Access Equipment<br>
      let siblingText = '';
      let node = checkbox.nextSibling;
      while (node) {
        if (node.nodeType === Node.TEXT_NODE) {
          siblingText += node.textContent || '';
          node = node.nextSibling;
          continue;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          const tag = (node.tagName || '').toLowerCase();
          if (tag === 'br') break;
          if (tag === 'span' || tag === 'label') siblingText += (node.textContent || '').trim();
          break;
        }
        node = node.nextSibling;
      }
      siblingText = siblingText.trim();
      const ariaLabel = checkbox.getAttribute('aria-label') || '';
      const dataName = checkbox.getAttribute('data-name') || '';
      const dataValue = checkbox.getAttribute('data-value') || '';
      const value = checkbox.value || '';
      const candidates = [labelText, siblingText, ariaLabel, dataName, dataValue, value].filter(Boolean);

      for (const candidate of candidates) {
        const candidateText = String(candidate).trim().toLowerCase();
        if (!candidateText) continue;
        if (candidateText === targetText) return checkbox;
        if (exactOnly) continue;
        if (candidateText.includes(targetText) || targetText.includes(candidateText)) return checkbox;

        const cleanCandidate = normalize(candidateText);
        if (cleanCandidate && cleanTarget && (cleanCandidate.includes(cleanTarget) || cleanTarget.includes(cleanCandidate))) {
          return checkbox;
        }
      }
    }

    return null;
  }
  
  function findElement(selector) {
    // Check if selector is HTML element format (e.g., "<strong>Add Text</strong>")
    const htmlSelector = parseHtmlSelector(selector);
    
    if (htmlSelector) {
      console.log(`üîç [HTML_SELECTOR] Parsed HTML selector: tag="${htmlSelector.tagName}", text="${htmlSelector.textContent}"`);
      
      // Try main document first
      let el = findElementByText(htmlSelector.tagName, htmlSelector.textContent, document);
      if (el) {
        console.log(`‚úÖ Element found in main document by text: ${htmlSelector.tagName} with text "${htmlSelector.textContent}"`);
        
        // Check if the found element is clickable
        if (isClickableElement(el)) {
          console.log(`üéØ Element is directly clickable: ${selector}`);
          return el;
        }
        
        // If not clickable, try to find the closest clickable parent
        const clickableParent = findClosestClickableParent(el);
        if (clickableParent) {
          console.log(`üéØ Found clickable parent for inner element: ${selector} -> ${clickableParent.tagName.toLowerCase()}${clickableParent.className ? '.' + clickableParent.className.split(' ').join('.') : ''}`);
          return clickableParent;
        }
        
        // Return original element if no clickable parent found
        console.log(`‚ö†Ô∏è Element found but no clickable parent detected: ${selector}`);
        return el;
      }
      
      // Try iframes
      const iframes = document.querySelectorAll('iframe');
      for (const iframe of iframes) {
        try {
          if (iframe.contentDocument) {
            el = findElementByText(htmlSelector.tagName, htmlSelector.textContent, iframe.contentDocument);
            if (el) {
              console.log(`‚úÖ Element found in iframe by text: ${htmlSelector.tagName} with text "${htmlSelector.textContent}"`);
              
              if (isClickableElement(el)) {
                return el;
              }
              
              const clickableParent = findClosestClickableParent(el);
              if (clickableParent) {
                return clickableParent;
              }
              
              return el;
            }
          }
        } catch (e) {
          // Cross-origin iframe, skip
        }
      }
      
      // Try shadow DOM
      const allElements = document.querySelectorAll('*');
      for (const element of allElements) {
        if (element.shadowRoot) {
          el = findElementByText(htmlSelector.tagName, htmlSelector.textContent, element.shadowRoot);
          if (el) {
            console.log(`‚úÖ Element found in shadow DOM by text: ${htmlSelector.tagName} with text "${htmlSelector.textContent}"`);
            
            if (isClickableElement(el)) {
              return el;
            }
            
            const clickableParent = findClosestClickableParent(el);
            if (clickableParent) {
              return clickableParent;
            }
            
            return el;
          }
        }
      }
      
      console.log(`‚ùå Element not found by text: ${htmlSelector.tagName} with text "${htmlSelector.textContent}"`);
      return null;
    }
    
    // Normal CSS selector handling
    // Try main document first
    let el = document.querySelector(selector);
    if (el) {
      console.log(`‚úÖ Element found in main document: ${selector}`);
      
      // Check if the found element is clickable
      if (isClickableElement(el)) {
        console.log(`üéØ Element is directly clickable: ${selector}`);
        return el;
      }
      
      // If not clickable, try to find the closest clickable parent
      const clickableParent = findClosestClickableParent(el);
      if (clickableParent) {
        console.log(`üéØ Found clickable parent for inner element: ${selector} -> ${clickableParent.tagName.toLowerCase()}${clickableParent.className ? '.' + clickableParent.className.split(' ').join('.') : ''}`);
        return clickableParent;
      }
      
      // Return original element if no clickable parent found
      console.log(`‚ö†Ô∏è Element found but no clickable parent detected: ${selector}`);
      return el;
    }
    
    // Fallback: Try to find by onclick attribute content (for elements like onclick="modal.add(...)")
    // Check if selector might be trying to match onclick content
    if (selector.includes('onclick') || selector.includes('modal.') || selector.includes('MY ACCOUNT')) {
      console.log(`üîç [FALLBACK] Trying to find element by onclick attribute or text content...`);
      
      // Try finding by onclick attribute
      const allLinks = document.querySelectorAll('a[onclick]');
      for (const link of allLinks) {
        const onclickAttr = link.getAttribute('onclick') || '';
        // Check if onclick contains common patterns
        if (onclickAttr.includes('modal.add') || onclickAttr.includes('modal') || 
            onclickAttr.includes('/login/') || onclickAttr.includes('layer')) {
          // Also check text content if selector mentions text
          if (selector.includes('MY ACCOUNT') || selector.includes('ACCOUNT')) {
            const linkText = link.textContent.trim().toUpperCase();
            if (linkText.includes('MY ACCOUNT') || linkText.includes('ACCOUNT')) {
              console.log(`‚úÖ [FALLBACK] Found element by onclick attribute and text: ${linkText}`);
              return link;
            }
          } else {
            // Return first match if no text requirement
            console.log(`‚úÖ [FALLBACK] Found element by onclick attribute: ${onclickAttr.substring(0, 50)}...`);
            return link;
          }
        }
      }
      
      // Try finding by text content if selector contains text
      if (selector.includes('MY ACCOUNT') || selector.includes('ACCOUNT')) {
        const textElements = document.querySelectorAll('a');
        for (const elem of textElements) {
          const elemText = elem.textContent.trim().toUpperCase();
          if (elemText === 'MY ACCOUNT' || elemText.includes('MY ACCOUNT')) {
            // Also check if it has onclick attribute
            if (elem.getAttribute('onclick')) {
              console.log(`‚úÖ [FALLBACK] Found element by text content and onclick: ${elemText}`);
              return elem;
            }
          }
        }
      }
    }
    
    // Try iframes
    const iframes = document.querySelectorAll('iframe');
    for (const iframe of iframes) {
      try {
        if (iframe.contentDocument) {
          el = iframe.contentDocument.querySelector(selector);
          if (el) {
            console.log(`‚úÖ Element found in iframe: ${selector}`);
            
            // Check if the found element is clickable
            if (isClickableElement(el)) {
              console.log(`üéØ Element is directly clickable: ${selector}`);
              return el;
            }
            
            // If not clickable, try to find the closest clickable parent
            const clickableParent = findClosestClickableParent(el);
            if (clickableParent) {
              console.log(`üéØ Found clickable parent for inner element: ${selector} -> ${clickableParent.tagName.toLowerCase()}${clickableParent.className ? '.' + clickableParent.className.split(' ').join('.') : ''}`);
              return clickableParent;
            }
            
            return el;
          }
        }
      } catch (e) {
        // Cross-origin iframe, skip
      }
    }
    
    // Try shadow DOM
    const allElements = document.querySelectorAll('*');
    for (const element of allElements) {
      if (element.shadowRoot) {
        el = element.shadowRoot.querySelector(selector);
        if (el) {
          console.log(`‚úÖ Element found in shadow DOM: ${selector}`);
          
          // Check if the found element is clickable
          if (isClickableElement(el)) {
            console.log(`üéØ Element is directly clickable: ${selector}`);
            return el;
          }
          
          // If not clickable, try to find the closest clickable parent
          const clickableParent = findClosestClickableParent(el);
          if (clickableParent) {
            console.log(`üéØ Found clickable parent for inner element: ${selector} -> ${clickableParent.tagName.toLowerCase()}${clickableParent.className ? '.' + clickableParent.className.split(' ').join('.') : ''}`);
            return clickableParent;
          }
          
          return el;
        }
      }
    }
    
    // Final fallback: Try to find by onclick attribute or text in iframes and shadow DOM
    if (selector.includes('onclick') || selector.includes('modal.') || selector.includes('MY ACCOUNT')) {
      console.log(`üîç [FINAL_FALLBACK] Trying to find element by onclick/text in iframes and shadow DOM...`);
      
      // Try iframes
      const iframes = document.querySelectorAll('iframe');
      for (const iframe of iframes) {
        try {
          if (iframe.contentDocument) {
            const iframeLinks = iframe.contentDocument.querySelectorAll('a[onclick]');
            for (const link of iframeLinks) {
              const onclickAttr = link.getAttribute('onclick') || '';
              if (onclickAttr.includes('modal.add') || onclickAttr.includes('modal') || 
                  onclickAttr.includes('/login/') || onclickAttr.includes('layer')) {
                if (selector.includes('MY ACCOUNT') || selector.includes('ACCOUNT')) {
                  const linkText = link.textContent.trim().toUpperCase();
                  if (linkText.includes('MY ACCOUNT') || linkText.includes('ACCOUNT')) {
                    console.log(`‚úÖ [FINAL_FALLBACK] Found element in iframe by onclick and text`);
                    return link;
                  }
                } else {
                  console.log(`‚úÖ [FINAL_FALLBACK] Found element in iframe by onclick`);
                  return link;
                }
              }
            }
          }
        } catch (e) {
          // Cross-origin iframe, skip
        }
      }
    }
    
    console.log(`‚ùå Element not found in any context: ${selector}`);
    return null;
  }

  // Enhanced element finder with MutationObserver support
  function createElementObserver(selector, timeout = 15000) {
    return new Promise((resolve, reject) => {
      const startTime = performance.now();
      
      // Check if selector is HTML element format
      const htmlSelector = parseHtmlSelector(selector);
      
      // First, try to find element immediately
      let element = findElement(selector);
      if (element) {
        resolve(element);
        return;
      }
      
      // Set up MutationObserver to watch for DOM changes
      const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          // Check for added nodes
          for (const node of mutation.addedNodes) {
            if (node.nodeType === Node.ELEMENT_NODE) {
              // Handle HTML selector format
              if (htmlSelector) {
                // Check if the added node matches our HTML selector
                if (node.tagName && node.tagName.toLowerCase() === htmlSelector.tagName) {
                  const nodeText = node.textContent.trim();
                  if (nodeText.toLowerCase() === htmlSelector.textContent.toLowerCase() ||
                      nodeText.toLowerCase().includes(htmlSelector.textContent.toLowerCase())) {
                    observer.disconnect();
                    resolve(node);
                    return;
                  }
                }
                
                // Check if any child elements match
                if (node.querySelectorAll) {
                  const matches = node.querySelectorAll(htmlSelector.tagName);
                  for (const match of matches) {
                    const matchText = match.textContent.trim();
                    if (matchText.toLowerCase() === htmlSelector.textContent.toLowerCase() ||
                        matchText.toLowerCase().includes(htmlSelector.textContent.toLowerCase())) {
                      observer.disconnect();
                      resolve(match);
                      return;
                    }
                  }
                }
              } else {
                // Normal CSS selector handling
                // Check if the added element matches our selector
                if (node.matches && node.matches(selector)) {
                  observer.disconnect();
                  resolve(node);
                  return;
                }
                // Check if any child elements match
                const childMatch = node.querySelector && node.querySelector(selector);
                if (childMatch) {
                  observer.disconnect();
                  resolve(childMatch);
                  return;
                }
              }
            }
          }
          
          // Check for attribute changes (for dynamic elements)
          if (mutation.type === 'attributes') {
            const target = mutation.target;
            
            if (htmlSelector) {
              // For HTML selectors, check if text content changed to match
              if (target.tagName && target.tagName.toLowerCase() === htmlSelector.tagName) {
                const targetText = target.textContent.trim();
                if (targetText.toLowerCase() === htmlSelector.textContent.toLowerCase() ||
                    targetText.toLowerCase().includes(htmlSelector.textContent.toLowerCase())) {
                  observer.disconnect();
                  resolve(target);
                  return;
                }
              }
            } else {
              // Normal CSS selector
              if (target.matches && target.matches(selector)) {
                observer.disconnect();
                resolve(target);
                return;
              }
            }
          }
        }
      });
      
      // Start observing
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['class', 'style', 'hidden', 'aria-hidden']
      });
      
      // Set timeout fallback
      const timeoutId = setTimeout(() => {
        observer.disconnect();
        reject(new Error(`Timeout waiting for element: ${selector}`));
      }, timeout);
      
      // Cleanup function
      const cleanup = () => {
        observer.disconnect();
        clearTimeout(timeoutId);
      };
      
      // Return cleanup function for manual disconnection
      resolve.cleanup = cleanup;
    });
  }

  // Advanced element detection for complex sites
  function waitForElementAdvanced(selector, options = {}) {
    const {
      timeout = 15000,
      retryInterval = 100,
      maxRetries = 50,
      checkVisibility = true,
      checkInteractable = true,
      waitForStable = false,
      stableTimeout = 1000
    } = options;
    
    return new Promise(async (resolve) => {
      const startTime = performance.now();
      let retryCount = 0;
      
      const checkElement = async () => {
        const element = findElement(selector);
        
        if (!element) {
          if (retryCount >= maxRetries) {
            console.warn(`‚ö†Ô∏è Max retries reached for: ${selector}`);
            resolve(null);
            return;
          }
          retryCount++;
          setTimeout(checkElement, retryInterval);
          return;
        }
        
        // Check visibility if required
        if (checkVisibility) {
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          const isVisible = rect.width > 0 && rect.height > 0 && 
                           style.display !== 'none' && 
                           style.visibility !== 'hidden' &&
                           style.opacity !== '0';
          
          if (!isVisible) {
            console.log(`‚è≥ Element found but not visible yet: ${selector}`);
            setTimeout(checkElement, retryInterval);
            return;
          }
        }
        
        // Check if interactable if required
        if (checkInteractable) {
          const rect = element.getBoundingClientRect();
          const isInteractable = rect.width > 0 && rect.height > 0;
          
          if (!isInteractable) {
            console.log(`‚è≥ Element found but not interactable yet: ${selector}`);
            setTimeout(checkElement, retryInterval);
            return;
          }
        }
        
        // Wait for element to be stable if required
        if (waitForStable) {
          await new Promise(resolve => setTimeout(resolve, stableTimeout));
          const stableElement = findElement(selector);
          if (stableElement === element) {
            console.log(`‚úÖ Element stable and ready: ${selector}`);
            resolve(element);
          } else {
            console.log(`üîÑ Element changed, retrying: ${selector}`);
            setTimeout(checkElement, retryInterval);
          }
          return;
        }
        
        console.log(`‚úÖ Element ready: ${selector}`);
        resolve(element);
      };
      
      // Start checking
      checkElement();
      
      // Set overall timeout
      setTimeout(() => {
        console.warn(`‚è∞ Overall timeout reached for: ${selector}`);
        resolve(null);
      }, timeout);
    });
  }

  // Enhanced findElement with better iframe and shadow DOM support
  function findElementEnhanced(selector, options = {}) {
    const {
      searchIframes = true,
      searchShadowDOM = true,
      searchFrames = true,
      maxDepth = 10
    } = options;
    
    // Check if selector is HTML element format
    const htmlSelector = parseHtmlSelector(selector);
    
    // Helper function to process found element and find clickable parent if needed
    const processFoundElement = (element, context) => {
      if (!element) return null;
      
      console.log(`‚úÖ Element found in ${context}: ${selector}`);
      
      // Check if the found element is clickable
      if (isClickableElement(element)) {
        console.log(`üéØ Element is directly clickable: ${selector}`);
        return element;
      }
      
      // If not clickable, try to find the closest clickable parent
      const clickableParent = findClosestClickableParent(element);
      if (clickableParent) {
        console.log(`üéØ Found clickable parent for inner element: ${selector} -> ${clickableParent.tagName.toLowerCase()}${clickableParent.className ? '.' + clickableParent.className.split(' ').join('.') : ''}`);
        return clickableParent;
      }
      
      // Return original element if no clickable parent found
      console.log(`‚ö†Ô∏è Element found but no clickable parent detected: ${selector}`);
      return element;
    };
    
    // Handle HTML selector format
    if (htmlSelector) {
      console.log(`üîç [HTML_SELECTOR] Parsed HTML selector: tag="${htmlSelector.tagName}", text="${htmlSelector.textContent}"`);
      
      // Try main document first
      let el = findElementByText(htmlSelector.tagName, htmlSelector.textContent, document);
      if (el) {
        return processFoundElement(el, 'main document');
      }
      
      // Search iframes
      if (searchIframes) {
        const iframes = document.querySelectorAll('iframe');
        for (const iframe of iframes) {
          try {
            if (iframe.contentDocument) {
              el = findElementByText(htmlSelector.tagName, htmlSelector.textContent, iframe.contentDocument);
              if (el) {
                return processFoundElement(el, 'iframe');
              }
            }
          } catch (e) {
            // Cross-origin iframe, skip
          }
        }
      }
      
      // Search frames
      if (searchFrames && window.frames) {
        for (let i = 0; i < window.frames.length; i++) {
          try {
            const frame = window.frames[i];
            if (frame.document) {
              el = findElementByText(htmlSelector.tagName, htmlSelector.textContent, frame.document);
              if (el) {
                return processFoundElement(el, 'frame');
              }
            }
          } catch (e) {
            // Cross-origin frame, skip
          }
        }
      }
      
      // Search shadow DOM recursively
      if (searchShadowDOM) {
        const searchShadowDOMRecursive = (root, depth = 0) => {
          if (depth > maxDepth) return null;
          
          const allElements = root.querySelectorAll('*');
          for (const element of allElements) {
            if (element.shadowRoot) {
              // Search in this shadow root
              const shadowEl = findElementByText(htmlSelector.tagName, htmlSelector.textContent, element.shadowRoot);
              if (shadowEl) {
                return processFoundElement(shadowEl, `shadow DOM (depth ${depth})`);
              }
              
              // Recursively search nested shadow roots
              const nestedEl = searchShadowDOMRecursive(element.shadowRoot, depth + 1);
              if (nestedEl) return nestedEl;
            }
          }
          return null;
        };
        
        el = searchShadowDOMRecursive(document);
        if (el) return el;
      }
      
      console.log(`‚ùå Element not found in any context by text: ${htmlSelector.tagName} with text "${htmlSelector.textContent}"`);
      return null;
    }
    
    // Normal CSS selector handling
    // Try main document first
    let el = document.querySelector(selector);
    if (el) {
      return processFoundElement(el, 'main document');
    }
    
    // Search iframes
    if (searchIframes) {
      const iframes = document.querySelectorAll('iframe');
      for (const iframe of iframes) {
        try {
          if (iframe.contentDocument) {
            el = iframe.contentDocument.querySelector(selector);
            if (el) {
              return processFoundElement(el, 'iframe');
            }
          }
        } catch (e) {
          // Cross-origin iframe, skip
        }
      }
    }
    
    // Search frames
    if (searchFrames && window.frames) {
      for (let i = 0; i < window.frames.length; i++) {
        try {
          const frame = window.frames[i];
          if (frame.document) {
            el = frame.document.querySelector(selector);
            if (el) {
              return processFoundElement(el, 'frame');
            }
          }
        } catch (e) {
          // Cross-origin frame, skip
        }
      }
    }
    
    // Search shadow DOM recursively
    if (searchShadowDOM) {
      const searchShadowDOMRecursive = (root, depth = 0) => {
        if (depth > maxDepth) return null;
        
        const allElements = root.querySelectorAll('*');
        for (const element of allElements) {
          if (element.shadowRoot) {
            // Search in this shadow root
            const shadowEl = element.shadowRoot.querySelector(selector);
            if (shadowEl) {
              return processFoundElement(shadowEl, `shadow DOM (depth ${depth})`);
            }
            
            // Recursively search nested shadow roots
            const nestedEl = searchShadowDOMRecursive(element.shadowRoot, depth + 1);
            if (nestedEl) return nestedEl;
          }
        }
        return null;
      };
      
      el = searchShadowDOMRecursive(document);
      if (el) return el;
    }
    
    console.log(`‚ùå Element not found in any context: ${selector}`);
    return null;
  }

  // Enhanced utility: Wait for an element to appear using MutationObserver with polling fallback
  function waitFor(selector, timeout = 15000) {
    return new Promise(async (resolve) => {
      const start = performance.now();
      
      try {
        // Try MutationObserver first for better performance
        const element = await createElementObserver(selector, timeout);
        console.log(`‚úÖ Element found via MutationObserver: ${selector}`);
        
        // Check if element is visible and interactable
        const rect = element.getBoundingClientRect();
        const isVisible = rect.width > 0 && rect.height > 0 && 
                         window.getComputedStyle(element).display !== 'none' && 
                         window.getComputedStyle(element).visibility !== 'hidden';
        console.log(`   ‚Ä¢ Visible: ${isVisible} (${rect.width}x${rect.height})`);
        console.log(`   ‚Ä¢ Display: ${window.getComputedStyle(element).display}`);
        console.log(`   ‚Ä¢ Visibility: ${window.getComputedStyle(element).visibility}`);
        
        resolve(element);
      } catch (error) {
        console.warn(`‚ö†Ô∏è MutationObserver failed for ${selector}, falling back to polling:`, error.message);
        
        // Fallback to polling if MutationObserver fails
        const poll = () => {
          const el = findElement(selector);
          if (el) {
            console.log(`‚úÖ Element found via polling: ${selector}`);
            // Check if element is visible and interactable
            const rect = el.getBoundingClientRect();
            const isVisible = rect.width > 0 && rect.height > 0 && 
                             window.getComputedStyle(el).display !== 'none' && 
                             window.getComputedStyle(el).visibility !== 'hidden';
            console.log(`   ‚Ä¢ Visible: ${isVisible} (${rect.width}x${rect.height})`);
            console.log(`   ‚Ä¢ Display: ${window.getComputedStyle(el).display}`);
            console.log(`   ‚Ä¢ Visibility: ${window.getComputedStyle(el).visibility}`);
            return resolve(el);
          }
          if (performance.now() - start > timeout) {
            console.warn(`‚è∞ Timeout waiting for element: ${selector}`);
            // Only show debug info for name selectors and only on first timeout
            if (selector.includes('name=')) {
              const allNameElements = document.querySelectorAll('[name]');
              console.log(`üîç Debug: Found ${allNameElements.length} elements with 'name' attribute:`);
              allNameElements.forEach((elem, index) => {
                const name = elem.getAttribute('name');
                if (name === 'name') {
                  console.log(`   ‚úÖ Target element found: [name="${name}"] - ${elem.tagName}${elem.className ? '.' + elem.className : ''}`);
                  console.log(`   HTML: ${elem.outerHTML}`);
                }
              });
            }
            return resolve(null);
          }
          // Use setTimeout instead of requestAnimationFrame for better performance
          setTimeout(poll, 100);
        };
        poll();
      }
    });
  }

  // Pause and wait for user resume if selector is missing
  async function pauseOnMissing(selector) {
    paused = true;
    showToast(`Paused: missing ${selector}`);
    console.warn(`‚è∏Ô∏è Paused: missing ${selector}`);
    updateAutomationStatus(AutomationStatus.PAUSED, { error: `Missing element: ${selector}` });
    reportAutomationStatus({ isRunning: false, status: 'paused', error: `Missing element: ${selector}` });
    
    // Wait for user resume only - no auto-resume
    await new Promise((r) => {
      resumeSignal = () => {
        r();
      };
    });
    
    if (AUTOMATION_STATE.isAborted()) throw new Error("Aborted");
    paused = false;
    updateAutomationStatus(AutomationStatus.RUNNING);
    reportAutomationStatus({ isRunning: true, status: 'resumed' });
  }

  // Report automation status to popup
  function reportAutomationStatus(status) {
    automationStatus = { ...automationStatus, ...status, lastUpdated: new Date().toISOString(), domain: extractBaseDomain(window.location.hostname) };
    
    // Store domain-specific automation status (not tab-specific)
    const domain = extractBaseDomain(window.location.hostname);
    const domainStatusKey = `automationStatus_${domain}`;
    
    safeChromeCall(() => {
      CHROME_API.storage.local.set({ [domainStatusKey]: automationStatus }, () => {
        if (CHROME_API.lastError) {
          console.warn("Extension context invalidated (storage):", CHROME_API.lastError.message);
        } else {
          console.log(`üè∑Ô∏è [DOMAIN] Stored automation status for domain ${domain}`);
        }
      });
    });
    
    safeChromeCall(() => {
      CHROME_API.runtime.sendMessage({
        action: 'updateAutomationStatus',
        status: automationStatus
      }, () => {
        if (CHROME_API.lastError) {
          console.warn("Extension context invalidated (sendMessage):", CHROME_API.lastError.message);
        }
      });
    });
  }

  // Notify popup of automation status
  function notifyPopupOfAutomationStatus(isRunning) {
    reportAutomationStatus({ isRunning });
  }

  // Send system notification to background script (non-blocking)
  function sendSystemNotification(title, message) {
    // Use setTimeout to make it non-blocking and fire-and-forget
    setTimeout(() => {
      try {
        // Extract domain name from current page
        const domain = extractBaseDomain(window.location.hostname);
        
        // Determine action type from title if not provided
        let actionType = null;
        if (title && title.toLowerCase().includes('error')) {
          actionType = 'error';
        } else if (title && title.toLowerCase().includes('paused')) {
          actionType = 'pause';
        } else if (title && title.toLowerCase().includes('complete')) {
          actionType = 'completed';
        }
        
        CHROME_API.runtime.sendMessage({
          type: "SHOW_AUTOMATION_NOTIFICATION",
          title: title || "CB-PHAA Automation",
          message: message || "Automation status update",
          domain: domain,
          action: actionType
        }, (response) => {
          // Fire-and-forget: don't wait for response or handle errors
          // This ensures notifications don't block automation flow
          if (CHROME_API.lastError) {
            console.warn("‚ö†Ô∏è [NOTIFICATION] Could not send notification:", CHROME_API.lastError.message);
          } else {
            console.log("üì¢ [NOTIFICATION] Notification sent:", title, `[${domain}] [${actionType || 'unknown'}]`);
          }
        });
      } catch (error) {
        // Silently fail - notifications are non-critical
        console.warn("‚ö†Ô∏è [NOTIFICATION] Error sending notification:", error.message);
      }
    }, 0);
  }

  // Get domain configuration from IndexedDB or fallback to local JSON
  async function getDomainConfig(domain) {
    try {
      console.log(`üîç Getting domain config for: ${domain}`);
      
      // First, try to get from IndexedDB via background script
      const response = await new Promise((resolve) => {
        CHROME_API.runtime.sendMessage({ 
          type: "GET_CONSOLIDATION_SETUP", 
          domainName: domain 
        }, (response) => {
          if (CHROME_API.lastError) {
            console.error("‚ùå Chrome runtime error:", CHROME_API.lastError.message);
            resolve({ success: false, error: CHROME_API.lastError.message });
          } else {
            // Handle case where response is undefined or null
            if (response === undefined || response === null) {
              console.error("‚ùå Background script returned undefined response");
              resolve({ success: false, error: "Background script returned undefined response" });
            } else {
              resolve(response);
            }
          }
        });
      });
      
      // Add additional safety checks
      if (!response) {
        console.error("‚ùå No response received from background script");
        // Return empty config instead of falling back to local file
        return {};
      }
      
      console.log("üîç [DEBUG] Background script response:", response);
      
      if (response.success && response.setup && response.setup.config) {
        console.log(`‚úÖ Found domain config for: ${domain} from Firestore/IndexedDB`);
        console.log("üîç [DEBUG] Domain config:", response.setup.config);
        return response.setup.config;
      } else {
        console.warn(`‚ö†Ô∏è No domain config found for: ${domain}`);
        console.warn("‚ö†Ô∏è Response details:", {
          success: response.success,
          error: response.error,
          setup: response.setup,
          fullResponse: response
        });
        
        // Return empty config instead of falling back to local file
        // Local file fallback removed - all configs should come from Firestore
        console.log("‚ÑπÔ∏è Returning empty config (no Firestore data available)");
        return {};
      }
    } catch (err) {
      console.error("‚ùå Error loading domain config:", err);
      console.error("‚ùå Error details:", {
        message: err.message,
        stack: err.stack,
        name: err.name
      });
      
      // Return empty config instead of falling back to local file
      // All configs should come from Firestore
      console.log("‚ÑπÔ∏è Returning empty config due to error");
      return {};
    }
  }

  // Fallback function to get domain config from local JSON file
  async function getDomainConfigFromLocal(domain) {
    try {
      console.log(`üîç Loading domain config from local consoSetup.json for: ${domain}`);
      
      // Fetch the local consoSetup.json file
      const response = await fetch(CHROME_API.runtime.getURL('automation/consoSetup.json'));
      if (!response.ok) {
        throw new Error(`Failed to fetch consoSetup.json: ${response.status}`);
      }
      
      const consoSetupData = await response.json();
      console.log(`üìä Loaded ${consoSetupData.length} consolidation setups from local file`);
      
      // Find the configuration for the specific domain
      const domainConfig = consoSetupData.find(setup => 
        setup.Sites && setup.Sites.toLowerCase() === domain.toLowerCase()
      );
      
      if (domainConfig) {
        console.log(`‚úÖ Found domain config for: ${domain} in local file`);
        console.log("üîç [DEBUG] Domain config from local file:", domainConfig);
        
        // Remove the Sites field and return the configuration
        const { Sites, ...config } = domainConfig;
        return config;
      } else {
        console.warn(`‚ö†Ô∏è No domain config found in local file for: ${domain}`);
        console.log("üîç Available domains in local file:", consoSetupData.map(s => s.Sites).filter(Boolean));
        return {};
      }
    } catch (err) {
      console.error("‚ùå Error loading domain config from local file:", err);
      console.error("‚ùå Error details:", {
        message: err.message,
        stack: err.stack,
        name: err.name
      });
      return {};
    }
  }

  // --- Centralized Automation Status Management ---
  const AutomationStatus = {
    IDLE: 'idle',
    STARTING: 'starting',
    RUNNING: 'running',
    PAUSED: 'paused',
    COMPLETED: 'completed',
    ABORTED: 'aborted',
    ERROR: 'error'
  };

  // Global automation state
  let automationState = {
    status: AutomationStatus.IDLE,
    currentStep: 0,
    totalSteps: 0,
    startTime: null,
    endTime: null,
    error: null,
    isCompleted: false,
    domain: null,
    sessionId: null
  };

  // Centralized status management functions
  function updateAutomationStatus(newStatus, details = {}) {
    const previousStatus = automationState.status;
    automationState = { ...automationState, ...details, status: newStatus };
    
    console.log(`üîÑ Automation Status: ${previousStatus} ‚Üí ${newStatus}`, details);
    
    // Update global state
    AUTOMATION_STATE.update({
      status: newStatus,
      isCompleted: newStatus === AutomationStatus.COMPLETED
    });
    
    // Report to popup
    reportAutomationStatus({
      isRunning: [AutomationStatus.STARTING, AutomationStatus.RUNNING].includes(newStatus),
      status: newStatus,
      currentStep: automationState.currentStep,
      totalSteps: automationState.totalSteps,
      error: automationState.error,
      isCompleted: automationState.isCompleted
    });
    
    // Update page title
    updatePageTitle(newStatus);
  }

  function updatePageTitle(status) {
    const statusConfig = {
      [AutomationStatus.IDLE]: { emoji: '', text: '' },
      [AutomationStatus.STARTING]: { emoji: 'üöÄ', text: 'Automation Running' },
      [AutomationStatus.RUNNING]: { emoji: 'üöÄ', text: 'Automation Running' },
      [AutomationStatus.PAUSED]: { emoji: '‚è∏Ô∏è', text: 'Automation Paused' },
      [AutomationStatus.COMPLETED]: { emoji: '‚úÖ', text: 'Automation Complete' },
      [AutomationStatus.ABORTED]: { emoji: '‚õî', text: 'Automation Aborted' },
      [AutomationStatus.ERROR]: { emoji: '‚è∏Ô∏è', text: 'Automation Paused' } // Error should show as paused
    };
    
    const config = statusConfig[status] || { emoji: '', text: '' };
    if (config.emoji && config.text) {
      document.title = `${config.emoji} ${config.text}`;
    } else {
      // Restore original title if no status
      const originalTitle = document.title.replace(/^[üöÄ‚è∏Ô∏è‚õî‚úÖ]\s+Automation\s+(Running|Paused|Aborted|Complete)\s*/, '').trim();
      document.title = originalTitle || document.title;
    }
  }

  async function canStartAutomation() {
    // Simple check: only prevent if automation is currently running
    if (automationRunning || automationStarting) {
      console.log(`‚ö†Ô∏è Automation already running/starting, cannot start new automation`);
      return false;
    }
    
    return true;
  }

  function resetAutomationState() {
    automationState = {
      status: AutomationStatus.IDLE,
      currentStep: 0,
      totalSteps: 0,
      startTime: null,
      endTime: null,
      error: null,
      isCompleted: false,
      domain: extractBaseDomain(window.location.hostname),
      sessionId: Date.now().toString()
    };
    
    AUTOMATION_STATE.update({
      status: AutomationStatus.IDLE,
      isCompleted: false,
      aborted: false,
      paused: false
    });
    
    console.log("üîÑ Automation state reset");
  }

  // --- Automation Control Setup ---
  function setupControls() {
    AUTOMATION_STATE.set({
      paused: false,
      aborted: false,
      status: AutomationStatus.IDLE,
      isCompleted: false
    });
          CHROME_API.runtime.onMessage.addListener((request, sender, sendResponse) => {
        const state = AUTOMATION_STATE.get();
        switch (request.command) {
          case "pause":
            if (automationRunning) {
              state.paused = true;
              updateAutomationStatus(AutomationStatus.PAUSED);
            console.log("‚è∏Ô∏è Automation paused");
            sendResponse && sendResponse({ success: true, status: 'paused' });
          } else {
            console.warn("‚ö†Ô∏è Cannot pause: automation not running");
            sendResponse && sendResponse({ success: false, error: 'Automation not running' });
          }
          break;
        case "resume":
          console.log("‚ñ∂Ô∏è [RESUME] Play button pressed");
          
          // Check if automation is paused or aborted
          if (state.paused || state.aborted) {
            console.log("‚ñ∂Ô∏è [RESUME] Resuming from paused/aborted state");
            
            // Reset states
            state.paused = false;
            state.aborted = false;
            
            // Resume signal if waiting
            if (resumeSignal) {
              resumeSignal();
              resumeSignal = null;
            }
            
            // Start automation
            if (!automationRunning && !automationStarting) {
              console.log("üöÄ [RESUME] Starting automation from current resumeIndex");
              runAutomation(false);
              sendResponse && sendResponse({ success: true, status: 'resumed' });
            } else {
              console.log("‚ö†Ô∏è [RESUME] Automation already running/starting");
              sendResponse && sendResponse({ success: true, status: 'already_running' });
            }
          } else if (automationRunning && state.paused) {
            // Handle normal pause/resume
            state.paused = false;
            if (resumeSignal) {
              resumeSignal();
              resumeSignal = null;
            }
            updateAutomationStatus(AutomationStatus.RUNNING);
            console.log("‚ñ∂Ô∏è Automation resumed");
            sendResponse && sendResponse({ success: true, status: 'resumed' });
          } else if (!automationRunning && canStartAutomation()) {
            console.log("üöÄ Starting fresh automation");
            runAutomation(false);
            sendResponse && sendResponse({ success: true, status: 'started' });
          } else {
            console.warn("‚ö†Ô∏è Cannot resume: automation not paused or cannot start");
            sendResponse && sendResponse({ success: false, error: 'Automation not paused or cannot start' });
          }
          break;
          case "abort":
            console.log("üõë [ABORT] Automation aborted by user");
            state.aborted = true;
            paused = false;
            if (resumeSignal) {
              resumeSignal();
              resumeSignal = null;
            }
            automationRunning = false;
            automationStarting = false;
            
            // Reset resume index (domain + current run) and clear completion flag on abort
            clearResumeIndex();
            console.log(`üõë [ABORT] Resume index reset to 0 for domain ${extractBaseDomain(window.location.hostname)}`);
            const completionKey = getTabSpecificCompletionKey();
            CHROME_API.storage.local.remove([completionKey], () => {
              console.log(`üõë [ABORT] Completion flag cleared for domain ${extractBaseDomain(window.location.hostname)}`);
            });
            
            updateAutomationStatus(AutomationStatus.ABORTED, {
              error: 'User aborted automation'
            });
            console.log(`üõë Automation aborted - resumeIndex reset to 0`);
            
            // Save automation accumulation with ABORTED status
            (async () => {
              try {
                const userData = await new Promise((resolve) => {
                  CHROME_API.storage.local.get(["userId"], (result) => {
                    if (CHROME_API.lastError) {
                      console.warn("Storage error:", CHROME_API.lastError.message);
                      resolve({});
                    } else {
                      resolve(result);
                    }
                  });
                });
                
                const userId = userData.userId;
                const domainName = extractBaseDomain(window.location.hostname);
                
                if (userId) {
                  // Get CampID from campaignData
                  const campaignData = await new Promise((resolve) => {
                    CHROME_API.storage.local.get(["CampaignData"], (result) => {
                      if (CHROME_API.lastError) {
                        console.warn("CampaignData storage error:", CHROME_API.lastError.message);
                        resolve({});
                      } else {
                        resolve(result);
                      }
                    });
                  });
                  
                  console.log("üìä [ACCUMULATION] CampaignData retrieved (abort):", campaignData);
                  console.log("üìä [ACCUMULATION] CampaignData.CampaignData (abort):", campaignData.CampaignData);
                  
                  const campId = campaignData.CampaignData?.campaignData?.idBox || null;
                  
                  if (!campId) {
                    console.warn("‚ö†Ô∏è [ACCUMULATION] No CampID found in CampaignData for abort");
                    console.warn("‚ö†Ô∏è [ACCUMULATION] Available keys in CampaignData:", campaignData.CampaignData ? Object.keys(campaignData.CampaignData) : "CampaignData is null/undefined");
                    console.warn("‚ö†Ô∏è [ACCUMULATION] idBox value:", campaignData.CampaignData?.campaignData?.idBox);
                  } else {
                    console.log("‚úÖ [ACCUMULATION] CampID found (abort):", campId);
                  }
                  
                  const accumulationResponse = await new Promise((resolve) => {
                    CHROME_API.runtime.sendMessage({ 
                      type: "SAVE_AUTOMATION_ACCUMULATION", 
                      userId: userId, 
                      campId: campId,
                      domainName: domainName, 
                      status: "ABORTED" 
                    }, (response) => {
                      if (CHROME_API.lastError) {
                        console.warn("Accumulation save error:", CHROME_API.lastError.message);
                        resolve(null);
                      } else {
                        resolve(response);
                      }
                    });
                  });
                  
                  if (accumulationResponse && accumulationResponse.success) {
                    console.log(`‚úÖ [ACCUMULATION] Automation accumulation saved with ABORTED status: ${accumulationResponse.accumulationId}`);
                    
                    // Also save citation accumulation for abort
                    try {
                      // Use a fallback CampID if none is found
                      const fallbackCampId = campId || `unknown_${Date.now()}`;
                      console.log(`üìä [CITATION_ACCUMULATION] Using CampID for abort: ${fallbackCampId} ${campId ? '(from CampaignData)' : '(fallback)'}`);
                      
                      const citationAccumulationResponse = await new Promise((resolve) => {
                        CHROME_API.runtime.sendMessage({ 
                          type: "SAVE_CITATION_ACCUMULATION", 
                          userId: userId,
                          campaignID: fallbackCampId,
                          domainName: domainName,
                          status: "Aborted",
                          index: window.__AUTOMATION_STATE__.currentStepIndex || 0 // Current step index when aborted
                        }, (response) => {
                          if (CHROME_API.lastError) {
                            console.warn("Citation accumulation save error:", CHROME_API.lastError.message);
                            resolve(null);
                          } else {
                            resolve(response);
                          }
                        });
                      });
                      
                      if (citationAccumulationResponse && citationAccumulationResponse.success) {
                        console.log(`‚úÖ [CITATION_ACCUMULATION] Citation accumulation saved for abort on domain: ${domainName}`);
                      } else {
                        console.warn(`‚ö†Ô∏è [CITATION_ACCUMULATION] Failed to save citation accumulation for abort`);
                      }
                    } catch (error) {
                      console.error(`‚ùå [CITATION_ACCUMULATION] Error saving citation accumulation for abort:`, error);
                    }
                  } else {
                    console.warn("‚ö†Ô∏è [ACCUMULATION] Failed to save automation accumulation:", accumulationResponse?.error);
                  }
                } else {
                  console.warn("‚ö†Ô∏è [ACCUMULATION] No user ID found for accumulation save on abort");
                }
              } catch (error) {
                console.error("‚ùå [ACCUMULATION] Error saving automation accumulation on abort:", error);
              }
            })();
            
            sendResponse && sendResponse({ success: true, status: 'aborted' });
            break;
        case "getAutomationStatus":
          sendResponse({
            success: true,
            status: automationStatus,
            isRunning: automationRunning,
            isPaused: state.paused,
            isAborted: state.aborted
          });
          break;
        case "manualSetResumeIndex":
          const resumeIndex = request.resumeIndex || 0;
          const key = getTabSpecificResumeIndexKey();
          const shouldAutoStart = request.autoStart !== false; // Default to true for backward compatibility
          const steps = window.automationSteps || [];
          const actualResumeIndex = getActualIndexFromVisibleNumber(resumeIndex + 1, steps);
          const visibleStepNumber = getVisibleStepNumberFromIndex(actualResumeIndex, steps);
          console.log(`üîÑ Setting resume index to: ${actualResumeIndex} (visible step ${visibleStepNumber}) for domain ${extractBaseDomain(window.location.hostname)} (autoStart: ${shouldAutoStart})`);
          setResumeIndex(actualResumeIndex);
          console.log(`‚úÖ Resume index updated to: ${actualResumeIndex}`);
          
          // Report status update to popup
          const currentStep = steps[actualResumeIndex];
          const stepLabel = (currentStep && currentStep.label) ? currentStep.label : '';
          const stepDescription = (currentStep && currentStep.description) ? currentStep.description : '';
          const stepAction = (currentStep && currentStep.action) ? currentStep.action : '';
          const visibleTotalSteps = getVisibleTotalSteps(steps);
          
          reportAutomationStatus({
            currentStep: visibleStepNumber, // Send 1-based visible step number
            totalSteps: visibleTotalSteps,
            currentLabel: stepLabel,
            currentDescription: stepDescription,
            currentAction: stepAction,
            status: 'step_updated'
          });
          
          // Only auto-start if explicitly requested (for backward compatibility)
          if (shouldAutoStart) {
              if (automationRunning) {
                console.log("‚ö†Ô∏è Automation running, aborting first...");
                window.__AUTOMATION_STATE__.aborted = true;
                const waitAndStart = () => {
                  if (!automationRunning) {
                    console.log("‚úÖ Automation stopped, starting from new index");
                    runAutomation(false);
                  } else {
                    setTimeout(waitAndStart, 100);
                  }
                };
                waitAndStart();
              } else {
                console.log("‚úÖ Starting automation from new index");
                runAutomation(false);
              }
            } else {
              console.log("‚ÑπÔ∏è Resume index updated without auto-starting automation");
            }
          sendResponse && sendResponse({ success: true, resumeIndex: actualResumeIndex });
          break;
        case "triggerAutomation":
          console.log("üéØ Automation triggered from Firebase console");
          const data = request.data || {};
          if (data.forceStart) {
            if (automationRunning) {
              state.aborted = true;
              setTimeout(() => runAutomation(true), 200);
            } else {
              runAutomation(true);
            }
          } else {
            if (!automationRunning) {
              runAutomation(true);
            }
          }
          sendResponse({ success: true, message: 'Automation trigger received' });
          break;
        case "startFresh":
          console.log("‚ôªÔ∏è Fresh start requested");
          resetAutomationState();
          clearResumeIndex();
          console.log("‚ôªÔ∏è Reset resume index to 0 for fresh start");
          runAutomation(true);
          sendResponse && sendResponse({ success: true, message: 'Fresh start initiated' });
          break;
        case "toggleSelectorGrabber":
          (function() {
            if (window.__CBPHAA_SELECTOR_GRABBER_ACTIVE__) {
              window.__CBPHAA_SELECTOR_GRABBER_ACTIVE__ = false;
              if (window.__CBPHAA_GRABBER_CLEANUP__) window.__CBPHAA_GRABBER_CLEANUP__();
              sendResponse && sendResponse({ success: true, active: false });
              return true;
            }
            window.__CBPHAA_SELECTOR_GRABBER_ACTIVE__ = true;
            var overlay = document.createElement("div");
            overlay.id = "cbph-selector-grabber-overlay";
            overlay.style.cssText = "position:fixed;inset:0;z-index:2147483646;pointer-events:auto;cursor:crosshair;background:rgba(0,0,0,0.05);";
            var highlight = document.createElement("div");
            highlight.id = "cbph-selector-grabber-highlight";
            highlight.style.cssText = "position:fixed;pointer-events:none;z-index:2147483645;border:2px solid #56ab2f;background:rgba(86,171,47,0.15);box-sizing:border-box;border-radius:2px;transition:top 0.05s,left 0.05s,width 0.05s,height 0.05s;";
            var tooltip = document.createElement("div");
            tooltip.id = "cbph-selector-grabber-tooltip";
            tooltip.style.cssText = "position:fixed;pointer-events:none;z-index:2147483647;background:#333;color:#fff;font:11px/1.2 sans-serif;padding:4px 8px;border-radius:4px;white-space:nowrap;max-width:320px;overflow:hidden;text-overflow:ellipsis;";
            document.body.appendChild(overlay);
            document.body.appendChild(highlight);
            document.body.appendChild(tooltip);
            highlight.style.display = "none";
            tooltip.style.display = "none";
            function getElementAtPoint(x, y) {
              overlay.style.pointerEvents = "none";
              var el = document.elementFromPoint(x, y);
              overlay.style.pointerEvents = "auto";
              return el && el !== overlay && el !== highlight && el !== tooltip ? el : null;
            }
            function escapeCssId(id) {
              if (!id) return "";
              return id.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
            }
            function escapeCssAttr(val) {
              if (val == null) return "";
              return String(val).replace(/\\/g, "\\\\").replace(/"/g, '\\"');
            }
            function getSimpleSelector(el) {
              if (!el || el.nodeType !== 1) return "";
              var tag = el.tagName.toLowerCase();
              if (el.id && /^[a-zA-Z][\w-]*$/.test(el.id)) return tag + "#" + escapeCssId(el.id);
              var parts = [tag];
              if (el.className && typeof el.className === "string") {
                var classes = el.className.trim().split(/\s+/).filter(Boolean);
                classes.slice(0, 3).forEach(function(c) { if (/^[\w-]+$/.test(c)) parts.push("." + c); });
              }
              return parts.join("");
            }
            function getSelectorPath(el) {
              if (!el || el.nodeType !== 1) return "";
              var tag = el.tagName.toLowerCase();
              var nth = 1;
              var sib = el.previousElementSibling;
              while (sib) { if (sib.tagName === el.tagName) nth++; sib = sib.previousElementSibling; }
              var sel = tag + ":nth-of-type(" + nth + ")";
              return sel;
            }
            function countMatches(selector) {
              try {
                return document.querySelectorAll(selector).length;
              } catch (e) { return 0; }
            }
            function getUniqueSelector(target) {
              if (!target || target.nodeType !== 1) return { selector: "", duplicate: false };
              var simple = getSimpleSelector(target);
              var n = countMatches(simple);
              if (n <= 1) return { selector: simple, duplicate: false };
              var path = [];
              var current = target;
              while (current && current !== document.body) {
                path.unshift(getSelectorPath(current));
                var combined = path.join(" > ");
                if (countMatches(combined) === 1) return { selector: combined, duplicate: true };
                current = current.parentElement;
              }
              return { selector: simple, duplicate: true };
            }
            function getAllAttributes(el) {
              if (!el || el.nodeType !== 1) return {};
              var o = {};
              for (var i = 0; i < el.attributes.length; i++) {
                var a = el.attributes[i];
                o[a.name] = a.value;
              }
              return o;
            }
            function escapeHtml(s) {
              var d = document.createElement("div");
              d.textContent = s;
              return d.innerHTML;
            }
            function showResultPanel(data) {
              var existingBackdrop = document.getElementById("cbph-selector-grabber-modal-backdrop");
              var existingPanel = document.getElementById("cbph-selector-grabber-result");
              if (existingBackdrop) existingBackdrop.remove();
              if (existingPanel) existingPanel.remove();
              var backdrop = document.createElement("div");
              backdrop.id = "cbph-selector-grabber-modal-backdrop";
              backdrop.style.cssText = "position:fixed;inset:0;z-index:2147483646;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;padding:16px;box-sizing:border-box;";
              var panel = document.createElement("div");
              panel.id = "cbph-selector-grabber-result";
              panel.style.cssText = "position:relative;z-index:2147483647;width:100%;max-width:480px;max-height:85vh;overflow:hidden;background:#fff;color:#333;font:12px/1.4 sans-serif;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.3);display:flex;flex-direction:column;";
              var dupNote = data.duplicate ? "<div style='color:#e65100;font-size:11px;margin-bottom:8px;'>Duplicate elements found ‚Äì selector uses parent path for uniqueness.</div>" : "";
              var attrRows = Object.keys(data.attributes).map(function(k) {
                var v = String(data.attributes[k]);
                var short = v.length > 60 ? v.substring(0, 60) + "‚Ä¶" : v;
                return "<div style='display:flex;align-items:center;justify-content:space-between;padding:6px 8px;background:#f5f5f5;border-radius:4px;margin-bottom:4px;'>" +
                  "<span style='font-weight:600;color:#1565c0;font-size:11px;'>" + escapeHtml(k) + "</span>" +
                  "<span style='font-family:monospace;font-size:11px;word-break:break-all;max-width:70%;'>" + escapeHtml(short) + "</span>" +
                  "<button type='button' class='cbph-attr-copy' data-value='" + escapeHtml(v).replace(/'/g, "&#39;") + "' style='background:none;border:none;cursor:pointer;padding:2px;margin-left:4px;' title='Copy value'>‚éò</button>" +
                  "</div>";
              }).join("");
              panel.innerHTML =
                "<div style='display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e0e0e0;background:#fafafa;border-radius:12px 12px 0 0;'>" +
                "<span style='font-weight:700;font-size:14px;color:#333;'>Selector</span>" +
                "<button type='button' id='cbph-grabber-close' style='background:none;border:none;cursor:pointer;padding:4px;font-size:18px;line-height:1;color:#666;' title='Close'>√ó</button>" +
                "</div>" +
                "<div style='padding:16px;overflow:auto;flex:1;'>" +
                "<div style='font-weight:600;font-size:11px;color:#666;margin-bottom:6px;'>CSS Selector</div>" +
                "<div style='display:flex;align-items:center;gap:8px;margin-bottom:12px;'>" +
                "<div style='flex:1;word-break:break-all;background:#f5f5f5;padding:8px 10px;border-radius:6px;font-family:monospace;font-size:12px;'>" + escapeHtml(data.selector) + "</div>" +
                "<button type='button' id='cbph-grabber-copy' style='padding:8px 12px;background:#56ab2f;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:12px;white-space:nowrap;' title='Copy selector'>Copy</button>" +
                "</div>" +
                dupNote +
                "<div style='font-weight:600;font-size:11px;color:#666;margin-bottom:6px;'>Tag</div>" +
                "<div style='margin-bottom:12px;font-family:monospace;font-size:12px;'>" + escapeHtml(data.tagName) + "</div>" +
                "<div style='font-weight:600;font-size:11px;color:#666;margin-bottom:6px;'>Attributes</div>" +
                "<div style='max-height:200px;overflow:auto;'>" + (attrRows || "<div style='color:#999;font-size:11px;'>No attributes</div>") + "</div>" +
                "</div>";
              backdrop.appendChild(panel);
              document.body.appendChild(backdrop);
              document.getElementById("cbph-grabber-copy").onclick = function() {
                try {
                  navigator.clipboard.writeText(data.selector);
                  this.textContent = "Copied!";
                  var t = this;
                  setTimeout(function() { t.textContent = "Copy"; }, 1500);
                } catch (e) {}
              };
              document.getElementById("cbph-grabber-close").onclick = closeModal;
              backdrop.onclick = function(e) {
                if (e.target === backdrop) closeModal();
              };
              panel.onclick = function(e) { e.stopPropagation(); };
              var attrCopyBtns = panel.querySelectorAll(".cbph-attr-copy");
              for (var i = 0; i < attrCopyBtns.length; i++) {
                (function(btn) {
                  var val = btn.getAttribute("data-value");
                  if (val) btn.onclick = function() {
                    try {
                      navigator.clipboard.writeText(val);
                      btn.textContent = "‚úì";
                      setTimeout(function() { btn.textContent = "‚éò"; }, 800);
                    } catch (e) {}
                  };
                })(attrCopyBtns[i]);
              }
              function closeModal() {
                backdrop.remove();
              }
            }
            function onMove(e) {
              var el = getElementAtPoint(e.clientX, e.clientY);
              if (!el) { highlight.style.display = "none"; tooltip.style.display = "none"; return; }
              var r = el.getBoundingClientRect();
              highlight.style.display = "block";
              highlight.style.left = r.left + "px";
              highlight.style.top = r.top + "px";
              highlight.style.width = r.width + "px";
              highlight.style.height = r.height + "px";
              var tag = el.tagName.toLowerCase();
              var id = el.id ? "#" + el.id : "";
              var cls = el.className && typeof el.className === "string" ? "." + el.className.trim().split(/\s+/)[0] : "";
              tooltip.textContent = tag + id + (cls ? cls : "");
              tooltip.style.display = "block";
              tooltip.style.left = (r.left + r.width / 2 - tooltip.offsetWidth / 2) + "px";
              tooltip.style.top = (r.top - tooltip.offsetHeight - 6) + "px";
              if (tooltip.offsetTop < 4) tooltip.style.top = (r.bottom + 6) + "px";
            }
            function onClick(e) {
              e.preventDefault();
              e.stopPropagation();
              var el = getElementAtPoint(e.clientX, e.clientY);
              if (!el) return;
              var result = getUniqueSelector(el);
              var attrs = getAllAttributes(el);
              showResultPanel({
                selector: result.selector,
                duplicate: result.duplicate,
                tagName: el.tagName.toLowerCase(),
                attributes: attrs
              });
            }
            function onKey(e) {
              if (e.key === "Escape") {
                window.__CBPHAA_SELECTOR_GRABBER_ACTIVE__ = false;
                if (window.__CBPHAA_GRABBER_CLEANUP__) window.__CBPHAA_GRABBER_CLEANUP__();
              }
            }
            overlay.addEventListener("mousemove", onMove);
            overlay.addEventListener("click", onClick, true);
            document.addEventListener("keydown", onKey);
            window.__CBPHAA_GRABBER_CLEANUP__ = function() {
              overlay.remove();
              highlight.remove();
              tooltip.remove();
              document.removeEventListener("keydown", onKey);
              var p = document.getElementById("cbph-selector-grabber-result");
              if (p) p.remove();
              var b = document.getElementById("cbph-selector-grabber-modal-backdrop");
              if (b) b.remove();
              window.__CBPHAA_GRABBER_CLEANUP__ = null;
            };
            sendResponse && sendResponse({ success: true, active: true });
            return true;
          })();
          break;
        default:
          console.warn(`‚ö†Ô∏è Unknown command received: ${request.command}`);
          sendResponse && sendResponse({ success: false, error: 'Unknown command' });
          break;
      }
    });
  }

  setupControls();

  // --- Micro Hotkeys (from Settings) ---
  var DEFAULT_HOTKEYS = {
    selectorGrabber: "Ctrl+Shift+G",
    disabledButton: "Ctrl+Shift+P",
    sync: "Ctrl+Shift+S",
    notification: "Ctrl+Shift+N",
    campaignViewer: "Ctrl+Shift+V"
  };
  var microHotkeysCache = Object.assign({}, DEFAULT_HOTKEYS);
  var MODIFIER_ORDER = ["Alt", "Ctrl", "Meta", "Shift"];
  function normalizeHotkeyString(s) {
    if (!s || typeof s !== "string") return "";
    s = s.trim().replace(/\s*\+\s*/g, "+").replace(/Control/gi, "Ctrl").replace(/Cmd/gi, "Meta");
    var parts = s.split("+");
    var modifiers = [];
    var keyPart = null;
    for (var i = 0; i < parts.length; i++) {
      var p = parts[i];
      if (MODIFIER_ORDER.indexOf(p) !== -1 && modifiers.indexOf(p) === -1) modifiers.push(p);
      else if (p && keyPart === null) keyPart = p.length === 1 ? p.toUpperCase() : p;
    }
    modifiers.sort(function(a, b) { return MODIFIER_ORDER.indexOf(a) - MODIFIER_ORDER.indexOf(b); });
    if (keyPart) modifiers.push(keyPart);
    return modifiers.join("+");
  }
  function keyEventToHotkeyString(e) {
    var parts = [];
    if (e.ctrlKey) parts.push("Ctrl");
    if (e.altKey) parts.push("Alt");
    if (e.shiftKey) parts.push("Shift");
    if (e.metaKey) parts.push("Meta");
    var key = e.key;
    if (key && key.length === 1) key = key.toUpperCase();
    if (key) parts.push(key);
    return parts.join("+");
  }
  function updateMicroHotkeysCache(cb) {
    if (!CHROME_API.storage || !CHROME_API.storage.local) {
      if (typeof cb === "function") cb();
      return;
    }
    CHROME_API.storage.local.get(["microHotkeys"], function(result) {
      if (result && result.microHotkeys && typeof result.microHotkeys === "object") {
        microHotkeysCache = Object.assign({}, DEFAULT_HOTKEYS, result.microHotkeys);
      } else {
        microHotkeysCache = Object.assign({}, DEFAULT_HOTKEYS);
      }
      if (typeof cb === "function") cb();
    });
  }
  updateMicroHotkeysCache();
  if (CHROME_API.storage && CHROME_API.storage.onChanged) {
    CHROME_API.storage.onChanged.addListener(function(changes, areaName) {
      if (areaName === "local" && changes.microHotkeys) {
        if (changes.microHotkeys.newValue) microHotkeysCache = Object.assign({}, DEFAULT_HOTKEYS, changes.microHotkeys.newValue);
      }
    });
  }
  function runMicroHotkeyHandler(e) {
    var target = document.activeElement;
    if (target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "SELECT" || target.isContentEditable)) return;
    var pressed = normalizeHotkeyString(keyEventToHotkeyString(e));
    if (!pressed) return;
    var actions = ["selectorGrabber", "disabledButton", "sync", "notification", "campaignViewer"];
    for (var i = 0; i < actions.length; i++) {
      var action = actions[i];
      var bound = microHotkeysCache[action];
      if (bound && normalizeHotkeyString(String(bound)) === pressed) {
        e.preventDefault();
        e.stopPropagation();
        try {
          if (typeof chrome !== "undefined" && chrome.runtime && chrome.runtime.sendMessage) {
            chrome.runtime.sendMessage({ type: "HOTKEY_ACTION", action: action });
          } else if (CHROME_API.runtime && CHROME_API.runtime.sendMessage) {
            CHROME_API.runtime.sendMessage({ type: "HOTKEY_ACTION", action: action });
          }
        } catch (err) {
          console.warn("CB-PHAA micro hotkey send failed:", err);
        }
        return;
      }
    }
  }
  window.addEventListener("keydown", runMicroHotkeyHandler, true);

  // --- Popup Communication Setup ---
  function setupPopupCommunication() {
    // Listen for commands from popup via postMessage
    window.addEventListener('message', (event) => {
      if (event.source !== window) return;
      
      if (event.data && event.data.type === 'AUTOMATION_COMMAND') {
        const command = event.data.command;
        console.log(`üéÆ [POPUP] Received command: ${command}`);
        
        const state = AUTOMATION_STATE.get();
        switch (command) {
          case "pause":
            if (automationRunning) {
              state.paused = true;
              // Also set the global paused flag
              paused = true;
              updateAutomationStatus(AutomationStatus.PAUSED);
              console.log("‚è∏Ô∏è [POPUP] Automation paused - execution will stop at next check");
            } else {
              console.warn("‚ö†Ô∏è [POPUP] Cannot pause: automation not running");
            }
            break;
            
          case "resume":
            console.log("‚ñ∂Ô∏è [POPUP] Play button pressed");
            
            // Ensure we read the latest resume index before starting
            const resumeKeyForPlay = getTabSpecificResumeIndexKey();
            CHROME_API.storage.local.get([resumeKeyForPlay], (result) => {
              const currentResumeIndex = result[resumeKeyForPlay] || 0;
              console.log(`üîç [POPUP] Current resume index before play: ${currentResumeIndex}`);
              
              // Check if automation is paused or aborted
              if (state.paused || state.aborted) {
                console.log("‚ñ∂Ô∏è [POPUP] Resuming from paused/aborted state");
                
                // Reset states
                state.paused = false;
                state.aborted = false;
                paused = false; // Also reset global paused flag
                
                // Resume signal if waiting
                if (resumeSignal) {
                  resumeSignal();
                  resumeSignal = null;
                }
                
                // Start automation ONLY if not already running
                if (!automationRunning && !automationStarting) {
                  console.log(`üöÄ [POPUP] Starting automation from resumeIndex: ${currentResumeIndex}`);
                  runAutomation(false);
                } else if (automationRunning) {
                  // Automation is running but was paused - just resume it
                  updateAutomationStatus(AutomationStatus.RUNNING);
                  console.log("‚ñ∂Ô∏è [POPUP] Automation resumed (was already running)");
                } else {
                  console.log("‚ö†Ô∏è [POPUP] Automation already starting");
                }
              } else if (automationRunning && state.paused) {
                // Handle normal pause/resume
                state.paused = false;
                paused = false; // Also reset global paused flag
                if (resumeSignal) {
                  resumeSignal();
                  resumeSignal = null;
                }
                updateAutomationStatus(AutomationStatus.RUNNING);
                console.log("‚ñ∂Ô∏è [POPUP] Automation resumed");
              } else if (!automationRunning && canStartAutomation()) {
                // Automation is idle/aborted - start it from current resumeIndex
                console.log(`üöÄ [POPUP] Starting automation from resumeIndex: ${currentResumeIndex} (was idle/aborted)`);
                runAutomation(false);
              } else {
                console.log("‚ÑπÔ∏è [POPUP] Cannot start automation - may be already starting or cannot start");
              }
            });
            break;
            
          case "abort":
            console.log("üõë [POPUP] Abort command received");
            state.aborted = true;
            paused = false;
            if (resumeSignal) {
              resumeSignal();
              resumeSignal = null;
            }
            automationRunning = false;
            automationStarting = false;
            
            // Reset resume index (domain + current run) and clear completion flag on abort
            clearResumeIndex();
            console.log(`üõë [POPUP] Resume index reset to 0 for domain ${extractBaseDomain(window.location.hostname)}`);
            const popupCompletionKey = getTabSpecificCompletionKey();
            CHROME_API.storage.local.remove([popupCompletionKey], () => {
              console.log(`üõë [POPUP] Completion flag cleared for domain ${extractBaseDomain(window.location.hostname)}`);
            });
            
            updateAutomationStatus(AutomationStatus.ABORTED, {
              error: 'User aborted via popup'
            });
            console.log(`üõë [POPUP] Automation aborted - resumeIndex reset to 0`);
            
            // Save automation accumulation with ABORTED status (popup abort)
            (async () => {
              try {
                const userData = await new Promise((resolve) => {
                  CHROME_API.storage.local.get(["userId"], (result) => {
                    if (CHROME_API.lastError) {
                      console.warn("Storage error:", CHROME_API.lastError.message);
                      resolve({});
                    } else {
                      resolve(result);
                    }
                  });
                });
                
                const userId = userData.userId;
                const domainName = extractBaseDomain(window.location.hostname);
                
                if (userId) {
                  // Get CampID from campaignData
                  const campaignData = await new Promise((resolve) => {
                    CHROME_API.storage.local.get(["CampaignData"], (result) => {
                      if (CHROME_API.lastError) {
                        console.warn("CampaignData storage error:", CHROME_API.lastError.message);
                        resolve({});
                      } else {
                        resolve(result);
                      }
                    });
                  });
                  
                  console.log("üìä [ACCUMULATION] CampaignData retrieved (popup abort):", campaignData);
                  console.log("üìä [ACCUMULATION] CampaignData.CampaignData (popup abort):", campaignData.CampaignData);
                  
                  const campId = campaignData.CampaignData?.campaignData?.idBox || null;
                  
                  if (!campId) {
                    console.warn("‚ö†Ô∏è [ACCUMULATION] No CampID found in CampaignData for popup abort");
                    console.warn("‚ö†Ô∏è [ACCUMULATION] Available keys in CampaignData:", campaignData.CampaignData ? Object.keys(campaignData.CampaignData) : "CampaignData is null/undefined");
                    console.warn("‚ö†Ô∏è [ACCUMULATION] idBox value:", campaignData.CampaignData?.campaignData?.idBox);
                  } else {
                    console.log("‚úÖ [ACCUMULATION] CampID found (popup abort):", campId);
                  }
                  
                  // Save only citation_accumulation on popup abort (skip automation_accumulation)
                  try {
                    // Prefer campaignData.campaignData.idBox if present; fall back to CampaignData.campaignData.idBox; else generate unknown
                    const inferredCampId = campaignData?.campaignData?.idBox || campaignData?.CampaignData?.campaignData?.idBox || null;
                    const fallbackCampId = inferredCampId || `unknown_${Date.now()}`;
                    console.log(`üìä [CITATION_ACCUMULATION] Using CampID for popup abort: ${fallbackCampId} ${inferredCampId ? '(from CampaignData)' : '(fallback)'}`);

                    const citationAccumulationResponse = await new Promise((resolve) => {
                      CHROME_API.runtime.sendMessage({ 
                        type: "SAVE_CITATION_ACCUMULATION", 
                        userId: userId,
                        campaignID: fallbackCampId,
                        domainName: domainName,
                        status: "Aborted",
                        index: window.__AUTOMATION_STATE__.currentStepIndex || 0
                      }, (response) => {
                        if (CHROME_API.lastError) {
                          console.warn("Citation accumulation save error:", CHROME_API.lastError.message);
                          resolve(null);
                        } else {
                          resolve(response);
                        }
                      });
                    });

                    if (citationAccumulationResponse && citationAccumulationResponse.success) {
                      console.log(`‚úÖ [CITATION_ACCUMULATION] Citation accumulation saved for popup abort on domain: ${domainName}`);
                    } else {
                      console.warn(`‚ö†Ô∏è [CITATION_ACCUMULATION] Failed to save citation accumulation for popup abort`);
                    }
                  } catch (error) {
                    console.error(`‚ùå [CITATION_ACCUMULATION] Error saving citation accumulation for popup abort:`, error);
                  }
                } else {
                  console.warn("‚ö†Ô∏è [ACCUMULATION] No user ID found for accumulation save on popup abort");
                }
              } catch (error) {
                console.error("‚ùå [ACCUMULATION] Error saving automation accumulation on popup abort:", error);
              }
            })();
            
            break;
            
          case "startFresh":
            console.log("‚ôªÔ∏è [POPUP] Fresh start requested");
            
            if (!isExtensionContextValid()) {
              showExtensionContextError();
              break;
            }
            
            resetAutomationState();
            clearResumeIndex();
            console.log("‚ôªÔ∏è [POPUP] Reset resume index to 0 for fresh start");
            runAutomation(true);
            break;
            
          case "forward":
            console.log("‚è≠Ô∏è [POPUP] Forward command received");
            
            if (!isExtensionContextValid()) {
              showExtensionContextError();
              break;
            }
            
            // Forward/backward buttons always work - just update index, never auto-resume
            // If automation is RUNNING, it will adopt the new index in the next iteration
            // If automation is PAUSED or ABORTED, it stays paused/aborted until play is pressed
            const forwardState = AUTOMATION_STATE.get();
            const forwardCurrentState = forwardState?.aborted ? 'ABORTED' : (forwardState?.paused ? 'PAUSED' : (automationRunning ? 'RUNNING' : 'IDLE'));
            
            const forwardKey = getTabSpecificResumeIndexKey();
            
            safeChromeCall(() => {
              chrome.storage.local.get([forwardKey], (result) => {
                if (chrome.runtime.lastError) {
                  console.warn("Extension context invalidated (forward get):", chrome.runtime.lastError.message);
                  showExtensionContextError();
                  return;
                }
                
                const currentIndex = result[forwardKey] || 0;
                const steps = window.automationSteps || [];
                let newForwardIndex = getNextVisibleIndex(currentIndex, steps);
                if (newForwardIndex === currentIndex && currentIndex < steps.length - 1) {
                  newForwardIndex = getNextVisibleIndex(currentIndex + 1, steps);
                }
                if (newForwardIndex >= steps.length) newForwardIndex = Math.max(0, steps.length - 1);
                console.log(`‚è≠Ô∏è [POPUP] Moving from step ${currentIndex} to step ${newForwardIndex} (state: ${forwardCurrentState})`);
                
                safeChromeCall(() => {
                  CHROME_API.storage.local.set({ [forwardKey]: newForwardIndex }, () => {
                    if (CHROME_API.lastError) {
                      console.warn("Extension context invalidated (forward set):", CHROME_API.lastError.message);
                      showExtensionContextError();
                      return;
                    }
                    
                    // Get step label, description, and action for the new index
                    const currentStep = steps[newForwardIndex];
                    const stepLabel = (currentStep && currentStep.label) ? currentStep.label : '';
                    const stepDescription = (currentStep && currentStep.description) ? currentStep.description : '';
                    const stepAction = (currentStep && currentStep.action) ? currentStep.action : '';
                    const visibleStepNumber = getVisibleStepNumberFromIndex(newForwardIndex, steps);
                    const visibleTotalSteps = getVisibleTotalSteps(steps);
                    
                    console.log(`‚úÖ [POPUP] Forward: Updated resume index to ${newForwardIndex}${stepLabel ? ` - Label: "${stepLabel}"` : ''}`);
                    console.log(`   ‚Ä¢ Current state: ${forwardCurrentState}`);
                    if (forwardCurrentState === 'RUNNING') {
                      console.log(`   ‚Ä¢ Automation is running - will adopt new index in next iteration`);
                    } else {
                      console.log(`   ‚Ä¢ Automation is ${forwardCurrentState} - will resume from this index when play is pressed`);
                    }
                    
                    reportAutomationStatus({
                      currentStep: visibleStepNumber,
                      totalSteps: visibleTotalSteps,
                      currentLabel: stepLabel,
                      currentDescription: stepDescription,
                      currentAction: stepAction,
                      status: 'step_updated'
                    });
                  });
                });
              });
            });
            break;
            
          case "backward":
            console.log("‚èÆÔ∏è [POPUP] Backward command received");
            
            if (!isExtensionContextValid()) {
              showExtensionContextError();
              break;
            }
            
            // Forward/backward buttons always work - just update index, never auto-resume
            // If automation is RUNNING, it will adopt the new index in the next iteration
            // If automation is PAUSED or ABORTED, it stays paused/aborted until play is pressed
            const backwardState = AUTOMATION_STATE.get();
            const backwardCurrentState = backwardState?.aborted ? 'ABORTED' : (backwardState?.paused ? 'PAUSED' : (automationRunning ? 'RUNNING' : 'IDLE'));
            
            const backwardKey = getTabSpecificResumeIndexKey();
            
            safeChromeCall(() => {
              chrome.storage.local.get([backwardKey], (result) => {
                if (chrome.runtime.lastError) {
                  console.warn("Extension context invalidated (backward get):", chrome.runtime.lastError.message);
                  showExtensionContextError();
                  return;
                }
                
                const currentBackwardIndex = result[backwardKey] || 0;
                const backwardSteps = window.automationSteps || [];
                let newBackwardIndex = getPreviousVisibleIndex(currentBackwardIndex, backwardSteps);
                if (newBackwardIndex === currentBackwardIndex && currentBackwardIndex > 0) {
                  newBackwardIndex = getPreviousVisibleIndex(currentBackwardIndex - 1, backwardSteps);
                }
                if (newBackwardIndex < 0) newBackwardIndex = 0;
                console.log(`‚èÆÔ∏è [POPUP] Moving from step ${currentBackwardIndex} to step ${newBackwardIndex} (state: ${backwardCurrentState})`);
                
                safeChromeCall(() => {
                  chrome.storage.local.set({ [backwardKey]: newBackwardIndex }, () => {
                    if (chrome.runtime.lastError) {
                      console.warn("Extension context invalidated (backward set):", chrome.runtime.lastError.message);
                      showExtensionContextError();
                      return;
                    }
                    
                    // Get step label, description, and action for the new index
                    const currentStep = backwardSteps[newBackwardIndex];
                    const backwardStepLabel = (currentStep && currentStep.label) ? currentStep.label : '';
                    const backwardStepDescription = (currentStep && currentStep.description) ? currentStep.description : '';
                    const backwardStepAction = (currentStep && currentStep.action) ? currentStep.action : '';
                    const visibleStepNumber = getVisibleStepNumberFromIndex(newBackwardIndex, backwardSteps);
                    const visibleTotalSteps = getVisibleTotalSteps(backwardSteps);
                    
                    console.log(`‚úÖ [POPUP] Backward: Updated resume index to ${newBackwardIndex}${backwardStepLabel ? ` - Label: "${backwardStepLabel}"` : ''}`);
                    console.log(`   ‚Ä¢ Current state: ${backwardCurrentState}`);
                    if (backwardCurrentState === 'RUNNING') {
                      console.log(`   ‚Ä¢ Automation is running - will adopt new index in next iteration`);
                    } else {
                      console.log(`   ‚Ä¢ Automation is ${backwardCurrentState} - will resume from this index when play is pressed`);
                    }
                    
                    reportAutomationStatus({
                      currentStep: visibleStepNumber,
                      totalSteps: visibleTotalSteps,
                      currentLabel: backwardStepLabel,
                      currentDescription: backwardStepDescription,
                      currentAction: backwardStepAction,
                      status: 'step_updated'
                    });
                  });
                });
              });
            });
            break;
            
          case "checkEligibility":
            console.log(`üîç [POPUP] Manual eligibility check requested`);
            performManualEligibilityCheck().then(result => {
              sendResponse && sendResponse({ 
                success: true, 
                eligibility: result 
              });
            }).catch(error => {
              console.error("‚ùå [POPUP] Error during eligibility check:", error);
              sendResponse && sendResponse({ 
                success: false, 
                error: error.message 
              });
            });
            return true; // Keep message channel open for async response
            break;
            
          case "checkCheckpoint":
            console.log(`üéØ [POPUP] Manual checkpoint check requested`);
            checkCheckpointStatus().then(result => {
              sendResponse && sendResponse({ 
                success: true, 
                checkpoint: result 
              });
            }).catch(error => {
              console.error("‚ùå [POPUP] Error during checkpoint check:", error);
              sendResponse && sendResponse({ 
                success: false, 
                error: error.message 
              });
            });
            return true; // Keep message channel open for async response
            break;
            
          default:
            console.warn(`‚ö†Ô∏è [POPUP] Unknown command received: ${command}`);
            break;
        }
      }
    });
  }

  setupPopupCommunication();

  // --- Automation File Utilities ---
  const getFilenames = () => {
    const hostname = extractBaseDomain(window.location.hostname);
    const path = normalize(location.pathname);
    const filenames = [`${hostname}.json`, `${hostname}${path}`.replace(/\//g, "_") + ".json"];
    console.log(`üìç Current URL: ${window.location.href}`);
    console.log(`üìç Hostname: ${hostname}, Path: ${path}`);
    console.log(`üìç Looking for files: ${filenames.join(', ')}`);
    return filenames;
  };

  // Domain detection function to validate if current domain matches automation domainName
  const isDomainSupported = (currentDomain, automationDomainName) => {
    // Handle null/undefined values
    if (!currentDomain || !automationDomainName) {
      console.warn(`‚ö†Ô∏è Invalid domain data: currentDomain="${currentDomain}", automationDomainName="${automationDomainName}"`);
      return false;
    }
    
    // Normalize domains for comparison using smart domain extraction
    const normalizedCurrent = extractBaseDomain(currentDomain);
    const normalizedAutomation = extractBaseDomain(automationDomainName);
    
    // Exact match after extraction
    if (normalizedCurrent === normalizedAutomation) {
      console.log(`‚úÖ Domain match confirmed: ${normalizedCurrent} === ${normalizedAutomation}`);
      return true;
    }
    
    // Check if original currentDomain (before extraction) is a subdomain of the automation domain
    // This handles cases like "welcome.all.biz" matching automation for "all.biz"
    const originalCurrent = currentDomain.toLowerCase();
    const originalAutomation = automationDomainName.toLowerCase();
    if (originalCurrent.endsWith(`.${originalAutomation}`) || originalCurrent.endsWith(`.${normalizedAutomation}`)) {
      console.log(`‚úÖ Subdomain match confirmed: ${originalCurrent} is subdomain of ${normalizedAutomation}`);
      return true;
    }
    
    // Check for subdomain matches (e.g., app.example.com matches example.com)
    if (normalizedCurrent.endsWith(`.${normalizedAutomation}`)) {
      console.log(`‚úÖ Subdomain match confirmed: ${normalizedCurrent} is subdomain of ${normalizedAutomation}`);
      return true;
    }
    
    // Check for parent domain matches (e.g., example.com matches app.example.com)
    if (normalizedAutomation.endsWith(`.${normalizedCurrent}`)) {
      console.log(`‚úÖ Parent domain match confirmed: ${normalizedCurrent} is parent of ${normalizedAutomation}`);
      return true;
    }
    
    console.warn(`‚ùå Domain mismatch: ${normalizedCurrent} does not match ${normalizedAutomation}`);
    return false;
  };

  // Ensure popup-visible step helpers exist before loadSteps uses them
  var isStepIncludedInPopup = typeof isStepIncludedInPopup === 'function' ? isStepIncludedInPopup : function(step) {
    if (!step) return false;
    const action = typeof step.action === 'string' ? step.action.toLowerCase() : '';
    if (action === 'separator') return false;
    if (step.enabled === false) return false;
    if (typeof step.enabled === 'string' && step.enabled.toLowerCase() === 'false') return false;
    if (step.skip === true) return false;
    if (typeof step.skip === 'string' && step.skip.toLowerCase() === 'true') return false;
    return true;
  };
  var getVisibleStepIndices = typeof getVisibleStepIndices === 'function' ? getVisibleStepIndices : function(steps) {
    if (!Array.isArray(steps)) return [];
    const visible = [];
    for (let i = 0; i < steps.length; i++) {
      if (isStepIncludedInPopup(steps[i])) {
        visible.push(i);
      }
    }
    return visible;
  };
  var getVisibleTotalSteps = typeof getVisibleTotalSteps === 'function' ? getVisibleTotalSteps : function(steps) {
    return getVisibleStepIndices(steps).length;
  };
  var getVisibleStepNumberFromIndex = typeof getVisibleStepNumberFromIndex === 'function' ? getVisibleStepNumberFromIndex : function(index, steps) {
    const visibleIndices = getVisibleStepIndices(steps);
    if (visibleIndices.length === 0) return index + 1;
    const visiblePos = visibleIndices.indexOf(index);
    if (visiblePos >= 0) return visiblePos + 1;
    for (let i = 0; i < visibleIndices.length; i++) {
      if (visibleIndices[i] > index) return i + 1;
    }
    return visibleIndices.length;
  };
  var getActualIndexFromVisibleNumber = typeof getActualIndexFromVisibleNumber === 'function' ? getActualIndexFromVisibleNumber : function(visibleNumber, steps) {
    const visibleIndices = getVisibleStepIndices(steps);
    if (!visibleNumber || visibleNumber < 1) return 0;
    const candidate = visibleIndices[visibleNumber - 1];
    if (candidate !== undefined) return candidate;
    return Math.max(0, visibleNumber - 1);
  };
  var getNextVisibleIndex = typeof getNextVisibleIndex === 'function' ? getNextVisibleIndex : function(currentIndex, steps) {
    const visibleIndices = getVisibleStepIndices(steps);
    for (let i = 0; i < visibleIndices.length; i++) {
      if (visibleIndices[i] > currentIndex) return visibleIndices[i];
    }
    return currentIndex;
  };
  var getPreviousVisibleIndex = typeof getPreviousVisibleIndex === 'function' ? getPreviousVisibleIndex : function(currentIndex, steps) {
    const visibleIndices = getVisibleStepIndices(steps);
    for (let i = visibleIndices.length - 1; i >= 0; i--) {
      if (visibleIndices[i] < currentIndex) return visibleIndices[i];
    }
    return currentIndex;
  };

  const loadSteps = async () => {
    const originalHostname = window.location.hostname.toLowerCase();
    const hostname = extractBaseDomain(originalHostname);
    console.log(`üîç Loading automation steps for domain: ${hostname} (original: ${originalHostname})`);
    
    try {
      // First, try to get automation from background script using base domain
      let response = await new Promise((resolve, reject) => {
        chrome.runtime.sendMessage({ type: "GET_AUTOMATION", domainName: hostname }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(response);
          }
        });
      });

      // If not found with base domain and original hostname is different, try original hostname
      if ((!response || !response.success || !response.automation) && originalHostname !== hostname) {
        console.log(`üîÑ No automation found for base domain ${hostname}, trying original hostname: ${originalHostname}`);
        response = await new Promise((resolve, reject) => {
          chrome.runtime.sendMessage({ type: "GET_AUTOMATION", domainName: originalHostname }, (response) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve(response);
            }
          });
        });
      }

      if (response && response.success && response.automation) {
        console.log(`‚úÖ Automation loaded from IndexedDB for ${hostname}`);
        console.log(`üìö Source collection: ${response.automation.sourceCollection || 'Unknown'} (based on user role)`);
        console.log(`üé≠ Role-based access: ${response.automation.sourceCollection === 'automationSteps' ? 'User collection' : 'Admin/Collaborator collection'}`);
        
        // Validate domain authority before proceeding - check both original and base domain
        const automationDomainName = response.automation.domainName;
        const isOriginalSupported = isDomainSupported(originalHostname, automationDomainName);
        const isBaseSupported = isDomainSupported(hostname, automationDomainName);
        
        if (!isOriginalSupported && !isBaseSupported) {
          console.error(`‚ùå Domain authority validation failed: Current domain "${originalHostname}" (base: "${hostname}") does not match automation domainName "${automationDomainName}"`);
          throw new Error(`Domain not supported: Current domain "${hostname}" does not match automation domainName "${automationDomainName}"`);
        }
        
        if (isOriginalSupported) {
          console.log(`‚úÖ Domain authority validated: Original hostname "${originalHostname}" is supported by automation domainName "${automationDomainName}"`);
        } else if (isBaseSupported) {
          console.log(`‚úÖ Domain authority validated: Base domain "${hostname}" is supported by automation domainName "${automationDomainName}"`);
        }
        
        const steps = response.automation.steps || [];
        
        // Debug: Show first few step selectors
        if (steps.length > 0) {
          console.log(`üîç First 3 step selectors from IndexedDB:`);
          steps.slice(0, 3).forEach((step, index) => {
            console.log(`   Step ${index + 1}: ${step.action} - "${step.selector}"`);
          });
        }
        
        // Fix double-escaped selectors in IndexedDB data
        steps.forEach((step, index) => {
          if (step.selector) {
            let originalSelector = step.selector;
            let needsFix = false;
            
            // Fix double-escaped quotes
            if (step.selector.includes('\\\\"')) {
              step.selector = step.selector.replace(/\\\\"/g, '"');
              needsFix = true;
            }
            
            // Fix unescaped dots in ID selectors (e.g., #page1.firstName -> #page1\.firstName)
            if (step.selector.startsWith('#') && step.selector.includes('.') && !step.selector.includes('\\.')) {
              step.selector = step.selector.replace(/#([^.#\s]+)\.([^.#\s]+)/g, '#$1\\.$2');
              needsFix = true;
            }
            
            if (needsFix) {
              console.log(`üîß [FIX] Fixed selector in step ${index + 1}:`);
              console.log(`   Original: "${originalSelector}"`);
              console.log(`   Fixed:    "${step.selector}"`);
            }
          }
        });
        
        // Check if IndexedDB has sufficient steps (at least 5 steps)
        if (steps.length < 5) {
          console.warn(`‚ö†Ô∏è IndexedDB only has ${steps.length} steps - this seems incomplete. Trying local file...`);
          
          // Try to get local file for comparison
          const filenames = getFilenames();
          for (const filename of filenames) {
            try {
              const localUrl = chrome.runtime.getURL(`automation/${filename}`);
              const localResponse = await fetch(localUrl);
              if (localResponse.ok) {
                const localSteps = await localResponse.json();
                console.log(`üìä Local file has ${localSteps.length} steps vs IndexedDB ${steps.length} steps`);
                
                if (localSteps.length > steps.length) {
                  console.log(`‚úÖ Using local file (${localSteps.length} steps) instead of IndexedDB (${steps.length} steps)`);
                  
                  // Validate domain authority for local file (filename should match domain)
                  const filenameDomain = filename.replace('.json', '').replace(/_/g, '.');
                  if (!isDomainSupported(hostname, filenameDomain)) {
                    console.warn(`‚ö†Ô∏è Domain authority validation failed for local file: Current domain "${hostname}" does not match filename domain "${filenameDomain}"`);
                    continue; // Try next filename
                  }
                  
                  reportAutomationStatus({ totalSteps: getVisibleTotalSteps(localSteps) });
                  return localSteps;
                }
              }
            } catch (err) {
              console.warn(`‚ö†Ô∏è Error checking local file: ${filename}`, err);
            }
          }
        }
        
        reportAutomationStatus({ totalSteps: getVisibleTotalSteps(steps) });
        return steps;
      } else {
        console.warn(`‚ö†Ô∏è No automation found in IndexedDB for ${hostname}, attempting sync...`);
        
        // Try to sync automations from Firestore
        const syncResponse = await new Promise((resolve, reject) => {
          chrome.runtime.sendMessage({ type: "SYNC_AUTOMATIONS" }, (response) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else {
              resolve(response);
            }
          });
        });

        if (syncResponse && syncResponse.success) {
          console.log(`üîÑ Automation sync completed, retrying load...`);
          
          // Retry getting automation after sync - try base domain first
          let retryResponse = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage({ type: "GET_AUTOMATION", domainName: hostname }, (response) => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
              } else {
                resolve(response);
              }
            });
          });

          // If not found with base domain, try original hostname
          if ((!retryResponse || !retryResponse.success || !retryResponse.automation) && originalHostname !== hostname) {
            console.log(`üîÑ Retry: No automation found for base domain ${hostname}, trying original hostname: ${originalHostname}`);
            retryResponse = await new Promise((resolve, reject) => {
              chrome.runtime.sendMessage({ type: "GET_AUTOMATION", domainName: originalHostname }, (response) => {
                if (chrome.runtime.lastError) {
                  reject(new Error(chrome.runtime.lastError.message));
                } else {
                  resolve(response);
                }
              });
            });
          }

          if (retryResponse && retryResponse.success && retryResponse.automation) {
            console.log(`‚úÖ Automation loaded after sync for ${hostname}`);
            console.log(`üìö Source collection: ${retryResponse.automation.sourceCollection || 'Unknown'} (based on user role)`);
            console.log(`üé≠ Role-based access: ${retryResponse.automation.sourceCollection === 'automationSteps' ? 'User collection' : 'Admin/Collaborator collection'}`);
            
            // Validate domain authority before proceeding - check both original and base domain
            const automationDomainName = retryResponse.automation.domainName;
            const isOriginalSupported = isDomainSupported(originalHostname, automationDomainName);
            const isBaseSupported = isDomainSupported(hostname, automationDomainName);
            
            if (!isOriginalSupported && !isBaseSupported) {
              console.error(`‚ùå Domain authority validation failed after sync: Current domain "${originalHostname}" (base: "${hostname}") does not match automation domainName "${automationDomainName}"`);
              throw new Error(`Domain not supported: Current domain "${hostname}" does not match automation domainName "${automationDomainName}"`);
            }
            
            if (isOriginalSupported) {
              console.log(`‚úÖ Domain authority validated after sync: Original hostname "${originalHostname}" is supported by automation domainName "${automationDomainName}"`);
            } else if (isBaseSupported) {
              console.log(`‚úÖ Domain authority validated after sync: Base domain "${hostname}" is supported by automation domainName "${automationDomainName}"`);
            }
            
            const steps = retryResponse.automation.steps || [];
            reportAutomationStatus({ totalSteps: getVisibleTotalSteps(steps) });
            return steps;
          }
        }
        
        console.error(`‚ùå No automation found for ${hostname} after sync attempt`);
        await debugIndexedDBState(hostname);
        return null;
      }
    } catch (error) {
      console.error(`‚ùå Error loading automation for ${hostname}:`, error);
      
      // Fallback to local files if background script fails
      console.log(`üîÑ Falling back to local automation files...`);
      const filenames = getFilenames();
      for (const filename of filenames) {
        try {
          const localUrl = chrome.runtime.getURL(`automation/${filename}`);
          const response = await fetch(localUrl);
          if (response.ok) {
            const steps = await response.json();
            console.log(`‚úÖ Found automation file in local automation folder: ${filename}`);
            
            // Validate domain authority for local file (filename should match domain)
            const filenameDomain = filename.replace('.json', '').replace(/_/g, '.');
            if (!isDomainSupported(hostname, filenameDomain)) {
              console.warn(`‚ö†Ô∏è Domain authority validation failed for local file: Current domain "${hostname}" does not match filename domain "${filenameDomain}"`);
              continue; // Try next filename
            }
            
            reportAutomationStatus({ totalSteps: getVisibleTotalSteps(steps) });
            return steps;
          }
        } catch (err) {
          console.warn(`‚ö†Ô∏è Error loading local automation file: ${filename}`, err);
        }
      }
      
      console.error(`‚ùå No automation found for ${hostname} (all methods failed)`);
      return null;
    }
  };

  // Debug function to get IndexedDB state
  const debugIndexedDBState = async (domainName) => {
    try {
      console.log(`üîç Debugging automation system state for domain: ${domainName}`);
      const response = await new Promise((resolve, reject) => {
        chrome.runtime.sendMessage({ type: "DEBUG_INDEXEDDB" }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else {
            resolve(response);
          }
        });
      });
      
      if (response && response.success) {
        console.log("üìä Debug Info:", response.debugInfo);
        
        if (response.debugInfo.indexedDBAvailable === false) {
          console.log("‚ö†Ô∏è IndexedDB is not available - checking Firestore data");
          if (response.debugInfo.firestoreData) {
            console.log("üìä Firestore data (active only):", response.debugInfo.firestoreData);
            const domainInFirestore = response.debugInfo.firestoreData.find(d => d.domainName === domainName);
            if (domainInFirestore) {
              console.log(`‚úÖ Found ${domainName} in Firestore (active):`, domainInFirestore);
              console.log("üí° The automation exists in Firestore - IndexedDB sync may have failed");
            } else {
              console.log(`‚ùå ${domainName} not found in Firestore (active)`);
              console.log("üìã Available domains in Firestore (active):", response.debugInfo.firestoreData.map(d => d.domainName));
            }
          } else {
            console.log("‚ùå No Firestore data available in debug info");
          }
          
          if (response.debugInfo.allFirestoreData) {
            console.log("üìä All Firestore data (any status):", response.debugInfo.allFirestoreData);
            const domainInAllFirestore = response.debugInfo.allFirestoreData.find(d => d.domainName === domainName);
            if (domainInAllFirestore) {
              console.log(`‚úÖ Found ${domainName} in Firestore (any status):`, domainInAllFirestore);
              console.log(`üí° The automation exists but has status "${domainInAllFirestore.status}" instead of "active"`);
            } else {
              console.log(`‚ùå ${domainName} not found in Firestore (any status)`);
              console.log("üìã Available domains in Firestore (any status):", response.debugInfo.allFirestoreData.map(d => d.domainName));
            }
          }
        } else {
          if (response.debugInfo.tasks) {
            const domainTask = response.debugInfo.tasks.find(t => t.domainName === domainName);
            if (domainTask) {
              console.log(`‚úÖ Found task for ${domainName} in IndexedDB:`, domainTask);
            } else {
              console.log(`‚ùå No task found for ${domainName} in IndexedDB`);
              console.log("üìã Available domains in IndexedDB:", response.debugInfo.tasks.map(t => t.domainName));
            }
          } else {
            console.log("‚ùå No IndexedDB tasks data available in debug info");
          }
        }
        
        if (response.debugInfo.syncStatus) {
          console.log("üìä Sync Status:", response.debugInfo.syncStatus);
        }
        
        if (response.debugInfo.userRoleInfo) {
          console.log("üë§ User Role Information:", response.debugInfo.userRoleInfo);
          if (response.debugInfo.userRoleInfo.user_roles) {
            const userRole = response.debugInfo.userRoleInfo.user_roles;
            console.log(`üé≠ User Role: ${userRole.role || 'Not set'}`);
            console.log(`üë§ User ID: ${userRole.userId || 'Unknown'}`);
            console.log(`üìß Email: ${userRole.email || 'Not set'}`);
            console.log(`üìù Display Name: ${userRole.displayName || 'Not set'}`);
            console.log(`üïí Last Updated: ${userRole.lastUpdated || 'Unknown'}`);
          } else {
            console.log("‚ö†Ô∏è No user roles found - this may affect automation eligibility");
          }
        }
      } else {
        console.error("‚ùå Failed to get debug info:", response?.error);
      }
    } catch (error) {
      console.error("‚ùå Error debugging automation system:", error);
    }
  };

  // --- Automation Step Functions ---
  async function tickPaymentMethodCheckboxes(step = {}) {
    const { actionMode, acceptedPaymentMethods, selector, stepIndex = '' } = step;
    
    console.log(`üîç [${stepIndex}] Looking for payment method checkboxes... (actionMode: ${actionMode || 'default'})`);
    
    // Get payment methods from CampaignData
    const { CampaignData = {} } = await chrome.storage.local.get(["CampaignData"]);
    
    // Handle nested structure - support both direct and nested CampaignData formats
    let nestedCampaign = null;
    if (Object.keys(CampaignData).length > 0) {
      if (CampaignData.campaignData) {
        nestedCampaign = CampaignData;
      } else {
        nestedCampaign = Object.values(CampaignData)[0];
        if (!nestedCampaign?.campaignData) {
          nestedCampaign = { campaignData: CampaignData };
        }
      }
    }
    
    const paymentMethodsData = nestedCampaign?.campaignData?.paymentMethodsBox || "";
    
    console.log(`üîç [${stepIndex}] [PAYMENT METHOD DEBUG] Full CampaignData:`, CampaignData);
    console.log(`üîç [${stepIndex}] [PAYMENT METHOD DEBUG] Nested campaign:`, nestedCampaign);
    console.log(`üîç [${stepIndex}] [PAYMENT METHOD DEBUG] Payment methods from CampaignData:`, paymentMethodsData);
    
    // Parse payment methods (comma-separated string) - keep original case for exact matching
    let paymentMethods = [];
    if (paymentMethodsData && typeof paymentMethodsData === 'string') {
      paymentMethods = paymentMethodsData
        .split(',')
        .map(method => method.trim())
        .filter(method => method.length > 0);
      console.log(`üîç [${stepIndex}] [PAYMENT METHOD] Parsed payment methods:`, paymentMethods);
    } else if (Array.isArray(paymentMethodsData)) {
      paymentMethods = paymentMethodsData.map(method => String(method).trim()).filter(method => method.length > 0);
      console.log(`üîç [${stepIndex}] [PAYMENT METHOD] Payment methods from array:`, paymentMethods);
    }
    
    if (paymentMethods.length === 0) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] No payment methods found in CampaignData.campaignData.paymentMethodsBox`);
      return 0;
    }
    
    // ============================================================================
    // CENTRALIZED PAYMENT METHOD MAPPING SYSTEM
    // ============================================================================
    // This unified mapping system is used across all payment method functions
    // Structure: { preferredFormat: [allVariations, including, aliases] }
    // ============================================================================
    // NOTE: This must be defined BEFORE filtering by acceptedPaymentMethods
    // so that the mapping can be used to expand acceptedPaymentMethods to include all variations
    // ============================================================================
    const PAYMENT_METHOD_MAPPINGS = {
      // Personal Check variations
      'Personal Check': ['Check', 'Personal Check', 'Cheque', 'Personal Cheque'],
    
      // Visa variations
      'Visa': ['Visa', 'VISA', 'Visa Card'],
    
      // Invoice variations
      'Invoice': ['Invoice'],
    
      // Financing variations
      'Financing Available': [
        'Financing Available',
        'Financing'
      ],
    
      // Mastercard variations
      'Mastercard': ['Mastercard', 'Master Card', 'Master-Card'],
    
      // Insurance variations
      'Insurance': [
        'Insurance',
        'Insurance Accepted',
        'Insurance Payment'
      ],
    
      // American Express variations
      'American Express': ['American Express', 'AMEX', 'Amex', 'American-Express'],
    
      // ATM / Debit variations
      'ATM / Debit': [
        'ATM / Debit',
        'Debit',
        'Debit Card',
        'ATM',
        'ATM Card'
      ],
    
      // Discover variations
      'Discover': ['Discover', 'Discover Card']
    };
    
    
    // Reverse mapping: from any variation to preferred format (for filling)
    const PAYMENT_METHOD_FILL_MAPPING = {};
    Object.keys(PAYMENT_METHOD_MAPPINGS).forEach(preferred => {
      PAYMENT_METHOD_MAPPINGS[preferred].forEach(variation => {
        // Map all case variations
        PAYMENT_METHOD_FILL_MAPPING[variation.toLowerCase()] = preferred;
        PAYMENT_METHOD_FILL_MAPPING[variation] = preferred;
        PAYMENT_METHOD_FILL_MAPPING[variation.toUpperCase()] = preferred;
        // Also map capitalized version
        const capitalized = variation.charAt(0).toUpperCase() + variation.slice(1).toLowerCase();
        PAYMENT_METHOD_FILL_MAPPING[capitalized] = preferred;
      });
    });
    
    // Filter payment methods by acceptedPaymentMethods if provided
    // IMPORTANT: This uses the mapping system to expand acceptedPaymentMethods
    // so that if controller passes "Personal Check", we also accept "Check", "Cheque", "Personal Cheque" from CampaignData
    if (acceptedPaymentMethods && Array.isArray(acceptedPaymentMethods) && acceptedPaymentMethods.length > 0) {
      // Expand acceptedPaymentMethods to include all variations from the mapping
      const expandedAcceptedSet = new Set();
      
      acceptedPaymentMethods.forEach(acceptedMethod => {
        const methodTrimmed = String(acceptedMethod).trim();
        // Add the original method
        expandedAcceptedSet.add(methodTrimmed);
        
        // Find which mapping group this accepted method belongs to and add all variations
        for (const [preferred, aliases] of Object.entries(PAYMENT_METHOD_MAPPINGS)) {
          const allVariations = [preferred, ...aliases];
          const matches = allVariations.some(v => 
            v.toLowerCase() === methodTrimmed.toLowerCase()
          );
          
          if (matches) {
            // Add all variations from this group (case-insensitive matching)
            allVariations.forEach(variation => {
              expandedAcceptedSet.add(variation);
              expandedAcceptedSet.add(variation.toLowerCase());
              expandedAcceptedSet.add(variation.toUpperCase());
            });
            break;
          }
        }
      });
      
      console.log(`üîç [${stepIndex}] [PAYMENT METHOD] Original acceptedPaymentMethods:`, acceptedPaymentMethods);
      console.log(`üîç [${stepIndex}] [PAYMENT METHOD] Expanded acceptedPaymentMethods (with all variations):`, Array.from(expandedAcceptedSet));
      
      // Now filter paymentMethods using the expanded set (case-insensitive)
      paymentMethods = paymentMethods.filter(method => {
        const methodTrimmed = method.trim();
        // Check if method matches any variation in the expanded set (case-insensitive)
        return Array.from(expandedAcceptedSet).some(accepted => 
          accepted.toLowerCase() === methodTrimmed.toLowerCase()
        );
      });
      
      console.log(`üîç [${stepIndex}] [PAYMENT METHOD] Filtered by acceptedPaymentMethods:`, paymentMethods);
      
      if (paymentMethods.length === 0) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] No payment methods match acceptedPaymentMethods (after mapping expansion)`);
        return 0;
      }
    }
    
    // Payment method mapping function - returns all possible label variations for matching
    // Used by findAndTickCheckbox to match checkboxes with various label formats
    function getPaymentMethodVariations(paymentMethod) {
      const variations = [paymentMethod]; // Always include original
      
      // Normalize input for lookup (case-insensitive)
      const normalizedInput = paymentMethod.trim();
      
      // Find which mapping group this payment method belongs to
      for (const [preferred, aliases] of Object.entries(PAYMENT_METHOD_MAPPINGS)) {
        // Check if paymentMethod matches any variation in this group
        const allVariations = [preferred, ...aliases];
        const matches = allVariations.some(v => 
          v.toLowerCase() === normalizedInput.toLowerCase()
        );
        
        if (matches) {
          // Add all variations from this group
          variations.push(...allVariations);
          break;
        }
      }
      
      // Remove duplicates while preserving order
      return [...new Set(variations)];
    }
    
    // Payment method mapping function for filling (converts to preferred format)
    // Used by fillAndIndent to convert payment methods to their preferred format
    function mapPaymentMethodForFill(paymentMethod) {
      if (!paymentMethod || typeof paymentMethod !== 'string') {
        return paymentMethod;
      }
      
      const normalized = paymentMethod.trim();
      
      // Check exact match first
      if (PAYMENT_METHOD_FILL_MAPPING[normalized]) {
        return PAYMENT_METHOD_FILL_MAPPING[normalized];
      }
      
      // Check case-insensitive match
      if (PAYMENT_METHOD_FILL_MAPPING[normalized.toLowerCase()]) {
        return PAYMENT_METHOD_FILL_MAPPING[normalized.toLowerCase()];
      }
      
      // Check if it's already a preferred format
      if (PAYMENT_METHOD_MAPPINGS[normalized]) {
        return normalized;
      }
      
      // Return original if no mapping found
      return paymentMethod;
    }
    
    // Function to check if a checkbox label exactly matches a payment method
    function matchesExactLabel(labelText, paymentMethodVariations) {
      const normalizedLabel = labelText.trim();
      
      // CRITICAL: Reject labels that start with negative prefixes like "No", "Not", "Without", etc.
      const negativePrefixes = ['no ', 'not ', 'without ', 'exclude ', 'except ', 'non-', 'un'];
      const normalizedLabelLower = normalizedLabel.toLowerCase();
      for (const prefix of negativePrefixes) {
        if (normalizedLabelLower.startsWith(prefix)) {
          return false; // Reject labels with negative prefixes
        }
      }
      
      // Check exact match first (case-insensitive)
      for (const variation of paymentMethodVariations) {
        if (normalizedLabel.toLowerCase() === variation.toLowerCase()) {
          return true;
        }
      }
      
      return false;
    }
    
    // Function to check if a checkbox label contains payment method (but not as part of a larger phrase)
    function matchesLabelContains(labelText, paymentMethodVariations) {
      const normalizedLabel = labelText.toLowerCase().trim();
      
      // CRITICAL: Reject labels that start with negative prefixes like "No", "Not", "Without", etc.
      const negativePrefixes = ['no ', 'not ', 'without ', 'exclude ', 'except ', 'non-', 'un'];
      for (const prefix of negativePrefixes) {
        if (normalizedLabel.startsWith(prefix)) {
          return false; // Reject labels with negative prefixes
        }
      }
      
      for (const variation of paymentMethodVariations) {
        const normalizedVariation = variation.toLowerCase().trim();
        
        // For multi-word payment methods (contains space or slash), allow matching if all words are present
        if (normalizedVariation.includes('/') || normalizedVariation.includes(' ')) {
          // Split by / or space and check if all parts are present as standalone words
          const parts = normalizedVariation.split(/[\/\s]+/).filter(p => p.length > 0);
          if (parts.length > 1) {
            const allPartsMatch = parts.every(part => {
              // Check if this part appears as a standalone word in the label
              const partRegex = new RegExp(`\\b${part.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
              return partRegex.test(normalizedLabel);
            });
            if (allPartsMatch) {
              return true;
            }
          }
        } else {
          // For single-word payment methods like "Cash", "Visa", "Mastercard", "Check"
          // STRICT: Use word boundaries to prevent partial matches
          // This prevents "Cash" from matching "Personal Check" or "Check" from matching "Cashier"
          
          // First, check exact match (whole label equals payment method)
          if (normalizedLabel === normalizedVariation) {
            return true;
          }
          
          // Second, check if it appears as a standalone word with word boundaries
          // This ensures "Cash" matches "Cash" but not "Cashier" or "Personal Check"
          const wordBoundaryRegex = new RegExp(`\\b${normalizedVariation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
          if (wordBoundaryRegex.test(normalizedLabel)) {
            // Additional validation: ensure the match is not part of a longer word
            // For example, "Cash" should not match "Cashier's Check"
            const matchIndex = normalizedLabel.indexOf(normalizedVariation);
            if (matchIndex !== -1) {
              // CRITICAL: Check if "no" or other negative words appear before the payment method
              const textBeforeMatch = normalizedLabel.substring(0, matchIndex).trim();
              const negativeWordsBefore = /\b(no|not|without|exclude|except|non|un)\s+$/i.test(textBeforeMatch);
              if (negativeWordsBefore) {
                return false; // Reject if negative word appears before payment method
              }
              
              const beforeChar = matchIndex > 0 ? normalizedLabel[matchIndex - 1] : ' ';
              const afterChar = matchIndex + normalizedVariation.length < normalizedLabel.length 
                ? normalizedLabel[matchIndex + normalizedVariation.length] 
                : ' ';
              // Check word boundaries (non-word characters or start/end of string)
              const isWordBoundaryBefore = !/\w/.test(beforeChar);
              const isWordBoundaryAfter = !/\w/.test(afterChar);
              
              if (isWordBoundaryBefore && isWordBoundaryAfter) {
                // ADDITIONAL SAFETY CHECK: For single-word payment methods, verify the label doesn't contain
                // other payment method keywords that would indicate a false match
                // This prevents "Cash" from matching "Personal Check" even if word boundaries pass
                const conflictingKeywords = ['check', 'cheque', 'card', 'visa', 'mastercard', 'amex', 'discover', 'debit', 'credit', 'invoice', 'financing'];
                const hasConflictingKeyword = conflictingKeywords.some(keyword => {
                  // Only check for conflicts if the keyword is different from the payment method
                  if (keyword === normalizedVariation) return false;
                  // Check if the conflicting keyword appears as a standalone word in the label
                  const keywordRegex = new RegExp(`\\b${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                  return keywordRegex.test(normalizedLabel);
                });
                
                if (hasConflictingKeyword) {
                  // If we found a conflicting keyword, this is likely a false match
                  // Only allow if the label is exactly the payment method (already checked above)
                  // or if the payment method word appears before the conflicting keyword
                  const paymentMethodIndex = normalizedLabel.indexOf(normalizedVariation);
                  const conflictingIndices = conflictingKeywords
                    .filter(k => k !== normalizedVariation)
                    .map(k => normalizedLabel.indexOf(k))
                    .filter(idx => idx !== -1);
                  
                  // If conflicting keywords appear before or at the same position as payment method, reject
                  if (conflictingIndices.length > 0 && conflictingIndices.some(idx => idx <= paymentMethodIndex)) {
                    return false; // Reject false match
                  }
                }
                
                return true;
              }
            }
          }
          
          // Third, allow if it appears in a comma-separated list format
          const isInCommaList = new RegExp(`(^|,\\s*)${normalizedVariation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(\\s*,|$)`, 'i').test(normalizedLabel);
          if (isInCommaList) {
            return true;
          }
        }
      }
      
      return false;
    }
    
    // Handle different action modes
    if (actionMode === 'fillAndIndent') {
      return await handleFillAndIndent(paymentMethods, selector, stepIndex, mapPaymentMethodForFill, PAYMENT_METHOD_MAPPINGS);
    } else if (actionMode === 'findAndTickCheckbox') {
      return await handleFindAndTickCheckbox(paymentMethods, selector, stepIndex, getPaymentMethodVariations, matchesExactLabel, matchesLabelContains);
    } else if (actionMode === 'findAndClickButton') {
      return await handleFindAndClickButton(paymentMethods, selector, stepIndex, getPaymentMethodVariations, matchesExactLabel, matchesLabelContains);
    } else if (actionMode === 'fillAndAddTextbox') {
      return await handleFillAndAddTextbox(paymentMethods, selector, stepIndex, mapPaymentMethodForFill);
    } else {
      // Default behavior: findAndTickCheckbox (backward compatibility)
      return await handleFindAndTickCheckbox(paymentMethods, selector, stepIndex, getPaymentMethodVariations, matchesExactLabel, matchesLabelContains);
    }
  }
  
  // Helper function for fillAndIndent mode
  async function handleFillAndIndent(paymentMethods, selector, stepIndex, mapPaymentMethodForFill, PAYMENT_METHOD_MAPPINGS) {
    if (!selector) {
      console.error(`‚ùå [${stepIndex}] fillAndIndent mode requires a selector`);
      return 0;
    }
    
    const targetElement = document.querySelector(selector);
    if (!targetElement) {
      console.error(`‚ùå [${stepIndex}] Target element not found for selector: ${selector}`);
      return 0;
    }
    
    console.log(`üîç [${stepIndex}] fillAndIndent mode: Filling ${paymentMethods.length} payment methods individually`);
    
    let filledCount = 0;
    
    // Focus the element first
    targetElement.focus();
    await delay(200);
    
    // Clear the field first
    if (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA') {
      targetElement.value = '';
      targetElement.dispatchEvent(new Event('input', { bubbles: true }));
      targetElement.dispatchEvent(new Event('change', { bubbles: true }));
    } else {
      targetElement.textContent = '';
      targetElement.dispatchEvent(new Event('input', { bubbles: true }));
    }
    await delay(200);
    
    // Helper function to get current field value
    function getFieldValue() {
      if (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA') {
        return targetElement.value || '';
      } else {
        return targetElement.textContent || '';
      }
    }
    
    // Helper function to check if payment method exists in textbox content
    // Returns: { exists: boolean, matchedLine: string | null, isExactMatch: boolean }
    function paymentMethodExistsInContent(content, paymentMethod) {
      if (!content) return { exists: false, matchedLine: null, isExactMatch: false };
      
      // Check if payment method appears in the content (case-insensitive, as whole word or part of line)
      const normalizedContent = content.toLowerCase().trim();
      const normalizedPaymentMethod = paymentMethod.toLowerCase().trim();
      
      // Split by newlines and check each line
      const lines = normalizedContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);
      
      // Check if any line exactly matches or contains the payment method
      for (const line of lines) {
        // Exact match (case-insensitive) - PREFERRED
        if (line === normalizedPaymentMethod) {
          return { exists: true, matchedLine: line, isExactMatch: true };
        }
        // Contains match (for partial matches) - but check if it's not a false positive
        // e.g., "Check" should not match "Personal Check" unless we're looking for "Personal Check"
        if (line.includes(normalizedPaymentMethod)) {
          // If the line is longer than what we're looking for, it might be a different variation
          // Only accept if the line starts with or equals the payment method (to avoid "Check" matching "Personal Check")
          if (line === normalizedPaymentMethod || line.startsWith(normalizedPaymentMethod + ' ')) {
            return { exists: true, matchedLine: line, isExactMatch: line === normalizedPaymentMethod };
          }
        }
      }
      
      return { exists: false, matchedLine: null, isExactMatch: false };
    }
    
    // Helper function to check if payment method already exists (to prevent duplicates)
    function paymentMethodAlreadyExists(paymentMethod) {
      const currentContent = getFieldValue();
      const result = paymentMethodExistsInContent(currentContent, paymentMethod);
      return result.exists;
    }
    
    // Helper function to fill text all at once (paste-style for faster parallel execution)
    async function typeText(text) {
      // Clear current input value first
      if (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA') {
        targetElement.value = '';
      } else {
        targetElement.textContent = '';
      }
      
      // Set the entire value at once (paste-style)
      if (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA') {
        targetElement.value = text;
      } else {
        targetElement.textContent = text;
      }
      
      // Dispatch paste event to simulate paste operation
      const pasteEvent = new ClipboardEvent('paste', {
        bubbles: true,
        cancelable: true,
        clipboardData: new DataTransfer()
      });
      targetElement.dispatchEvent(pasteEvent);
      
      // Dispatch input event (single event for the entire text)
      targetElement.dispatchEvent(new Event('input', { bubbles: true }));
      
      // Dispatch change event
      targetElement.dispatchEvent(new Event('change', { bubbles: true }));
      
      // Small delay to allow the field to process the value
      await delay(100);
    }
    
    // Helper function to press Enter key
    async function pressEnter() {
      await delay(200);
      
      // Simulate Enter key press to create new line/indent
      const enterEvent = new KeyboardEvent('keydown', {
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
        which: 13,
        bubbles: true,
        cancelable: true
      });
      targetElement.dispatchEvent(enterEvent);
      
      const enterEventPress = new KeyboardEvent('keypress', {
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
        which: 13,
        bubbles: true,
        cancelable: true
      });
      targetElement.dispatchEvent(enterEventPress);
      
      const enterEventUp = new KeyboardEvent('keyup', {
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
        which: 13,
        bubbles: true,
        cancelable: true
      });
      targetElement.dispatchEvent(enterEventUp);
      
      await delay(400); // Delay after pressing Enter
    }
    
    // Helper function to try a payment method and verify if it's accepted by the textbox
    // Returns true if the payment method is successfully entered and verified, false otherwise
    async function tryPaymentMethod(paymentMethodToTry, attemptLabel) {
      console.log(`üîç [${stepIndex}] ${attemptLabel}: Trying "${paymentMethodToTry}"`);
      
      // Check if payment method already exists (prevent duplicates)
      if (paymentMethodAlreadyExists(paymentMethodToTry)) {
        console.log(`‚úÖ [${stepIndex}] Payment method "${paymentMethodToTry}" already exists in textbox, skipping`);
        return true; // Already exists, consider it successful
      }
      
      // Get content before typing to preserve existing payment methods
      const contentBefore = getFieldValue();
      const existingPaymentMethods = contentBefore.split('\n').map(l => l.trim()).filter(l => l.length > 0);
      
      // Focus the element to ensure we're working with the right field
      targetElement.focus();
      await delay(150);
      
      // For fillAndIndent mode, we need to type in the input field
      // The field might accumulate entries, so we should work with the current input area
      // Clear only the current input value (not the entire accumulated content)
      // We'll type the payment method, and after pressing Enter, it should be added to the content
      if (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA') {
        // Store the current value to restore if needed
        // But actually, for autocomplete, we want to clear the input to type fresh
        // The accumulated content should be preserved elsewhere or in the field value
        // For now, clear the value to type the new payment method
        // After Enter, the new content should include both old and new
        targetElement.value = '';
        targetElement.dispatchEvent(new Event('input', { bubbles: true }));
      } else {
        targetElement.textContent = '';
        targetElement.dispatchEvent(new Event('input', { bubbles: true }));
      }
      await delay(100);
      
      // Fill the payment method all at once (paste-style)
      await typeText(paymentMethodToTry);
      
      // Wait for autocomplete to process and show suggestions (reduced delay since we're pasting)
      await delay(300);
      
      // Check if autocomplete suggestions are visible (common selectors for autocomplete dropdowns)
      let suggestionsVisible = false;
      try {
        // Look for common autocomplete dropdown selectors
        const autocompleteSelectors = [
          'ul[role="listbox"]',
          'div[role="listbox"]',
          '.autocomplete',
          '.suggestions',
          '[data-autocomplete]',
          '.dropdown-menu',
          '.ui-autocomplete',
          'ul.autocomplete-list',
          'div.autocomplete-list'
        ];
        
        for (const selector of autocompleteSelectors) {
          const dropdown = document.querySelector(selector);
          if (dropdown && dropdown.offsetParent !== null) {
            // Check if any suggestion contains the payment method (case-insensitive)
            const suggestionTexts = dropdown.innerText || dropdown.textContent || '';
            if (suggestionTexts.toLowerCase().includes(paymentMethodToTry.toLowerCase())) {
              suggestionsVisible = true;
              console.log(`‚úÖ [${stepIndex}] Found autocomplete suggestions containing "${paymentMethodToTry}"`);
              break;
            }
          }
        }
      } catch (e) {
        // Ignore errors when checking for suggestions
      }
      
      // Verify the payment method text is in the input field
      let currentValue = getFieldValue();
      let textInField = currentValue.toLowerCase().trim().includes(paymentMethodToTry.toLowerCase().trim());
      
      // If we have suggestions or text in field, the payment method might be accepted
      if (suggestionsVisible || textInField) {
        console.log(`‚úÖ [${stepIndex}] Payment method "${paymentMethodToTry}" appears to be accepted (suggestions: ${suggestionsVisible}, text in field: ${textInField})`);
        
        // Press Enter to accept/indent the payment method
        await pressEnter();
        
        // Verify the payment method is in the content after pressing Enter
        await delay(500);
        currentValue = getFieldValue();
        
        // Check if payment method now exists in the content (with strict matching)
        const result = paymentMethodExistsInContent(currentValue, paymentMethodToTry);
        
        if (result.exists) {
          if (result.isExactMatch) {
            console.log(`‚úÖ [${stepIndex}] ‚úÖ EXACT MATCH: Payment method "${paymentMethodToTry}" confirmed in textbox (exact match)`);
          } else {
            console.log(`‚úÖ [${stepIndex}] ‚úÖ PARTIAL MATCH: Payment method "${paymentMethodToTry}" found in textbox (matched: "${result.matchedLine}")`);
          }
          
          // Additional check: verify it wasn't a duplicate (count occurrences)
          const lines = currentValue.split('\n').map(l => l.trim()).filter(l => l.length > 0);
          const occurrences = lines.filter(line => {
            const lineLower = line.toLowerCase();
            const methodLower = paymentMethodToTry.toLowerCase();
            // Only count exact matches or lines that start with the payment method
            return lineLower === methodLower || lineLower.startsWith(methodLower + ' ');
          }).length;
          
          if (occurrences > 1) {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Payment method "${paymentMethodToTry}" appears ${occurrences} times - possible duplicate`);
          }
          
          // IMPORTANT: If we tried "Check" but got "Personal Check", this is a mismatch
          // We should only accept if the entered value matches what we tried
          if (!result.isExactMatch && result.matchedLine && result.matchedLine !== paymentMethodToTry.toLowerCase()) {
            console.warn(`‚ö†Ô∏è [${stepIndex}] MISMATCH: Tried "${paymentMethodToTry}" but got "${result.matchedLine}" - this might be a different variation`);
            // Don't accept if we tried a shorter variation but got a longer one
            // e.g., tried "Check" but got "Personal Check"
            if (result.matchedLine.length > paymentMethodToTry.length && 
                result.matchedLine.includes(paymentMethodToTry.toLowerCase())) {
              console.warn(`‚ö†Ô∏è [${stepIndex}] REJECTING: Tried shorter "${paymentMethodToTry}" but autocomplete selected longer "${result.matchedLine}" - will try next variation`);
              return false;
            }
          }
          
          return true;
        } else {
          console.warn(`‚ö†Ô∏è [${stepIndex}] ‚ùå Payment method "${paymentMethodToTry}" NOT found in textbox after Enter press`);
          // Check what's actually in the textbox now
          const lines = currentValue.split('\n').map(l => l.trim()).filter(l => l.length > 0);
          console.log(`üîç [${stepIndex}] Current textbox content lines (${lines.length}):`, lines);
          console.log(`üîç [${stepIndex}] Content before: ${existingPaymentMethods.length} lines, Content after: ${lines.length} lines`);
          return false;
        }
      } else {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Payment method "${paymentMethodToTry}" not accepted by textbox (no suggestions, text not in field)`);
        return false;
      }
    }
    
    // Helper function to get all variations to try for a payment method
    // Returns array of payment methods to try in order: [shorter variations first, then original, then longer variations]
    // Special case: For "Personal Check", "Check" is tried first
    function getAllVariationsToTry(paymentMethod) {
      const normalized = paymentMethod.trim().toLowerCase();
      
      if (!PAYMENT_METHOD_MAPPINGS) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] PAYMENT_METHOD_MAPPINGS not available, only trying original: "${paymentMethod}"`);
        return [paymentMethod];
      }
      
      // Find which mapping group this payment method belongs to
      for (const [preferred, aliases] of Object.entries(PAYMENT_METHOD_MAPPINGS)) {
        const allVariations = [preferred, ...aliases];
        const matches = allVariations.some(v => 
          v.toLowerCase() === normalized
        );
        
        if (matches) {
          // Collect all variations from the group
          const allGroupVariations = [preferred, ...aliases];
          
          // Find the shortest variation that is contained in the original (for "Personal Check" -> "Check")
          let shortestContained = null;
          for (const variation of allGroupVariations) {
            const variationLower = variation.toLowerCase();
            // Check if this variation is shorter and is contained in the original payment method
            if (variation.length < paymentMethod.length && 
                normalized.includes(variationLower) &&
                (!shortestContained || variation.length < shortestContained.length)) {
              shortestContained = variation;
            }
          }
          
          // Build the order: shortest contained variation first (if found), then original, then rest sorted by length
          const variations = [];
          
          // Add shortest contained variation first (e.g., "Check" for "Personal Check")
          if (shortestContained && shortestContained.toLowerCase() !== normalized) {
            variations.push(shortestContained);
          }
          
          // Add original payment method
          variations.push(paymentMethod);
          
          // Add all other variations, excluding the ones already added
          const otherVariations = [];
          for (const variation of allGroupVariations) {
            const variationLower = variation.toLowerCase();
            if (variationLower !== normalized && 
                variation !== shortestContained) {
              otherVariations.push(variation);
            }
          }
          
          // Sort remaining variations: shorter first, then longer
          otherVariations.sort((a, b) => {
            if (a.length !== b.length) {
              return a.length - b.length;
            }
            return a.localeCompare(b);
          });
          
          // Add sorted variations after original
          variations.push(...otherVariations);
          
          // Remove duplicates while preserving order
          const uniqueVariations = [...new Set(variations)];
          console.log(`üîç [${stepIndex}] [PAYMENT VARIATIONS] For "${paymentMethod}", will try in order:`, uniqueVariations);
          return uniqueVariations;
        }
      }
      
      // If no mapping found, just return original
      return [paymentMethod];
    }
    
    // Process each payment method with verification
    for (let i = 0; i < paymentMethods.length; i++) {
      const originalPaymentMethod = paymentMethods[i].trim();
      
      console.log(`üîç [${stepIndex}] Processing payment method ${i + 1}/${paymentMethods.length}: "${originalPaymentMethod}"`);
      
      // First check if this payment method (or any of its variations) already exists
      const variationsToCheck = getAllVariationsToTry(originalPaymentMethod);
      let alreadyExists = false;
      let existingVariation = null;
      
      for (const variation of variationsToCheck) {
        if (paymentMethodAlreadyExists(variation)) {
          alreadyExists = true;
          existingVariation = variation;
          console.log(`‚úÖ [${stepIndex}] Payment method "${originalPaymentMethod}" already exists as "${variation}" in textbox, skipping`);
          filledCount++;
          break; // Skip this payment method, move to next
        }
      }
      
      if (alreadyExists) {
        continue; // Skip to next payment method
      }
      
      // Get all variations to try (original first, then shorter variations, then longer ones)
      const variationsToTry = getAllVariationsToTry(originalPaymentMethod);
      
      console.log(`üîç [${stepIndex}] [FILL ORDER] Will try ${variationsToTry.length} variation(s) in this exact order:`);
      variationsToTry.forEach((v, idx) => {
        const marker = idx === 0 ? 'üëâ' : '  ';
        console.log(`   ${marker} ${idx + 1}. "${v}"`);
      });
      
      let success = false;
      let finalPaymentMethod = null;
      
      // Try each variation in order until one succeeds
      for (let attemptIndex = 0; attemptIndex < variationsToTry.length; attemptIndex++) {
        const variationToTry = variationsToTry[attemptIndex];
        const isOriginal = (variationToTry.toLowerCase() === originalPaymentMethod.toLowerCase());
        const attemptLabel = isOriginal 
          ? `[Attempt ${attemptIndex + 1}/${variationsToTry.length}] Original: "${variationToTry}"`
          : `[Attempt ${attemptIndex + 1}/${variationsToTry.length}] Variation: "${variationToTry}"`;
        
        console.log(`\nüîÑ [${stepIndex}] ${attemptLabel}`);
        console.log(`   üìù Trying to fill: "${variationToTry}"`);
        
        success = await tryPaymentMethod(variationToTry, attemptLabel);
        
        if (success) {
          finalPaymentMethod = variationToTry;
          if (isOriginal) {
            console.log(`‚úÖ [${stepIndex}] ‚úÖ SUCCESS: Original payment method "${variationToTry}" was accepted`);
          } else {
            console.log(`‚úÖ [${stepIndex}] ‚úÖ SUCCESS: Variation "${variationToTry}" was accepted (original was: "${originalPaymentMethod}")`);
          }
          // Immediately break and move to next payment method - don't try other variations
          break;
        } else {
          console.log(`‚ùå [${stepIndex}] ‚ùå FAILED: Variation "${variationToTry}" was NOT accepted - will try next variation...`);
          // Add a small delay before trying next variation
          await delay(300);
        }
      }
      
      if (success && finalPaymentMethod) {
        filledCount++;
        // Success! Move immediately to next payment method (already broken out of loop)
        continue;
      } else {
        // Final retry with original payment method only if all variations failed
        console.log(`üîÑ [${stepIndex}] All variations failed. Final retry with original payment method: "${originalPaymentMethod}"`);
        success = await tryPaymentMethod(originalPaymentMethod, `[Final Retry]`);
        if (success) {
          filledCount++;
          finalPaymentMethod = originalPaymentMethod;
        } else {
          console.error(`‚ùå [${stepIndex}] Failed to enter payment method "${originalPaymentMethod}" after trying all ${variationsToTry.length} variation(s)`);
        }
      }
    }
    
    // After filling all payment methods, continue pressing Enter until no more data can be entered
    console.log(`üîç [${stepIndex}] Pressing Enter to clear remaining field content...`);
    let previousValue = getFieldValue();
    let enterPressCount = 0;
    const maxEnterPresses = 10; // Safety limit to prevent infinite loop
    
    while (enterPressCount < maxEnterPresses) {
      await pressEnter();
      const currentValue = getFieldValue();
      
      // Check if field is empty or value hasn't changed (indicating no more data to clear)
      if (!currentValue || currentValue.trim().length === 0) {
        console.log(`‚úÖ [${stepIndex}] Field is now empty after ${enterPressCount + 1} Enter press(es)`);
        break;
      }
      
      // If value hasn't changed, it means Enter didn't do anything (no more data to clear)
      if (currentValue === previousValue) {
        console.log(`‚úÖ [${stepIndex}] Field value unchanged after Enter press - no more data to clear`);
        break;
      }
      
      previousValue = currentValue;
      enterPressCount++;
    }
    
    if (enterPressCount >= maxEnterPresses) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Reached maximum Enter presses (${maxEnterPresses}) - stopping`);
    }
    
    console.log(`‚úÖ [${stepIndex}] Successfully filled ${filledCount} payment methods`);
    return filledCount;
  }
  
  // Helper function for findAndTickCheckbox mode - Enhanced for maximum robustness across different sites
  async function handleFindAndTickCheckbox(paymentMethods, selector, stepIndex, getPaymentMethodVariations, matchesExactLabel, matchesLabelContains) {
    console.log(`üîç [${stepIndex}] findAndTickCheckbox mode: Looking for ${paymentMethods.length} payment method checkboxes`);
    
    let tickedCount = 0;
    
    // Scope checkbox search to container if selector is provided, otherwise search entire page
    let checkboxes;
    let searchContainer = null;
    
    if (selector) {
      searchContainer = document.querySelector(selector);
      if (searchContainer) {
        console.log(`üîç [${stepIndex}] Scoping checkbox search to container: ${selector}`);
        checkboxes = searchContainer.querySelectorAll('input[type="checkbox"]');
      } else {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Selector provided but container not found: ${selector}. Searching entire page instead.`);
        checkboxes = document.querySelectorAll('input[type="checkbox"]');
      }
    } else {
      console.log(`üîç [${stepIndex}] No selector provided, searching entire page for checkboxes`);
      checkboxes = document.querySelectorAll('input[type="checkbox"]');
    }
    
      // Comprehensive function to extract all possible label text from a checkbox
      // Returns labels prioritized by specificity (most specific first)
      function extractLabelText(checkbox) {
        const labelTextsWithPriority = []; // Array of {text, priority} objects
        
        // Priority levels (lower number = higher priority):
        // 1 = Direct label association (label[for], parent label, immediate siblings)
        // 2 = Close proximity (text nodes, nearby siblings)
        // 3 = Same container (parent text, table cell, list item)
        // 4 = Wider context (grandparent, container elements)
        
        // Strategy 1: Find label using 'for' attribute (Priority 1)
        if (checkbox.id) {
          const labelByFor = document.querySelector(`label[for="${checkbox.id}"]`);
          if (labelByFor) {
            if (!searchContainer || searchContainer.contains(labelByFor)) {
              const text = labelByFor.textContent?.trim();
              if (text && text.length > 0 && text.length < 100) {
                labelTextsWithPriority.push({ text, priority: 1 });
              }
            }
          }
        }
        
        // Strategy 2: Check if checkbox is inside a label element (Priority 1)
        let parentLabel = checkbox.parentElement;
        let depth = 0;
        const maxParent = searchContainer || document.body;
        while (parentLabel && parentLabel !== maxParent && depth < 10) {
          if (parentLabel.tagName === 'LABEL') {
            const text = parentLabel.textContent?.trim();
            if (text && text.length > 0 && text.length < 100) {
              labelTextsWithPriority.push({ text, priority: 1 });
            }
            break;
          }
          parentLabel = parentLabel.parentElement;
          depth++;
        }
        
        // Strategy 3: PRIORITIZE immediate sibling HTML elements (Priority 1)
        const parent = checkbox.parentElement;
        if (parent) {
          const siblings = Array.from(parent.children);
          const checkboxIndex = siblings.indexOf(checkbox);
          const priorityTags = ['span', 'div', 'label', 'p', 'strong', 'em', 'b', 'i', 'a'];
          
          // Check immediate sibling after checkbox (most common pattern: <input><span>Visa</span>)
          if (checkboxIndex < siblings.length - 1) {
            const nextSibling = siblings[checkboxIndex + 1];
            if (nextSibling && nextSibling.nodeType === 1) {
              const tagName = nextSibling.tagName?.toLowerCase();
              if (priorityTags.includes(tagName)) {
                const text = nextSibling.textContent?.trim();
                if (text && text.length > 0 && text.length < 100) {
                  labelTextsWithPriority.push({ text, priority: 1 });
                }
              }
            }
          }
          
          // Check immediate sibling before checkbox (pattern: <span>Visa</span><input>)
          if (checkboxIndex > 0) {
            const prevSibling = siblings[checkboxIndex - 1];
            if (prevSibling && prevSibling.nodeType === 1) {
              const tagName = prevSibling.tagName?.toLowerCase();
              if (priorityTags.includes(tagName)) {
                const text = prevSibling.textContent?.trim();
                if (text && text.length > 0 && text.length < 100) {
                  labelTextsWithPriority.push({ text, priority: 1 });
                }
              }
            }
          }
        
          // Check nearby siblings (Priority 2)
          for (let i = checkboxIndex - 1; i >= 0 && i >= checkboxIndex - 3; i--) {
            const sibling = siblings[i];
            if (sibling && sibling.nodeType === 1) {
              const text = sibling.textContent?.trim();
              if (text && text.length > 0 && text.length < 100) {
                labelTextsWithPriority.push({ text, priority: 2 });
              }
            }
          }
          
          for (let i = checkboxIndex + 1; i < siblings.length && i <= checkboxIndex + 3; i++) {
            const sibling = siblings[i];
            if (sibling && sibling.nodeType === 1) {
              const text = sibling.textContent?.trim();
              if (text && text.length > 0 && text.length < 100) {
                labelTextsWithPriority.push({ text, priority: 2 });
              }
            }
          }
          
          // Strategy 4: Look for adjacent text nodes (Priority 2)
          const allNodes = Array.from(parent.childNodes);
          const checkboxNodeIndex = allNodes.indexOf(checkbox);
          
          if (checkboxNodeIndex > 0) {
            const prevNode = allNodes[checkboxNodeIndex - 1];
            if (prevNode && prevNode.nodeType === 3) {
              const text = prevNode.textContent?.trim();
              if (text && text.length > 0 && text.length < 100) {
                labelTextsWithPriority.push({ text, priority: 2 });
              }
            }
          }
          
          if (checkboxNodeIndex < allNodes.length - 1) {
            const nextNode = allNodes[checkboxNodeIndex + 1];
            if (nextNode && nextNode.nodeType === 3) {
              const text = nextNode.textContent?.trim();
              if (text && text.length > 0 && text.length < 100) {
                labelTextsWithPriority.push({ text, priority: 2 });
              }
            }
          }
          
          // Strategy 5: Look for text in nested elements within parent (Priority 3)
          // For table cells, only get text from the specific cell, not the whole row
          const tableCell = checkbox.closest('td, th');
          if (tableCell && tableCell === parent) {
            // Checkbox is directly in a table cell - get text from this cell only
            const clone = tableCell.cloneNode(true);
            const cloneCheckbox = clone.querySelector(`input[type="checkbox"][id="${checkbox.id}"]`);
            if (cloneCheckbox) {
              cloneCheckbox.remove();
            }
            const cellText = clone.textContent?.trim();
            if (cellText && cellText.length > 0 && cellText.length < 100) {
              labelTextsWithPriority.push({ text: cellText, priority: 3 });
            }
          } else {
            // Not in a table cell, look for shorter text elements in parent
            const textElements = parent.querySelectorAll('span, div, p, label, strong, em, b, i, a');
            for (const el of textElements) {
              if (el.contains(checkbox)) continue;
              const text = el.textContent?.trim();
              if (text && text.length > 0 && text.length < 50) {
                labelTextsWithPriority.push({ text, priority: 3 });
              }
            }
          }
        }
        
        // Strategy 6: Look in table cells (td/th) if checkbox is in a table (Priority 3)
        const tableCell = checkbox.closest('td, th');
        if (tableCell && (!parent || tableCell !== parent)) {
          if (!searchContainer || searchContainer.contains(tableCell)) {
            // Get text from this specific cell only, exclude checkbox
            const clone = tableCell.cloneNode(true);
            const cloneCheckbox = clone.querySelector(`input[type="checkbox"][id="${checkbox.id}"]`);
            if (cloneCheckbox) {
              cloneCheckbox.remove();
            }
            const cellText = clone.textContent?.trim();
            if (cellText && cellText.length > 0 && cellText.length < 100) {
              labelTextsWithPriority.push({ text: cellText, priority: 3 });
            }
          }
        }
        
        // Strategy 7: Look in list items (li) if checkbox is in a list (Priority 3)
        const listItem = checkbox.closest('li');
        if (listItem && (!parent || listItem !== parent)) {
          if (!searchContainer || searchContainer.contains(listItem)) {
            const clone = listItem.cloneNode(true);
            const cloneCheckbox = clone.querySelector(`input[type="checkbox"][id="${checkbox.id}"]`);
            if (cloneCheckbox) {
              cloneCheckbox.remove();
            }
            const itemText = clone.textContent?.trim();
            if (itemText && itemText.length > 0 && itemText.length < 100) {
              labelTextsWithPriority.push({ text: itemText, priority: 3 });
            }
          }
        }
        
        // Strategy 8: Get text from parent container (Priority 4 - lowest priority)
        if (parent) {
          const clone = parent.cloneNode(true);
          const cloneCheckbox = clone.querySelector(`input[type="checkbox"][id="${checkbox.id}"]`);
          if (cloneCheckbox) {
            cloneCheckbox.remove();
          }
          const allText = clone.textContent?.trim();
          if (allText && allText.length > 0 && allText.length < 150) {
            labelTextsWithPriority.push({ text: allText, priority: 4 });
          }
        }
        
        // Remove duplicates, sort by priority (lower number = higher priority), then by length (shorter = more specific)
        const uniqueTexts = new Map();
        for (const { text, priority } of labelTextsWithPriority) {
          if (!text || text.length === 0) continue;
          const normalized = text.toLowerCase().trim();
          if (!uniqueTexts.has(normalized) || uniqueTexts.get(normalized).priority > priority) {
            uniqueTexts.set(normalized, { text, priority });
          }
        }
        
        // Sort by priority first, then by length
        const sorted = Array.from(uniqueTexts.values()).sort((a, b) => {
          if (a.priority !== b.priority) {
            return a.priority - b.priority; // Lower priority number = higher priority
          }
          return a.text.length - b.text.length; // Shorter = more specific
        });
        
        return sorted.map(item => item.text);
      }
    
    // Process each payment method individually
    for (const paymentMethod of paymentMethods) {
      const paymentMethodVariations = getPaymentMethodVariations(paymentMethod);
      console.log(`üîç [${stepIndex}] [PAYMENT METHOD] Processing "${paymentMethod}" with variations:`, paymentMethodVariations);
      
      let foundForThisMethod = false;
    
      for (const checkbox of checkboxes) {
        // Skip if already checked
        if (checkbox.checked) {
          continue;
        }
        
        // Extract all possible label texts
        const labelTexts = extractLabelText(checkbox);
        
        // Also check all checkbox attributes
        const checkboxAttributes = {
          id: checkbox.id || '',
          name: checkbox.name || '',
          value: checkbox.value || '',
          'data-name': checkbox.getAttribute('data-name') || '',
          'data-value': checkbox.getAttribute('data-value') || '',
          'data-label': checkbox.getAttribute('data-label') || '',
          'data-text': checkbox.getAttribute('data-text') || '',
          'aria-label': checkbox.getAttribute('aria-label') || '',
          'aria-labelledby': checkbox.getAttribute('aria-labelledby') || '',
          title: checkbox.getAttribute('title') || '',
          placeholder: checkbox.getAttribute('placeholder') || '',
          class: checkbox.className || ''
        };
        
        // If aria-labelledby exists, get text from that element
        if (checkboxAttributes['aria-labelledby']) {
          const labelledBy = document.getElementById(checkboxAttributes['aria-labelledby']);
          if (labelledBy) {
            // If we have a container, prefer elements within it, but still accept elements outside
            if (!searchContainer || searchContainer.contains(labelledBy)) {
              const text = labelledBy.textContent?.trim();
              if (text) labelTexts.push(text);
            }
          }
        }
        
        // Normalize all texts for comparison
        const allTextsToCheck = [
          ...labelTexts,
          ...Object.values(checkboxAttributes).filter(v => v && typeof v === 'string')
        ];
        
        // Check if checkbox is in a payment-related section (optional, not strict)
        let isInPaymentSection = true; // Default to true for maximum compatibility
        let paymentSectionScore = 0;
        let currentElement = checkbox;
        let depth = 0;
        
        while (currentElement && currentElement !== document.body && depth < 15) {
          const elementText = (currentElement.textContent || '').toLowerCase();
          const elementClass = (currentElement.className || '').toLowerCase();
          const elementId = (currentElement.id || '').toLowerCase();
          const elementTag = currentElement.tagName?.toLowerCase() || '';
          
          // Payment-related keywords
          const paymentKeywords = ['payment', 'pay', 'method', 'cash', 'card', 'credit', 'debit', 'visa', 'mastercard', 'amex', 'check', 'cheque'];
          const hasPaymentKeyword = paymentKeywords.some(keyword => 
            elementText.includes(keyword) || 
            elementClass.includes(keyword) || 
            elementId.includes(keyword)
          );
          
          if (hasPaymentKeyword) {
            paymentSectionScore++;
          }
          
          // If we find strong payment indicators, mark as payment section
          if (elementText.includes('payment method') || elementClass.includes('payment-method') || elementId.includes('payment-method')) {
            isInPaymentSection = true;
            break;
          }
          
          currentElement = currentElement.parentElement;
          depth++;
        }
        
        // If no payment indicators found at all, still process (for maximum compatibility)
        // But prefer checkboxes with at least some payment-related context
        const shouldProcess = isInPaymentSection || paymentSectionScore === 0; // Process all if no payment context found (might be a different site structure)
        
        if (!shouldProcess && paymentSectionScore === 0) {
          // Only skip if we're very confident it's NOT a payment section
          // For maximum robustness, we'll still check it
        }
        
        // Try to match payment method with all extracted texts and attributes
        let matchesPaymentMethod = false;
        let matchedText = '';
        let matchReason = '';
        
        // CRITICAL: Only match against PRIMARY label (the most specific one) to prevent false matches
        // This prevents false matches when extraction finds multiple payment methods in the same container
        // The primary label (first in sorted array) is the most specific and should be the actual checkbox label
        const primaryLabel = labelTexts[0] || ''; // The most specific label
        
        // CRITICAL CHECK: Reject labels that start with negative prefixes (e.g., "No Visa", "Not Accepted", etc.)
        if (primaryLabel) {
          const normalizedPrimaryLower = primaryLabel.toLowerCase().trim();
          const negativePrefixes = ['no ', 'not ', 'without ', 'exclude ', 'except ', 'non-', 'un'];
          const hasNegativePrefix = negativePrefixes.some(prefix => normalizedPrimaryLower.startsWith(prefix));
          
          if (hasNegativePrefix) {
            console.log(`üö´ [${stepIndex}] [REJECTED] Label "${primaryLabel}" starts with negative prefix, skipping match`);
            continue; // Skip this checkbox entirely
          }
        }
        
        // STRICT MATCHING: If primary label contains ANY payment method keyword, ONLY match against primary label
        // This ensures we match the actual checkbox label, not labels from nearby checkboxes
        if (primaryLabel) {
          const normalizedPrimary = primaryLabel.toLowerCase();
          const paymentKeywords = ['check', 'cheque', 'cash', 'card', 'visa', 'mastercard', 'amex', 'discover', 'debit', 'credit', 'invoice', 'financing', 'atm', 'diners', 'paypal', 'interac', 'jcb', 'unionpay'];
          
          // Check if primary label contains any payment method keywords
          const primaryHasPaymentKeywords = paymentKeywords.some(keyword => {
            const keywordRegex = new RegExp(`\\b${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
            return keywordRegex.test(normalizedPrimary);
          });
          
          // If primary label contains payment keywords, ONLY match against primary label (strict)
          if (primaryHasPaymentKeywords) {
            // Try exact match first (highest confidence)
            if (matchesExactLabel(primaryLabel, paymentMethodVariations)) {
              matchesPaymentMethod = true;
              matchedText = primaryLabel;
              matchReason = 'exact primary label match';
            }
            // Try contains match with word boundaries (medium confidence) - only for primary label
            else if (matchesLabelContains(primaryLabel, paymentMethodVariations)) {
              matchesPaymentMethod = true;
              matchedText = primaryLabel;
              matchReason = 'contains match (word boundary) on primary label';
            }
            // If primary label has payment keywords but doesn't match, don't check secondary labels
            // This prevents matching "American Express" when primary label is "Paypal"
          } else {
            // Primary label doesn't contain payment keywords, might be a false extraction
            // Still try to match, but be more cautious - only exact matches
            if (matchesExactLabel(primaryLabel, paymentMethodVariations)) {
              matchesPaymentMethod = true;
              matchedText = primaryLabel;
              matchReason = 'exact match (primary label, no payment keywords)';
            }
          }
        }
        
        // ONLY check secondary labels if primary label doesn't contain ANY payment keywords
        // This prevents false matches when primary label is a different payment method
        if (!matchesPaymentMethod && labelTexts.length > 1 && primaryLabel) {
          const normalizedPrimary = primaryLabel.toLowerCase();
          const paymentKeywords = ['check', 'cheque', 'cash', 'card', 'visa', 'mastercard', 'amex', 'discover', 'debit', 'credit', 'invoice', 'financing', 'atm', 'diners', 'paypal', 'interac', 'jcb', 'unionpay'];
          
          // Check if primary label contains ANY payment method keywords
          const primaryHasAnyPaymentKeywords = paymentKeywords.some(keyword => {
            const keywordRegex = new RegExp(`\\b${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
            return keywordRegex.test(normalizedPrimary);
          });
          
          // Only check secondary labels if primary label has NO payment keywords at all
          if (!primaryHasAnyPaymentKeywords) {
            const secondaryLabels = labelTexts.slice(1, 3); // Check next 2 labels
            for (const labelText of secondaryLabels) {
              if (!labelText) continue;
              
              // Only exact matches from secondary labels
              if (matchesExactLabel(labelText, paymentMethodVariations)) {
                matchesPaymentMethod = true;
                matchedText = labelText;
                matchReason = 'exact secondary label match (primary has no payment keywords)';
                break;
              }
            }
          }
        }
        
        // Debug logging to help identify false matches
        if (matchesPaymentMethod) {
          console.log(`üîç [${stepIndex}] [MATCH DEBUG] Payment method "${paymentMethod}" (variations: ${JSON.stringify(paymentMethodVariations)}) matched label text: "${matchedText}" (reason: ${matchReason})`);
          console.log(`üîç [${stepIndex}] [MATCH DEBUG] All label texts for this checkbox:`, labelTexts);
        } else {
          // Log when a payment method doesn't match to help debug false positives
          if (labelTexts.length > 0 && paymentMethodVariations.length > 0) {
            console.log(`üîç [${stepIndex}] [NO MATCH] Payment method "${paymentMethod}" (variations: ${JSON.stringify(paymentMethodVariations)}) did NOT match label texts:`, labelTexts);
          }
        }
        
        // If label doesn't match, check all attributes (with strict word boundary matching)
        if (!matchesPaymentMethod) {
          for (const variation of paymentMethodVariations) {
            const normalizedVariation = variation.toLowerCase().trim();
            
            for (const [attrName, attrValue] of Object.entries(checkboxAttributes)) {
              if (!attrValue) continue;
              
              const normalizedAttr = attrValue.toLowerCase().trim();
              
              // CRITICAL: Reject attributes that start with negative prefixes
              const negativePrefixes = ['no ', 'not ', 'without ', 'exclude ', 'except ', 'non-', 'un'];
              const hasNegativePrefix = negativePrefixes.some(prefix => normalizedAttr.startsWith(prefix));
              if (hasNegativePrefix) {
                continue; // Skip this attribute
              }
              
              // Exact match (highest confidence for attributes)
              if (normalizedAttr === normalizedVariation) {
                matchesPaymentMethod = true;
                matchedText = `${attrName}: ${attrValue}`;
                matchReason = `exact ${attrName} match`;
                break;
              }
              
              // For single-word payment methods, use strict word boundary matching
              // This prevents "Cash" from matching "Personal Check" in attributes
              if (!normalizedVariation.includes(' ') && !normalizedVariation.includes('/')) {
                // Use word boundary regex to ensure exact word match
                const wordBoundaryRegex = new RegExp(`\\b${normalizedVariation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                if (wordBoundaryRegex.test(normalizedAttr)) {
                  // Additional validation: ensure it's not a partial match
                  const matchIndex = normalizedAttr.indexOf(normalizedVariation);
                  if (matchIndex !== -1) {
                    const beforeChar = matchIndex > 0 ? normalizedAttr[matchIndex - 1] : ' ';
                    const afterChar = matchIndex + normalizedVariation.length < normalizedAttr.length 
                      ? normalizedAttr[matchIndex + normalizedVariation.length] 
                      : ' ';
                    const isWordBoundaryBefore = !/\w/.test(beforeChar);
                    const isWordBoundaryAfter = !/\w/.test(afterChar);
                    
                    if (isWordBoundaryBefore && isWordBoundaryAfter) {
                      matchesPaymentMethod = true;
                      matchedText = `${attrName}: ${attrValue}`;
                      matchReason = `word boundary ${attrName} match`;
                      break;
                    }
                  }
                }
              } else {
                // For multi-word payment methods, check if all words are present
                const parts = normalizedVariation.split(/[\/\s]+/).filter(p => p.length > 0);
                if (parts.length > 1) {
                  const allPartsMatch = parts.every(part => {
                    const partRegex = new RegExp(`\\b${part.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                    return partRegex.test(normalizedAttr);
                  });
                  if (allPartsMatch) {
                    matchesPaymentMethod = true;
                    matchedText = `${attrName}: ${attrValue}`;
                    matchReason = `multi-word ${attrName} match`;
                    break;
                  }
                }
              }
            }
            
            if (matchesPaymentMethod) break;
          }
        }
        
        // Additional safety check: prevent false matches by validating the matched text
        if (matchesPaymentMethod) {
          // CRITICAL CHECK: If primary label contains conflicting payment method keywords, reject the match
          // This prevents "Cash" from matching when the checkbox is actually for "Personal Check"
          if (primaryLabel && matchedText !== primaryLabel) {
            const normalizedPrimary = primaryLabel.toLowerCase();
            const normalizedPaymentMethod = paymentMethod.toLowerCase();
            const paymentKeywords = ['check', 'cheque', 'cash', 'card', 'visa', 'mastercard', 'amex', 'discover', 'debit', 'credit', 'invoice', 'financing', 'atm', 'diners', 'paypal', 'interac', 'jcb', 'unionpay'];
            
            // Check if primary label contains payment method keywords other than the one we're matching
            const primaryHasOtherKeywords = paymentKeywords.some(keyword => {
              if (keyword === normalizedPaymentMethod) return false; // Don't conflict with itself
              const keywordRegex = new RegExp(`\\b${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
              return keywordRegex.test(normalizedPrimary);
            });
            
            // If primary label has other payment keywords and the matched text is not exactly the payment method, reject
            if (primaryHasOtherKeywords) {
              const normalizedMatched = matchedText.toLowerCase();
              const exactMatch = normalizedMatched === normalizedPaymentMethod;
              
              if (!exactMatch) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] [MATCH REJECTED] Primary label "${primaryLabel}" contains other payment keywords, rejecting match with "${matchedText}"`);
                matchesPaymentMethod = false;
                matchedText = '';
                matchReason = '';
              }
            }
          }
          
          // For single-word payment methods, ensure the matched text doesn't contain other payment method words
          // This prevents "Cash" from matching "Personal Check" or "Check" from matching "Cashier's Check"
          const normalizedVariation = paymentMethod.toLowerCase().trim();
          if (!normalizedVariation.includes(' ') && !normalizedVariation.includes('/')) {
            // List of other payment method keywords that shouldn't appear in the match
            const conflictingKeywords = ['check', 'cheque', 'cash', 'card', 'visa', 'mastercard', 'amex', 'discover', 'debit', 'credit', 'invoice', 'financing'];
            const normalizedMatchedText = matchedText.toLowerCase();
            
            // Check if matched text contains conflicting keywords as standalone words
            const conflictingWords = conflictingKeywords.filter(keyword => {
              if (keyword === normalizedVariation) return false; // Don't conflict with itself
              // Check if the conflicting keyword appears as a standalone word (not part of another word)
              const keywordRegex = new RegExp(`\\b${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
              return keywordRegex.test(normalizedMatchedText);
            });
            
            // If we found conflicting keywords, verify the match is still valid
            if (conflictingWords.length > 0) {
              // Check if the matched text is exactly the payment method or contains it as a standalone word
              const exactMatch = normalizedMatchedText.trim() === normalizedVariation;
              const wordBoundaryMatch = new RegExp(`\\b${normalizedVariation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i').test(normalizedMatchedText);
              
              // CRITICAL: If the payment method is "cash" and matched text contains "check" or "cheque", reject it
              // This explicitly prevents "Cash" from matching "Personal Check"
              if (normalizedVariation === 'cash' && (conflictingWords.includes('check') || conflictingWords.includes('cheque'))) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] [MATCH REJECTED] Explicitly rejected: Payment method "Cash" cannot match "${matchedText}" (contains check/cheque)`);
                matchesPaymentMethod = false;
                matchedText = '';
                matchReason = '';
              }
              // Only allow if it's an exact match or word boundary match
              // If there are conflicting words and it's not an exact/word-boundary match, reject it
              else if (!exactMatch && !wordBoundaryMatch) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] [MATCH REJECTED] Rejected false match: "${matchedText}" contains conflicting keywords: ${conflictingWords.join(', ')}`);
                matchesPaymentMethod = false;
                matchedText = '';
                matchReason = '';
              }
            }
          }
        }
      
        if (matchesPaymentMethod && !checkbox.checked) {
          checkbox.checked = true;
          checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          checkbox.dispatchEvent(new Event('click', { bubbles: true }));
          checkbox.style.border = "2px solid #4CAF50";
          console.log(`‚úÖ [${stepIndex}] Ticked payment method checkbox: "${matchedText || labelTexts[0] || 'Unknown'}" (matches "${paymentMethod}", reason: ${matchReason || 'attribute match'})`);
          tickedCount++;
          foundForThisMethod = true;
        } else if (matchesPaymentMethod && checkbox.checked) {
          // Already checked, but log for debugging
          console.log(`‚ÑπÔ∏è [${stepIndex}] Payment method checkbox already checked: "${matchedText || labelTexts[0] || 'Unknown'}" (matches "${paymentMethod}")`);
        }
      }
      
      if (!foundForThisMethod) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] [PAYMENT METHOD] Could not find checkbox for "${paymentMethod}"`);
      }
    }
    
    console.log(`üéØ [${stepIndex}] Total payment method checkboxes ticked: ${tickedCount}`);
    return tickedCount;
  }

  async function handleFindAndClickButton(paymentMethods, selector, stepIndex, getPaymentMethodVariations, matchesExactLabel, matchesLabelContains) {
    console.log(`üîç [${stepIndex}] findAndClickButton mode: Looking for ${paymentMethods.length} payment method buttons`);

    let clickedCount = 0;

    const searchContainer = selector ? document.querySelector(selector) : document;
    if (selector && !searchContainer) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Selector provided but container not found: ${selector}. Searching entire page instead.`);
    }

    const container = searchContainer || document;
    const buttons = Array.from(container.querySelectorAll('button, [role="button"]'));
    if (buttons.length === 0) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] No buttons found for payment methods`);
      return 0;
    }

    const getButtonText = (button) => {
      const ariaLabel = button.getAttribute('aria-label');
      const title = button.getAttribute('title');
      const text = button.textContent;
      return (ariaLabel || title || text || '').trim();
    };

    const isButtonSelected = (button) => {
      const ariaPressed = button.getAttribute('aria-pressed');
      if (ariaPressed && ariaPressed.toLowerCase() === 'true') return true;
      const className = button.className || '';
      if (typeof className === 'string' && className.toLowerCase().includes('selected')) return true;
      if (button.querySelector('i[class*="tick"], i[class*="check"], i[class*="checked"]')) return true;
      return false;
    };

    for (const paymentMethod of paymentMethods) {
      const paymentMethodVariations = getPaymentMethodVariations(paymentMethod);
      let matchedButton = null;

      for (const button of buttons) {
        const labelText = getButtonText(button);
        if (!labelText) continue;
        if (matchesExactLabel(labelText, paymentMethodVariations) || matchesLabelContains(labelText, paymentMethodVariations)) {
          matchedButton = button;
          break;
        }
      }

      if (!matchedButton) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] No matching button found for payment method: "${paymentMethod}"`);
        continue;
      }

      if (isButtonSelected(matchedButton)) {
        console.log(`‚ÑπÔ∏è [${stepIndex}] Button already selected for: "${paymentMethod}"`);
        continue;
      }

      try {
        console.log(`‚úÖ [${stepIndex}] Clicking payment method button: "${paymentMethod}"`);
        if (typeof simulateMouseClick === 'function') {
          await simulateMouseClick(matchedButton);
        } else {
          matchedButton.click();
        }
        clickedCount++;
        await delay(150);
      } catch (error) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Failed clicking payment method button "${paymentMethod}":`, error);
      }
    }

    console.log(`‚úÖ [${stepIndex}] Total payment method buttons clicked: ${clickedCount}`);
    return clickedCount;
  }
  
  // Helper function for fillAndAddTextbox mode
  async function handleFillAndAddTextbox(paymentMethods, selector, stepIndex, mapPaymentMethodForFill) {
    if (!selector) {
      console.error(`‚ùå [${stepIndex}] fillAndAddTextbox mode requires a selector`);
      return 0;
    }
    
    console.log(`üîç [${stepIndex}] fillAndAddTextbox mode: Adding and filling ${paymentMethods.length} payment methods`);
    
    // Try to find the "add field" button - common patterns
    const addButtonSelectors = [
      'button[class*="add"]',
      'button[class*="Add"]',
      'button[id*="add"]',
      'button[id*="Add"]',
      'a[class*="add"]',
      'a[class*="Add"]',
      'button:contains("Add")',
      'button:contains("add")',
      '[data-action="add"]',
      '[data-action="Add"]'
    ];
    
    let addButton = null;
    for (const btnSelector of addButtonSelectors) {
      try {
        const buttons = Array.from(document.querySelectorAll('button, a'));
        addButton = buttons.find(btn => {
          const text = btn.textContent?.toLowerCase() || '';
          const className = btn.className?.toLowerCase() || '';
          const id = btn.id?.toLowerCase() || '';
          return text.includes('add') || className.includes('add') || id.includes('add');
        });
        if (addButton) break;
      } catch (e) {
        // Continue to next selector
      }
    }
    
    if (!addButton) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Could not find "add field" button. Trying to use selector directly for textbox.`);
    }
    
    let filledCount = 0;
    for (let i = 0; i < paymentMethods.length; i++) {
      const originalPaymentMethod = paymentMethods[i];
      // Apply payment method mapping (e.g., Mastercard ‚Üí Master Card, American Express ‚Üí AMEX)
      const paymentMethod = mapPaymentMethodForFill(originalPaymentMethod);
      
      if (paymentMethod !== originalPaymentMethod) {
        console.log(`üîÑ [${stepIndex}] Mapped payment method: "${originalPaymentMethod}" ‚Üí "${paymentMethod}"`);
      }
      
      console.log(`üîç [${stepIndex}] Processing payment method ${i + 1}/${paymentMethods.length}: "${paymentMethod}"`);
      
      // Click add button if it exists and not the first item
      if (addButton && i > 0) {
        addButton.click();
        await delay(300); // Wait for new field to appear
      }
      
      // Find the target textbox (could be the last one if multiple exist)
      let targetElement = document.querySelector(selector);
      
      // If multiple elements match, get the last one (newly added)
      const allMatches = document.querySelectorAll(selector);
      if (allMatches.length > 1) {
        targetElement = allMatches[allMatches.length - 1];
      }
      
      if (!targetElement) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Target element not found for selector: ${selector} (attempt ${i + 1})`);
        continue;
      }
      
      // Fill the textbox
      targetElement.focus();
      if (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA') {
        targetElement.value = paymentMethod;
        targetElement.dispatchEvent(new Event('input', { bubbles: true }));
        targetElement.dispatchEvent(new Event('change', { bubbles: true }));
      } else {
        targetElement.textContent = paymentMethod;
        targetElement.dispatchEvent(new Event('input', { bubbles: true }));
      }
      
      filledCount++;
      await delay(200); // Small delay between fills
    }
    
    console.log(`‚úÖ [${stepIndex}] Successfully filled ${filledCount} payment methods in textboxes`);
    return filledCount;
  }

  async function tickSubcategoryCheckboxes() {
    console.log("üîç Looking for subcategory checkboxes...");
    const { CampaignData = {} } = await chrome.storage.local.get(["CampaignData"]);
    const nestedCampaign = Object.values(CampaignData)[0];
    const currentDomain = extractBaseDomain(window.location.hostname);
    let citations = nestedCampaign?.campaignData?.citations || nestedCampaign?.citations;
    
    console.log("üîç [SUBCATEGORY DEBUG] Citations data structure:");
    console.log("   ‚Ä¢ Full CampaignData:", CampaignData);
    console.log("   ‚Ä¢ Nested campaign:", nestedCampaign);
    console.log("   ‚Ä¢ Citations:", citations);
    console.log("   ‚Ä¢ Citations type:", Array.isArray(citations) ? 'array' : typeof citations);
    let subcategory = null;
    if (Array.isArray(citations)) {
      const matchingCitation = citations.find(citation => citation.site === currentDomain);
      if (matchingCitation) {
        subcategory = matchingCitation.subCategory || matchingCitation.subcategory;
        console.log(`‚úÖ Found matching citation for ${currentDomain}:`, matchingCitation);
      } else {
        console.warn(`‚ö†Ô∏è No citation found for domain: ${currentDomain}`);
      }
    } else if (citations && typeof citations === 'object') {
      subcategory = citations.subCategory || citations.subcategory;
    }
    if (!subcategory) {
      console.warn("‚ö†Ô∏è No subcategory found in campaign data for this domain");
      return 0;
    }
    console.log(`üéØ Looking for subcategory: "${subcategory}"`);
    let tickedCount = 0;
    const containers = document.querySelectorAll('ul.list-of-sub-categories');
    let checkboxes = [];
    containers.forEach(container => {
      checkboxes = checkboxes.concat(Array.from(container.querySelectorAll('input[type="checkbox"]')));
    });
    if (checkboxes.length === 0) {
      console.warn("‚ö†Ô∏è No subcategory checkboxes found in any container");
      return 0;
    }
    checkboxes.forEach(checkbox => {
      let labelText = '';
      const label = checkbox.closest('label');
      if (label) labelText = label.textContent.trim();
      const dataName = checkbox.getAttribute('data-name');
      const dataValue = checkbox.getAttribute('data-value');
      const checkboxValue = checkbox.value;
      
      // Get all possible text values to match against
      const allTextValues = [
        labelText,
        dataName,
        dataValue,
        checkboxValue
      ].filter(v => v && v.trim().length > 0);
      
      // Normalize subcategory for matching
      const normalizedSubcategory = subcategory.toLowerCase().trim();
      
      // Check for exact or close match
      const matches = allTextValues.some(textValue => {
        const normalizedText = textValue.toLowerCase().trim();
        
        // Exact match
        if (normalizedText === normalizedSubcategory) {
          return true;
        }
        
        // Handle comma-separated subcategories (e.g., if subcategory is "Cell Phone Repair, Mobile Repair")
        const subcategoryParts = normalizedSubcategory.split(',').map(s => s.trim()).filter(s => s.length > 0);
        if (subcategoryParts.length > 1) {
          // If subcategory has multiple values, check if any part matches
          return subcategoryParts.some(part => normalizedText === part || normalizedText.includes(part));
        }
        
        // Check if the checkbox text is contained in the subcategory or vice versa (but be strict)
        // Only match if one contains the other and they're reasonably similar in length
        const lengthRatio = Math.min(normalizedText.length, normalizedSubcategory.length) / Math.max(normalizedText.length, normalizedSubcategory.length);
        if (lengthRatio > 0.7) { // At least 70% length similarity
          return normalizedText.includes(normalizedSubcategory) || normalizedSubcategory.includes(normalizedText);
        }
        
        return false;
      });
      
      if (matches && !checkbox.checked) {
        checkbox.checked = true;
        checkbox.dispatchEvent(new Event('change', { bubbles: true }));
        checkbox.dispatchEvent(new Event('click', { bubbles: true }));
        checkbox.style.border = "2px solid #4CAF50";
        console.log(`‚úÖ Ticked subcategory checkbox: "${labelText || dataName || 'Unknown'}" (matches "${subcategory}")`);
        tickedCount++;
      }
    });
    console.log(`üéØ Total subcategory checkboxes ticked: ${tickedCount}`);
    return tickedCount;
  }

  function tickCheckboxesByText(container, searchValue, stepIndex) {
    const raw = String(searchValue || '').trim();
    if (!raw) {
      return { success: false, error: 'No search value provided for checkbox selection' };
    }

    const desiredValues = raw
      .split(/[,;\n]/)
      .map(v => v.trim())
      .filter(v => v.length > 0);

    if (desiredValues.length === 0) {
      return { success: false, error: 'No valid search values after parsing' };
    }

    const normalize = (val) => String(val || '').toLowerCase().trim();
    const normalizeLoose = (val) => String(val || '').toLowerCase().replace(/[^a-z0-9]/g, '');

    const getCheckboxTextCandidates = (checkbox) => {
      const label = checkbox.closest('label');
      const labelText = label ? label.textContent.trim() : '';
      const dataName = checkbox.getAttribute('data-name') || '';
      const dataValue = checkbox.getAttribute('data-value') || '';
      const checkboxValue = checkbox.value || '';
      const ariaLabel = checkbox.getAttribute('aria-label') || '';
      return [labelText, dataName, dataValue, checkboxValue, ariaLabel].filter(v => v && v.trim().length > 0);
    };

    const matchesText = (candidate, target) => {
      const normalizedCandidate = normalize(candidate);
      const normalizedTarget = normalize(target);

      if (!normalizedCandidate || !normalizedTarget) return false;

      if (normalizedCandidate === normalizedTarget) return true;

      const candidateLoose = normalizeLoose(candidate);
      const targetLoose = normalizeLoose(target);
      if (candidateLoose && targetLoose && (candidateLoose.includes(targetLoose) || targetLoose.includes(candidateLoose))) {
        return true;
      }

      const lengthRatio = Math.min(normalizedCandidate.length, normalizedTarget.length) /
        Math.max(normalizedCandidate.length, normalizedTarget.length);
      if (lengthRatio > 0.7) {
        return normalizedCandidate.includes(normalizedTarget) || normalizedTarget.includes(normalizedCandidate);
      }

      return false;
    };

    const checkboxes = [];
    if (container && container.tagName === 'INPUT' && container.type === 'checkbox') {
      checkboxes.push(container);
    } else if (container) {
      checkboxes.push(...Array.from(container.querySelectorAll('input[type="checkbox"]')));
    }

    if (checkboxes.length === 0) {
      return { success: false, error: 'No checkboxes found in container' };
    }

    let tickedCount = 0;
    let matchedCount = 0;

    desiredValues.forEach((desired) => {
      let matchedCheckbox = null;
      for (const checkbox of checkboxes) {
        const candidates = getCheckboxTextCandidates(checkbox);
        const hasMatch = candidates.some(candidate => matchesText(candidate, desired));
        if (hasMatch) {
          matchedCheckbox = checkbox;
          break;
        }
      }

      if (matchedCheckbox) {
        matchedCount++;
        if (!matchedCheckbox.checked) {
          matchedCheckbox.checked = true;
          matchedCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
          matchedCheckbox.dispatchEvent(new Event('click', { bubbles: true }));
          tickedCount++;
        }
        console.log(`‚úÖ [${stepIndex}] Ticked checkbox for "${desired}"`);
      } else {
        console.warn(`‚ö†Ô∏è [${stepIndex}] No checkbox match found for "${desired}"`);
      }
    });

    if (matchedCount === 0) {
      return { success: false, error: `No matching checkbox found for "${raw}"` };
    }

    return { success: true, tickedCount, matchedCount };
  }

  // Generate consolidated content for textarea with HTML support detection
  async function generateConsolidatedContentForTextarea(useHtml = false) {
    console.log(`üîç Generating consolidated content for textarea (HTML: ${useHtml})...`);
    
    try {
      // Get campaign data from Chrome storage (same way as automation)
      const result = await chrome.storage.local.get(["CampaignData"]);
      console.log("üîç [DEBUG] Full storage result:", result);
      
      let campaignData = result.CampaignData || {};
      console.log("üîç [DEBUG] CampaignData keys:", Object.keys(campaignData));
      console.log("üîç [DEBUG] CampaignData values:", campaignData);
      
      // If CampaignData is empty, try to get it from background script
      if (!campaignData || Object.keys(campaignData).length === 0) {
        console.log("üîç [DEBUG] CampaignData is empty in storage, requesting from background script...");
        
        const response = await new Promise((resolve) => {
          chrome.runtime.sendMessage({ 
            type: "FETCH_CAMPAIGN_DATA"
          }, (response) => {
            if (chrome.runtime.lastError) {
              console.error("‚ùå Chrome runtime error:", chrome.runtime.lastError.message);
              resolve({ error: chrome.runtime.lastError.message });
            } else {
              resolve(response);
            }
          });
        });
        
        if (response && response.CampaignData) {
          console.log("üîç [DEBUG] Got CampaignData from background script:", response.CampaignData);
          campaignData = response.CampaignData;
        } else {
          console.warn("‚ö†Ô∏è No CampaignData available from background script either");
          console.warn("‚ö†Ô∏è Background response:", response);
        }
      }
      
      // Check if we have the nested structure or direct structure
      let nestedCampaign;
      if (Object.keys(campaignData).length > 0) {
        // Check if campaignData has a 'campaignData' property (nested structure)
        if (campaignData.campaignData) {
          nestedCampaign = campaignData;
          console.log("üîç [DEBUG] Using nested structure");
        } else {
          // Direct structure - wrap it
          nestedCampaign = { campaignData: campaignData };
          console.log("üîç [DEBUG] Using direct structure, wrapped");
        }
      } else {
        console.warn("‚ö†Ô∏è No campaign data found in storage");
        return "";
      }
      
      console.log("üîç [DEBUG] Nested campaign:", nestedCampaign);
      
      // Get domain configuration from IndexedDB (consolidationSetup collection)
      const domain = extractBaseDomain(window.location.hostname);
      let domainConfig = await getDomainConfig(domain);
      
      if (!domainConfig || Object.keys(domainConfig).length === 0) {
        console.warn(`‚ö†Ô∏è No configuration found for domain: ${domain} in both IndexedDB and local file`);
        console.log("üîÑ Using minimal fallback configuration (only Description)...");
        
        // Minimal fallback: Only show description if no configuration is found
        domainConfig = {
          "Description": "TRUE"
        };
        
        console.log("üîÑ Using minimal fallback configuration:", domainConfig);
      }
      
      console.log(`üéØ Consolidating data for domain: ${domain}`);
      console.log("üîç [DEBUG] Domain config keys:", Object.keys(domainConfig));
      console.log("üîç [DEBUG] Domain config values:", domainConfig);
      
      // Create itemvalue object with all the data
      let itemvalue = {
        address: nestedCampaign.campaignData.addressBox || "",
        website: nestedCampaign.campaignData.websiteBox || "",
        description: nestedCampaign.campaignData.longDescriptionBox || "",
        service1: nestedCampaign.campaignData.service1Box || "",
        service2: nestedCampaign.campaignData.service2Box || "",
        service3: nestedCampaign.campaignData.service3Box || "",
        service4: nestedCampaign.campaignData.service4Box || "",
        service5: nestedCampaign.campaignData.service5Box || "",
        services: nestedCampaign.campaignData.servicesBox || "",
        numemployee: nestedCampaign.campaignData.employeesBox || "",
        yearestab: nestedCampaign.campaignData.yearFormationBox || "",
        payment: nestedCampaign.campaignData.paymentMethodsBox || "",
        hours: nestedCampaign.campaignData.businessHoursBox || "",
        telephone: nestedCampaign.campaignData.contactTelephoneBox || "",
        mobile: nestedCampaign.campaignData.mobileNumberBox || "",
        fax: nestedCampaign.campaignData.faxNumberBox || "",
        email: nestedCampaign.campaignData.contactEmailBox || "",
        facebook: nestedCampaign.campaignData.facebookBox || "",
        twitter: nestedCampaign.campaignData.twitterBox || "",
        linkedin: nestedCampaign.campaignData.linkedinBox || "",
        pinterest: nestedCampaign.campaignData.pinterestBox || "",
        instagram: nestedCampaign.campaignData.instagramBox || "",
        tiktok: nestedCampaign.campaignData.tiktokBox || "",
        youtube: nestedCampaign.campaignData.youtubeBox || "",
        businessName: nestedCampaign.campaignData.businessNameBox || "",
        category: nestedCampaign.campaignData.categoryBox || ""
      };

      // Apply simple fallback mechanism for submission data
      itemvalue = applySubmissionDataFallbacks(itemvalue, nestedCampaign);
      
      console.log("üîç [DEBUG] Starting content building...");
      console.log("üîç [DEBUG] Domain config Address:", domainConfig.Address);
      console.log("üîç [DEBUG] Itemvalue address:", itemvalue.address);
      
      // Build the consolidated content
      let formattedContent = "";
      
      // Helper function to format business hours with proper indentation per day
      const formatBusinessHoursContent = (hours) => {
        if (!hours || hours.trim() === "") return "";
        
        // First, check if hours already have line breaks (detailed format from formatBusinessHoursFromData)
        const lines = hours.split(/\n/).filter(line => line.trim() !== "");
        
        if (lines.length > 1) {
          // Already has line breaks - format each line with proper indentation
          const formattedLines = lines.map(line => {
            // Check if line starts with day abbreviation
            const dayMatch = line.match(/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun):\s*(.+)$/i);
            if (dayMatch) {
              const day = dayMatch[1];
              const time = dayMatch[2].trim();
              if (useHtml) {
                return `${day}:&nbsp;&nbsp;&nbsp;${time}`;
              } else {
                return `${day}:   ${time}`;
              }
            }
            return line;
          });
          return formattedLines.join(useHtml ? '<br/>' : '\n');
        }
        
        // Single line format - try to parse it
        // Use a simpler approach - find all day patterns and extract text between them
        const allDays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
        const dayIndices = [];
        allDays.forEach(day => {
          const index = hours.indexOf(day + ':');
          if (index !== -1) {
            dayIndices.push({ day, index });
          }
        });
        
        // Sort by index
        dayIndices.sort((a, b) => a.index - b.index);
        
        if (dayIndices.length > 0) {
          const matches = [];
          for (let i = 0; i < dayIndices.length; i++) {
            const current = dayIndices[i];
            const next = dayIndices[i + 1];
            const startIndex = current.index + current.day.length + 1; // +1 for colon
            const endIndex = next ? next.index : hours.length;
            const time = hours.substring(startIndex, endIndex).trim();
            if (time && time.length > 0) {
              matches.push({ day: current.day, time });
            }
          }
          
          if (matches.length > 0) {
            if (useHtml) {
              return matches.map(m => `${m.day}:&nbsp;&nbsp;&nbsp;${m.time}`).join('<br/>');
            } else {
              return matches.map(m => `${m.day}:   ${m.time}`).join('\n');
            }
          }
        }
        
        // Fallback: return original with minimal formatting
        return hours;
      };
      
      // Helper function to format labels with proper alignment and HTML support
      const formatLabel = (label, key) => {
        // Handle field names with colons (e.g., "Number of Employees:")
        const fieldKey = key.includes(":") ? key : `${key}:`;
        if (domainConfig[fieldKey] !== "TRUE") return "";
        
        // Map configuration keys to itemvalue keys
        const keyMapping = {
          "Contact Telephone": "telephone",
          "Contact Email": "email", 
          "Mobile Number": "mobile",
          "Fax Number": "fax",
          "Number of Employees": "numemployee",
          "Date of Company Formation": "yearestab",
          "Payment Method": "payment",
          "Business Hours": "hours"
        };
        
        const dataKey = keyMapping[key] || key.toLowerCase();
        const value = itemvalue[dataKey];
        
        if (!value || value.trim() === "") return "";
        
        // Special handling for Business Hours
        if (key === "Business Hours") {
          const formattedHours = formatBusinessHoursContent(value);
          if (!formattedHours) return "";
          
          if (useHtml) {
            return `<strong>${label}:</strong><br/>${formattedHours}<br/><br/>`;
          } else {
            return `${label}:\n${formattedHours}\n\n`;
          }
        }
        
        // Helper function to make URLs clickable
        const makeClickable = (text) => {
          if (!useHtml) return text;
          
          // URL regex pattern
          const urlRegex = /(https?:\/\/[^\s]+)/g;
          return text.replace(urlRegex, '<a href="$1" target="_blank">$1</a>');
        };
        
        if (useHtml) {
          return `<strong>${label}:</strong><br/>${makeClickable(value)}<br/><br/>`;
        } else {
          return `${label}:\n${value}\n\n`;
        }
      };
      
      // Normalize social media values for domain-specific rules
      const normalizeSocialMediaValue = (key, value) => {
        if (!value) return value;
        if (domain === "akama.com" && key.toLowerCase() === "twitter") {
          return value.replace(/x\.com/gi, "twitter.com");
        }
        return value;
      };

      // Helper function to format social media links
      const formatSocialMedia = () => {
        const socialMediaFields = ["Facebook", "Twitter", "LinkedIn", "Pinterest", "Instagram", "Tiktok", "Youtube"];
        
        // Collect social media items that have both configuration and data
        const socialMediaItems = [];
        socialMediaFields.forEach(key => {
          const lowercaseKey = key.toLowerCase();
          const normalizedValue = normalizeSocialMediaValue(key, itemvalue[lowercaseKey]);
          if (domainConfig[key] === "TRUE" && normalizedValue && normalizedValue.trim() !== "") {
            socialMediaItems.push({ key, value: normalizedValue });
          }
        });
        
        // Only show header if there are actual items
        if (socialMediaItems.length === 0) return "";
        
        let content = useHtml ? "<strong>Social Media Profiles:</strong><br/>" : "Social Media Profiles:\n";
        
        socialMediaItems.forEach(item => {
          if (useHtml) {
            const clickableValue = item.value.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>');
            content += `${clickableValue}<br/>`;
          } else {
            content += `${item.value}\n`;
          }
        });
        
        return content + (useHtml ? "<br/>" : "\n");
      };
      
      // Format address
      if (domainConfig.Address === "TRUE" && itemvalue.address) {
        if (useHtml) {
          formattedContent += `<strong>Address:</strong><br/>${itemvalue.address}<br/><br/>`;
        } else {
          formattedContent += `Address:\n${itemvalue.address}\n\n`;
        }
      }
      
      // Format website
      if (domainConfig.Website === "TRUE" && itemvalue.website) {
        if (useHtml) {
          const clickableWebsite = itemvalue.website.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>');
          formattedContent += `<strong>Website:</strong><br/>${clickableWebsite}<br/><br/>`;
        } else {
          formattedContent += `Website:\n${itemvalue.website}\n\n`;
        }
      }
      
      // Format description
      if (domainConfig.Description === "TRUE" && itemvalue.description) {
        if (useHtml) {
          formattedContent += `<strong>Description:</strong><br/>${itemvalue.description}<br/><br/>`;
        } else {
          formattedContent += `Description:\n${itemvalue.description}\n\n`;
        }
      }
      
      // Format services
      if (domainConfig["List of Services"] === "TRUE" && (itemvalue.service1 || itemvalue.service2 || itemvalue.service3 || itemvalue.service4 || itemvalue.service5)) {
        // Collect all services into an array
        const servicesList = [
          itemvalue.service1,
          itemvalue.service2,
          itemvalue.service3,
          itemvalue.service4,
          itemvalue.service5
        ].filter(s => s && s.trim() !== "");
        
        // Determine label based on number of services
        const label = servicesList.length === 1 ? "Service" : "List of Services";
        
        if (useHtml) {
          formattedContent += `<strong>${label}:</strong><br/>`;
          servicesList.forEach(service => {
            formattedContent += `${service}<br/>`;
          });
          formattedContent += "<br/>";
        } else {
          formattedContent += `${label}:\n`;
          servicesList.forEach(service => {
            formattedContent += `${service}\n`;
          });
          formattedContent += "\n";
        }
      }
      
      // Format other fields
      formattedContent += formatLabel("Number of Employees", "Number of Employees");
      formattedContent += formatLabel("Date of Company Formation", "Date of Company Formation");
      formattedContent += formatLabel("Payment Method", "Payment Method");
      formattedContent += formatLabel("Business Hours", "Business Hours");
      
      // Contact information section
      const hasContactInfo = 
        (domainConfig["Contact Telephone:"] === "TRUE" && itemvalue.telephone && itemvalue.telephone.trim() !== "") ||
        (domainConfig["Contact Email:"] === "TRUE" && itemvalue.email && itemvalue.email.trim() !== "") ||
        (domainConfig["Mobile Number:"] === "TRUE" && itemvalue.mobile && itemvalue.mobile.trim() !== "") ||
        (domainConfig["Fax Number:"] === "TRUE" && itemvalue.fax && itemvalue.fax.trim() !== "");
        
      if (hasContactInfo) {
        if (useHtml) {
          formattedContent += "<strong>For more information, please contact us with the details below:</strong><br/><br/>";
        } else {
          formattedContent += "For more information, please contact us with the details below:\n\n";
        }
        formattedContent += formatLabel("Contact Telephone", "Contact Telephone");
        formattedContent += formatLabel("Contact Email", "Contact Email");
        formattedContent += formatLabel("Mobile Number", "Mobile Number");
        formattedContent += formatLabel("Fax Number", "Fax Number");
      }
      
      // Social media section
      formattedContent += formatSocialMedia();
      
      console.log("‚úÖ Consolidated content generated successfully");
      console.log("üîç [DEBUG] Generated content length:", formattedContent.length);
      console.log("üîç [DEBUG] Generated content preview:", formattedContent.substring(0, 200));
      
      return formattedContent;
      
    } catch (error) {
      console.error("‚ùå Error generating consolidated content:", error);
      return "";
    }
  }

  // Generate consolidated content without injecting to Froala (for textarea use)
  async function generateConsolidatedContent() {
    console.log("üîç Generating consolidated content for textarea...");
    
    try {
      // Get campaign data from Chrome storage (same way as automation)
      const result = await chrome.storage.local.get(["CampaignData"]);
      console.log("üîç [DEBUG] Full storage result:", result);
      
      let campaignData = result.CampaignData || {};
      console.log("üîç [DEBUG] CampaignData keys:", Object.keys(campaignData));
      console.log("üîç [DEBUG] CampaignData values:", campaignData);
      
      // If CampaignData is empty, try to get it from background script
      if (!campaignData || Object.keys(campaignData).length === 0) {
        console.log("üîç [DEBUG] CampaignData is empty in storage, requesting from background script...");
        
        const response = await new Promise((resolve) => {
          chrome.runtime.sendMessage({ 
            type: "FETCH_CAMPAIGN_DATA"
          }, (response) => {
            if (chrome.runtime.lastError) {
              console.error("‚ùå Chrome runtime error:", chrome.runtime.lastError.message);
              resolve({ error: chrome.runtime.lastError.message });
            } else {
              resolve(response);
            }
          });
        });
        
        if (response && response.CampaignData) {
          console.log("üîç [DEBUG] Got CampaignData from background script:", response.CampaignData);
          campaignData = response.CampaignData;
        } else {
          console.warn("‚ö†Ô∏è No CampaignData available from background script either");
          console.warn("‚ö†Ô∏è Background response:", response);
        }
      }
      
      // Check if we have the nested structure or direct structure
      let nestedCampaign;
      if (Object.keys(campaignData).length > 0) {
        // Check if campaignData has a 'campaignData' property (nested structure)
        if (campaignData.campaignData) {
          nestedCampaign = campaignData;
          console.log("üîç [DEBUG] Using nested structure");
        } else {
          // Direct structure - wrap it
          nestedCampaign = { campaignData: campaignData };
          console.log("üîç [DEBUG] Using direct structure, wrapped");
        }
      } else {
        console.warn("‚ö†Ô∏è No campaign data found in storage");
        return "";
      }
      
      console.log("üîç [DEBUG] Nested campaign:", nestedCampaign);
      
      // Get domain configuration from IndexedDB (consolidationSetup collection)
      const domain = extractBaseDomain(window.location.hostname);
      let domainConfig = await getDomainConfig(domain);
      
      if (!domainConfig || Object.keys(domainConfig).length === 0) {
        console.warn(`‚ö†Ô∏è No configuration found for domain: ${domain} in both IndexedDB and local file`);
        console.log("üîÑ Using minimal fallback configuration (only Description)...");
        
        // Minimal fallback: Only show description if no configuration is found
        domainConfig = {
          "Description": "TRUE"
        };
        
        console.log("üîÑ Using minimal fallback configuration:", domainConfig);
      }
      
      console.log(`üéØ Consolidating data for domain: ${domain}`);
      console.log("üîç [DEBUG] Domain config keys:", Object.keys(domainConfig));
      console.log("üîç [DEBUG] Domain config values:", domainConfig);
      
      // Create itemvalue object with all the data
      let itemvalue = {
        address: nestedCampaign.campaignData.addressBox || "",
        website: nestedCampaign.campaignData.websiteBox || "",
        description: nestedCampaign.campaignData.longDescriptionBox || "",
        service1: nestedCampaign.campaignData.service1Box || "",
        service2: nestedCampaign.campaignData.service2Box || "",
        service3: nestedCampaign.campaignData.service3Box || "",
        service4: nestedCampaign.campaignData.service4Box || "",
        service5: nestedCampaign.campaignData.service5Box || "",
        services: nestedCampaign.campaignData.servicesBox || "",
        numemployee: nestedCampaign.campaignData.employeesBox || "",
        yearestab: nestedCampaign.campaignData.yearFormationBox || "",
        payment: nestedCampaign.campaignData.paymentMethodsBox || "",
        hours: nestedCampaign.campaignData.businessHoursBox || "",
        telephone: nestedCampaign.campaignData.contactTelephoneBox || "",
        mobile: nestedCampaign.campaignData.mobileNumberBox || "",
        fax: nestedCampaign.campaignData.faxNumberBox || "",
        email: nestedCampaign.campaignData.contactEmailBox || "",
        facebook: nestedCampaign.campaignData.facebookBox || "",
        twitter: nestedCampaign.campaignData.twitterBox || "",
        linkedin: nestedCampaign.campaignData.linkedinBox || "",
        pinterest: nestedCampaign.campaignData.pinterestBox || "",
        instagram: nestedCampaign.campaignData.instagramBox || "",
        tiktok: nestedCampaign.campaignData.tiktokBox || "",
        youtube: nestedCampaign.campaignData.youtubeBox || "",
        businessName: nestedCampaign.campaignData.businessNameBox || "",
        category: nestedCampaign.campaignData.categoryBox || ""
      };

      // Apply simple fallback mechanism for submission data
      itemvalue = applySubmissionDataFallbacks(itemvalue, nestedCampaign);
      
      console.log("üîç [DEBUG] Starting content building...");
      console.log("üîç [DEBUG] Domain config Address:", domainConfig.Address);
      console.log("üîç [DEBUG] Itemvalue address:", itemvalue.address);
      
      // Build the consolidated content
      let formattedContent = "";
      
      // Detect if we should use HTML formatting (check if textarea supports it)
      const useHtml = false; // For now, use plain text. Can be enhanced to detect HTML support
      
      // Helper function to format business hours with proper indentation per day
      const formatBusinessHoursContent = (hours) => {
        if (!hours || hours.trim() === "") return "";
        
        // First, check if hours already have line breaks (detailed format from formatBusinessHoursFromData)
        const lines = hours.split(/\n/).filter(line => line.trim() !== "");
        
        if (lines.length > 1) {
          // Already has line breaks - format each line with proper indentation
          const formattedLines = lines.map(line => {
            // Check if line starts with day abbreviation
            const dayMatch = line.match(/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun):\s*(.+)$/i);
            if (dayMatch) {
              const day = dayMatch[1];
              const time = dayMatch[2].trim();
              if (useHtml) {
                return `${day}:&nbsp;&nbsp;&nbsp;${time}`;
              } else {
                return `${day}:   ${time}`;
              }
            }
            return line;
          });
          return formattedLines.join(useHtml ? '<br/>' : '\n');
        }
        
        // Single line format - try to parse it
        // Use a simpler approach - find all day patterns and extract text between them
        const allDays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
        const dayIndices = [];
        allDays.forEach(day => {
          const index = hours.indexOf(day + ':');
          if (index !== -1) {
            dayIndices.push({ day, index });
          }
        });
        
        // Sort by index
        dayIndices.sort((a, b) => a.index - b.index);
        
        if (dayIndices.length > 0) {
          const matches = [];
          for (let i = 0; i < dayIndices.length; i++) {
            const current = dayIndices[i];
            const next = dayIndices[i + 1];
            const startIndex = current.index + current.day.length + 1; // +1 for colon
            const endIndex = next ? next.index : hours.length;
            const time = hours.substring(startIndex, endIndex).trim();
            if (time && time.length > 0) {
              matches.push({ day: current.day, time });
            }
          }
          
          if (matches.length > 0) {
            if (useHtml) {
              return matches.map(m => `${m.day}:&nbsp;&nbsp;&nbsp;${m.time}`).join('<br/>');
            } else {
              return matches.map(m => `${m.day}:   ${m.time}`).join('\n');
            }
          }
        }
        
        // Fallback: return original with minimal formatting
        return hours;
      };
      
      // Helper function to format labels with proper alignment and HTML support
      const formatLabel = (label, key, useHtml = false) => {
        // Handle field names with colons (e.g., "Number of Employees:")
        const fieldKey = key.includes(":") ? key : `${key}:`;
        if (domainConfig[fieldKey] !== "TRUE") return "";
        
        // Map configuration keys to itemvalue keys
        const keyMapping = {
          "Contact Telephone": "telephone",
          "Contact Email": "email", 
          "Mobile Number": "mobile",
          "Fax Number": "fax",
          "Number of Employees": "numemployee",
          "Date of Company Formation": "yearestab",
          "Payment Method": "payment",
          "Business Hours": "hours"
        };
        
        const dataKey = keyMapping[key] || key.toLowerCase();
        const value = itemvalue[dataKey];
        
        if (!value || value.trim() === "") return "";
        
        // Special handling for Business Hours
        if (key === "Business Hours") {
          const formattedHours = formatBusinessHoursContent(value);
          if (!formattedHours) return "";
          
          if (useHtml) {
            return `<strong>${label}:</strong><br/>${formattedHours}<br/><br/>`;
          } else {
            return `${label}:\n${formattedHours}\n\n`;
          }
        }
        
        // Helper function to make URLs clickable
        const makeClickable = (text) => {
          if (!useHtml) return text;
          
          // URL regex pattern
          const urlRegex = /(https?:\/\/[^\s]+)/g;
          return text.replace(urlRegex, '<a href="$1" target="_blank">$1</a>');
        };
        
        if (useHtml) {
          return `<strong>${label}:</strong><br/>${makeClickable(value)}<br/><br/>`;
        } else {
          return `${label}:\n${value}\n\n`;
        }
      };
      
      // Helper function to format social media links
      const formatSocialMedia = (useHtml = false) => {
        const socialMediaFields = ["Facebook", "Twitter", "LinkedIn", "Pinterest", "Instagram", "Tiktok", "Youtube"];
        
        // Collect social media items that have both configuration and data
        const socialMediaItems = [];
        socialMediaFields.forEach(key => {
          const lowercaseKey = key.toLowerCase();
          const normalizedValue = normalizeSocialMediaValue(key, itemvalue[lowercaseKey]);
          if (domainConfig[key] === "TRUE" && normalizedValue && normalizedValue.trim() !== "") {
            socialMediaItems.push({ key, value: normalizedValue });
          }
        });
        
        // Only show header if there are actual items
        if (socialMediaItems.length === 0) return "";
        
        let content = useHtml ? "<strong>Social Media Profiles:</strong><br/>" : "Social Media Profiles:\n";
        
        socialMediaItems.forEach(item => {
          if (useHtml) {
            const clickableValue = item.value.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>');
            content += `${clickableValue}<br/>`;
          } else {
            content += `${item.value}\n`;
          }
        });
        
        return content + (useHtml ? "<br/>" : "\n");
      };
      
      // Format address
      if (domainConfig.Address === "TRUE" && itemvalue.address) {
        if (useHtml) {
          formattedContent += `<strong>Address:</strong><br/>${itemvalue.address}<br/><br/>`;
        } else {
          formattedContent += `Address:\n${itemvalue.address}\n\n`;
        }
      }
      
      // Format website
      if (domainConfig.Website === "TRUE" && itemvalue.website) {
        if (useHtml) {
          const clickableWebsite = itemvalue.website.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>');
          formattedContent += `<strong>Website:</strong><br/>${clickableWebsite}<br/><br/>`;
        } else {
          formattedContent += `Website:\n${itemvalue.website}\n\n`;
        }
      }
      
      // Format description
      if (domainConfig.Description === "TRUE" && itemvalue.description) {
        if (useHtml) {
          formattedContent += `<strong>Description:</strong><br/>${itemvalue.description}<br/><br/>`;
        } else {
          formattedContent += `Description:\n${itemvalue.description}\n\n`;
        }
      }
      
      // Format services
      if (domainConfig["List of Services"] === "TRUE" && (itemvalue.service1 || itemvalue.service2 || itemvalue.service3 || itemvalue.service4 || itemvalue.service5)) {
        // Collect all services into an array
        const servicesList = [
          itemvalue.service1,
          itemvalue.service2,
          itemvalue.service3,
          itemvalue.service4,
          itemvalue.service5
        ].filter(s => s && s.trim() !== "");
        
        // Determine label based on number of services
        const label = servicesList.length === 1 ? "Service" : "List of Services";
        
        if (useHtml) {
          formattedContent += `<strong>${label}:</strong><br/>`;
          servicesList.forEach(service => {
            formattedContent += `${service}<br/>`;
          });
          formattedContent += "<br/>";
        } else {
          formattedContent += `${label}:\n`;
          servicesList.forEach(service => {
            formattedContent += `${service}\n`;
          });
          formattedContent += "\n";
        }
      }
      
      // Format other fields
      formattedContent += formatLabel("Number of Employees", "Number of Employees", useHtml);
      formattedContent += formatLabel("Date of Company Formation", "Date of Company Formation", useHtml);
      formattedContent += formatLabel("Payment Method", "Payment Method", useHtml);
      formattedContent += formatLabel("Business Hours", "Business Hours", useHtml);
      
      // Contact information section
      const hasContactInfo = 
        (domainConfig["Contact Telephone:"] === "TRUE" && itemvalue.telephone && itemvalue.telephone.trim() !== "") ||
        (domainConfig["Contact Email:"] === "TRUE" && itemvalue.email && itemvalue.email.trim() !== "") ||
        (domainConfig["Mobile Number:"] === "TRUE" && itemvalue.mobile && itemvalue.mobile.trim() !== "") ||
        (domainConfig["Fax Number:"] === "TRUE" && itemvalue.fax && itemvalue.fax.trim() !== "");
        
      if (hasContactInfo) {
        if (useHtml) {
          formattedContent += "<strong>For more information, please contact us with the details below:</strong><br/><br/>";
        } else {
          formattedContent += "For more information, please contact us with the details below:\n\n";
        }
        formattedContent += formatLabel("Contact Telephone", "Contact Telephone", useHtml);
        formattedContent += formatLabel("Contact Email", "Contact Email", useHtml);
        formattedContent += formatLabel("Mobile Number", "Mobile Number", useHtml);
        formattedContent += formatLabel("Fax Number", "Fax Number", useHtml);
      }
      
      // Social media section
      formattedContent += formatSocialMedia(useHtml);
      
      console.log("‚úÖ Consolidated content generated successfully");
      console.log("üîç [DEBUG] Generated content length:", formattedContent.length);
      console.log("üîç [DEBUG] Generated content preview:", formattedContent.substring(0, 200));
      
      return formattedContent;
      
    } catch (error) {
      console.error("‚ùå Error generating consolidated content:", error);
      return "";
    }
  }

  // Simple fallback mechanism for submission data - works with step-level alternatives
  function applySubmissionDataFallbacks(itemvalue, nestedCampaign) {
    console.log("üîÑ Applying submission data fallbacks...");
    
    const fallbackData = { ...itemvalue };
    const campaignData = nestedCampaign?.campaignData || {};
    
    // Simple fallback logic - just ensure basic fields have values
    // The main fallback logic is handled in the executeStep function using the 'alternative' parameter
    
    // Special handling for services field - combine multiple service fields
    if (!fallbackData.services || fallbackData.services.trim() === '') {
      const serviceFields = ['service1', 'service2', 'service3', 'service4', 'service5'];
      const availableServices = serviceFields
        .map(field => fallbackData[field])
        .filter(service => service && service.trim() !== '');
      
      if (availableServices.length > 0) {
        fallbackData.services = availableServices.join(', ');
        console.log(`‚úÖ [FALLBACK] Combined services from individual fields: '${fallbackData.services}'`);
      }
    }
    
    // Ensure at least one contact method exists
    const contactFields = ['telephone', 'mobile', 'email'];
    const hasContactInfo = contactFields.some(field => 
      fallbackData[field] && fallbackData[field].trim() !== ''
    );
    
    if (!hasContactInfo && (fallbackData.businessName || fallbackData.category)) {
      // Generate email from business name or category
      const sourceName = fallbackData.businessName || fallbackData.category || 'contact';
      const cleanName = sourceName.toLowerCase().replace(/[^a-z0-9]/g, '');
      fallbackData.email = `${cleanName}@example.com`;
      console.log(`‚úÖ [FALLBACK] Generated email from ${fallbackData.businessName ? 'business name' : 'category'}: '${fallbackData.email}'`);
    }
    
    console.log("‚úÖ [FALLBACK] Basic fallbacks applied successfully");
    return fallbackData;
  }

  async function consolidateData() {
    console.log("üîç Consolidating data from campaignData...");
    
    try {
      // Get campaign data from Chrome storage (same way as automation)
      const result = await chrome.storage.local.get(["CampaignData"]);
      console.log("üîç [DEBUG] Full storage result:", result);
      
      // Debug: Check what's actually in chrome.storage.local
      const allStorage = await chrome.storage.local.get(null);
      console.log("üîç [DEBUG] All storage keys:", Object.keys(allStorage));
      console.log("üîç [DEBUG] All storage data:", allStorage);
      
      // Debug: Check authentication status
      console.log("üîç [DEBUG] Is logged in:", allStorage.isLoggedIn);
      console.log("üîç [DEBUG] CampaignDataStatus:", allStorage.CampaignDataStatus);
      console.log("üîç [DEBUG] User roles:", allStorage.user_roles);
      
      let campaignData = result.CampaignData || {};
      console.log("üîç [DEBUG] CampaignData keys:", Object.keys(campaignData));
      console.log("üîç [DEBUG] CampaignData values:", campaignData);
      
      // If CampaignData is empty, try to get it from background script
      if (!campaignData || Object.keys(campaignData).length === 0) {
        console.log("üîç [DEBUG] CampaignData is empty in storage, requesting from background script...");
        
        const response = await new Promise((resolve) => {
          chrome.runtime.sendMessage({ 
            type: "FETCH_CAMPAIGN_DATA"
          }, (response) => {
            if (chrome.runtime.lastError) {
              console.error("‚ùå Chrome runtime error:", chrome.runtime.lastError.message);
              resolve({ error: chrome.runtime.lastError.message });
            } else {
              resolve(response);
            }
          });
        });
        
        if (response && response.CampaignData) {
          console.log("üîç [DEBUG] Got CampaignData from background script:", response.CampaignData);
          campaignData = response.CampaignData;
        } else {
          console.warn("‚ö†Ô∏è No CampaignData available from background script either");
          console.warn("‚ö†Ô∏è Background response:", response);
        }
      }
      
      // Check if we have the nested structure or direct structure
      let nestedCampaign;
      if (Object.keys(campaignData).length > 0) {
        // Check if campaignData has a 'campaignData' property (nested structure)
        if (campaignData.campaignData) {
          console.log("üîç [DEBUG] Found nested campaignData structure");
          nestedCampaign = campaignData;
        } else {
          // Try to get the first value (nested structure)
          nestedCampaign = Object.values(campaignData)[0];
          console.log("üîç [DEBUG] Nested campaign:", nestedCampaign);
          
          // If nested structure doesn't have campaignData, use the direct structure
          if (!nestedCampaign?.campaignData) {
            console.log("üîç [DEBUG] No nested campaignData found, using direct structure");
            nestedCampaign = { campaignData: campaignData };
          }
        }
      } else {
        console.warn("‚ö†Ô∏è No campaign data found in storage");
        return null;
      }
      
      if (!nestedCampaign?.campaignData) {
        console.warn("‚ö†Ô∏è No campaign data found");
        return null;
      }
      
      // Get domain configuration from IndexedDB (consolidationSetup collection)
      const domain = extractBaseDomain(window.location.hostname);
      let domainConfig = await getDomainConfig(domain);
      
      if (!domainConfig || Object.keys(domainConfig).length === 0) {
        console.warn(`‚ö†Ô∏è No configuration found for domain: ${domain} in both IndexedDB and local file`);
        console.log("üîÑ Using minimal fallback configuration (only Description)...");
        
        // Minimal fallback: Only show description if no configuration is found
        domainConfig = {
          "Description": "TRUE"
        };
        
        console.log("üîÑ Using minimal fallback configuration:", domainConfig);
      }
      
      console.log(`üéØ Consolidating data for domain: ${domain}`);
      console.log("üîç [DEBUG] Domain config keys:", Object.keys(domainConfig));
      console.log("üîç [DEBUG] Domain config values:", domainConfig);
      
      // Extract data from campaignData
      let itemvalue = {
        address: nestedCampaign.campaignData.addressBox || "",
        website: nestedCampaign.campaignData.websiteBox || "",
        description: nestedCampaign.campaignData.longDescriptionBox || "",
        service1: nestedCampaign.campaignData.service1Box || "",
        service2: nestedCampaign.campaignData.service2Box || "",
        service3: nestedCampaign.campaignData.service3Box || "",
        service4: nestedCampaign.campaignData.service4Box || "",
        service5: nestedCampaign.campaignData.service5Box || "",
        services: nestedCampaign.campaignData.servicesBox || "",
        numemployee: nestedCampaign.campaignData.employeesBox || "",
        yearestab: nestedCampaign.campaignData.yearFormationBox || "",
        payment: nestedCampaign.campaignData.paymentMethodsBox || "",
        hours: nestedCampaign.campaignData.businessHoursBox || "",
        telephone: nestedCampaign.campaignData.contactTelephoneBox || "",
        mobile: nestedCampaign.campaignData.mobileNumberBox || "",
        fax: nestedCampaign.campaignData.faxNumberBox || "",
        email: nestedCampaign.campaignData.contactEmailBox || "",
        facebook: nestedCampaign.campaignData.facebookBox || "",
        twitter: nestedCampaign.campaignData.twitterBox || "",
        linkedin: nestedCampaign.campaignData.linkedinBox || "",
        pinterest: nestedCampaign.campaignData.pinterestBox || "",
        instagram: nestedCampaign.campaignData.instagramBox || "",
        tiktok: nestedCampaign.campaignData.tiktokBox || "",
        youtube: nestedCampaign.campaignData.youtubeBox || "",
        city: nestedCampaign.campaignData.city || "",
        state: nestedCampaign.campaignData.state || "",
        zipcode: nestedCampaign.campaignData.zipcode || ""
      };
      
      console.log("üîç [DEBUG] Extracted itemvalue data:");
      console.log("  - Address:", itemvalue.address);
      console.log("  - Website:", itemvalue.website);
      console.log("  - Description:", itemvalue.description ? "Present" : "Empty");
      console.log("  - Hours:", itemvalue.hours ? "Present" : "Empty");
      console.log("  - Telephone:", itemvalue.telephone);
      console.log("  - Email:", itemvalue.email);
      console.log("  - Mobile:", itemvalue.mobile);
      console.log("  - Fax:", itemvalue.fax);
      
      // Check if this is a special site
      const isSpecialSite = ["agreatertown.com", "yenino.com", "bpublic.com", "bizmakersamerica.org", "wegotaguy.net"].includes(domain);
      const removeStrongTags = domain === "bestincom.com";
      const showRawTags = isSpecialSite;
      
      // Helper function to format labels
      const formatLabel = (label, key) => {
        // Handle field names with colons (e.g., "Number of Employees:")
        const fieldKey = key.includes(":") ? key : `${key}:`;
        if (domainConfig[fieldKey] !== "TRUE") return "";
        
        // Map configuration keys to itemvalue keys
        const keyMapping = {
          "Contact Telephone": "telephone",
          "Contact Email": "email", 
          "Mobile Number": "mobile",
          "Fax Number": "fax",
          "Number of Employees": "numemployee",
          "Date of Company Formation": "yearestab",
          "Payment Method": "payment",
          "Business Hours": "hours"
        };
        
        const dataKey = keyMapping[key] || key.toLowerCase();
        const value = itemvalue[dataKey];
        
        if (!value || value.trim() === "") return "";
        
        const labelText = removeStrongTags ? `${label}:<br/>` : `<strong>${label}:</strong><br/>`;
        return showRawTags
          ? `&lt;${removeStrongTags ? "" : "strong"}&gt;${label}:&lt;/${removeStrongTags ? "" : "strong"}&gt;&lt;br/&gt;${value}&lt;br/&gt;&lt;br/&gt;`
          : `${labelText}${value}<br/><br/>`;
      };
      
      // Format website
      const formatWebsite = (website) => {
        if (domainConfig.Website !== "TRUE" || !website) return "";
        return showRawTags
          ? `&lt;${removeStrongTags ? "" : "strong"}&gt;Website:&lt;/${removeStrongTags ? "" : "strong"}&gt;&lt;br/&gt;&lt;a href="${website}" target="_blank"&gt;${website}&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;`
          : `${removeStrongTags ? "Website:<br/>" : "<strong>Website:</strong><br/>"}<a href="${website}" target="_blank">${website}</a><br/><br/>`;
      };
      
      // Format business hours with proper indentation per day
      const formatBusinessHours = (hours) => {
        if (domainConfig["Business Hours:"] !== "TRUE" || !hours || hours.trim() === "") return "";
        
        // Parse the hours string - it might be in format "Mon: 8:00 am - 8:00 pm Tue: 8:00 am - 8:00 pm..."
        // or already formatted with line breaks
        let formattedHours = hours;
        
        // If it's a single line with multiple days, try to split it
        // Pattern: Day abbreviation followed by colon (Mon:, Tue:, etc.)
        const dayPattern = /(Mon|Tue|Wed|Thu|Fri|Sat|Sun):\s*([^\n]+?)(?=(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun):|$)/gi;
        
        // Check if hours contain day patterns
        if (dayPattern.test(hours)) {
          // Reset regex
          dayPattern.lastIndex = 0;
          const matches = [];
          let match;
          
          while ((match = dayPattern.exec(hours)) !== null) {
            const day = match[1];
            const time = match[2].trim();
            matches.push({ day, time });
          }
          
          if (matches.length > 0) {
            // Format each day on its own line with proper indentation
            if (showRawTags) {
              formattedHours = matches.map(m => `${m.day}:&nbsp;&nbsp;&nbsp;${m.time}`).join('&lt;br/&gt;');
            } else {
              formattedHours = matches.map(m => `${m.day}:&nbsp;&nbsp;&nbsp;${m.time}`).join('<br/>');
            }
          }
        } else {
          // If already has line breaks or different format, try to format each line
          const lines = hours.split(/\n/).filter(line => line.trim() !== "");
          if (lines.length > 1) {
            // Format each line with proper indentation
            const formattedLines = lines.map(line => {
              // Check if line starts with day abbreviation
              const dayMatch = line.match(/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun):\s*(.+)$/i);
              if (dayMatch) {
                if (showRawTags) {
                  return `${dayMatch[1]}:&nbsp;&nbsp;&nbsp;${dayMatch[2].trim()}`;
                } else {
                  return `${dayMatch[1]}:&nbsp;&nbsp;&nbsp;${dayMatch[2].trim()}`;
                }
              }
              return line;
            });
            formattedHours = formattedLines.join(showRawTags ? '&lt;br/&gt;' : '<br/>');
          }
        }
        
        return showRawTags
          ? `&lt;${removeStrongTags ? "" : "strong"}&gt;Business Hours:&lt;/${removeStrongTags ? "" : "strong"}&gt;&lt;br/&gt;${formattedHours}&lt;br/&gt;&lt;br/&gt;`
          : `${removeStrongTags ? "Business Hours:<br/>" : "<strong>Business Hours:</strong><br/>"}${formattedHours}<br/><br/>`;
      };
      
      // Format services
      const formatServices = () => {
        let servicesList = [itemvalue.service1, itemvalue.service2, itemvalue.service3, itemvalue.service4, itemvalue.service5].filter(s => s);
        if (domainConfig["List of Services"] !== "TRUE" || servicesList.length === 0) return "";
        const label = servicesList.length === 1 ? "Service" : "List of Services";
        let services = servicesList.join(showRawTags ? "&lt;br/&gt;" : "<br/>");
        return showRawTags
          ? `&lt;${removeStrongTags ? "" : "strong"}&gt;${label}:&lt;/${removeStrongTags ? "" : "strong"}&gt;&lt;br/&gt;${services}&lt;br/&gt;&lt;br/&gt;`
          : `${removeStrongTags ? `${label}:<br/>` : `<strong>${label}:</strong><br/>`}${services}<br/><br/>`;
      };
      
      // Format description
      const formatDescription = () => {
        if (domainConfig.Description !== "TRUE" || !itemvalue.description) return "";
        
        const hasOtherDetails = 
          (domainConfig.Address === "TRUE" && itemvalue.address) ||
          (domainConfig.Website === "TRUE" && itemvalue.website) ||
          (domainConfig["List of Services"] === "TRUE" && itemvalue.service1) ||
          (domainConfig["Contact Telephone:"] === "TRUE" && itemvalue.telephone && itemvalue.telephone.trim() !== "") ||
          (domainConfig["Contact Email:"] === "TRUE" && itemvalue.email && itemvalue.email.trim() !== "") ||
          (domainConfig["Mobile Number:"] === "TRUE" && itemvalue.mobile && itemvalue.mobile.trim() !== "") ||
          (domainConfig["Fax Number:"] === "TRUE" && itemvalue.fax && itemvalue.fax.trim() !== "") ||
          (domainConfig["Number of Employees:"] === "TRUE" && itemvalue.numemployee) ||
          (domainConfig["Date of Company Formation:"] === "TRUE" && itemvalue.yearestab) ||
          (domainConfig["Payment Method"] === "TRUE" && itemvalue.payment) ||
          (domainConfig.Facebook === "TRUE" && itemvalue.facebook) ||
          (domainConfig.Twitter === "TRUE" && itemvalue.twitter) ||
          (domainConfig.LinkedIn === "TRUE" && itemvalue.linkedin) ||
          (domainConfig.Pinterest === "TRUE" && itemvalue.pinterest) ||
          (domainConfig.Instagram === "TRUE" && itemvalue.instagram) ||
          (domainConfig.Tiktok === "TRUE" && itemvalue.tiktok) ||
          (domainConfig.Youtube === "TRUE" && itemvalue.youtube);

        const formatted = itemvalue.description.replace(/\n/g, showRawTags ? "&lt;br/&gt;" : "<br/>");
        return showRawTags
          ? `${hasOtherDetails ? `&lt;${removeStrongTags ? "" : "strong"}&gt;Description:&lt;/${removeStrongTags ? "" : "strong"}&gt;&lt;br/&gt;` : ""}${formatted}&lt;br/&gt;&lt;br/&gt;`
          : `${hasOtherDetails ? (removeStrongTags ? "Description:<br/>" : "<strong>Description:</strong><br/>") : ""}${formatted}<br/><br/>`;
      };
      
      // Build consolidated content
      let formattedContent = "";
      
      console.log("üîç [DEBUG] Starting content building...");
      console.log("üîç [DEBUG] Domain config Address:", domainConfig.Address);
      console.log("üîç [DEBUG] Itemvalue address:", itemvalue.address);
      
      // Address logic (simplified - always show full address)
      if (domainConfig.Address === "TRUE" && itemvalue.address) {
        const addressContent = formatLabel("Address", "address");
        console.log("üîç [DEBUG] Address content:", addressContent);
        formattedContent += addressContent;
      }
      
      const websiteContent = formatWebsite(itemvalue.website);
      console.log("üîç [DEBUG] Website content:", websiteContent);
      formattedContent += websiteContent;
      
      const descriptionContent = formatDescription();
      console.log("üîç [DEBUG] Description content:", descriptionContent);
      formattedContent += descriptionContent;
      
      const servicesContent = formatServices();
      console.log("üîç [DEBUG] Services content:", servicesContent);
      formattedContent += servicesContent;
      
      const employeesContent = formatLabel("Number of Employees", "numemployee");
      console.log("üîç [DEBUG] Employees content:", employeesContent);
      formattedContent += employeesContent;
      
      const formationContent = formatLabel("Date of Company Formation", "yearestab");
      console.log("üîç [DEBUG] Formation content:", formationContent);
      formattedContent += formationContent;
      
      const paymentContent = formatLabel("Payment Method", "payment");
      console.log("üîç [DEBUG] Payment content:", paymentContent);
      formattedContent += paymentContent;
      
      const hoursContent = formatBusinessHours(itemvalue.hours);
      console.log("üîç [DEBUG] Hours content:", hoursContent);
      formattedContent += hoursContent;
      
      // Contact information section
      console.log('[consolidateData] Contact info check:', {
        telephone: { value: itemvalue.telephone, config: domainConfig["Contact Telephone:"] },
        email: { value: itemvalue.email, config: domainConfig["Contact Email:"] },
        mobile: { value: itemvalue.mobile, config: domainConfig["Mobile Number:"] },
        fax: { value: itemvalue.fax, config: domainConfig["Fax Number:"] }
      });
      
      function isValidContact(val) {
        const cleaned = typeof val === "string" ? val.trim().toLowerCase() : "";
        return cleaned && cleaned !== "null" && cleaned !== "undefined";
      }
      
      
      // Debug each contact field individually
      const telephoneValid = domainConfig["Contact Telephone:"] === "TRUE" && isValidContact(itemvalue.telephone);
      const emailValid = domainConfig["Contact Email:"] === "TRUE" && isValidContact(itemvalue.email);
      const mobileValid = domainConfig["Mobile Number:"] === "TRUE" && isValidContact(itemvalue.mobile);
      const faxValid = domainConfig["Fax Number:"] === "TRUE" && isValidContact(itemvalue.fax);
      
      console.log("üîç [DEBUG] Contact field validation:");
      console.log(`  - Contact Telephone: config="${domainConfig["Contact Telephone:"]}", value="${itemvalue.telephone}", valid=${telephoneValid}`);
      console.log(`  - Contact Email: config="${domainConfig["Contact Email:"]}", value="${itemvalue.email}", valid=${emailValid}`);
      console.log(`  - Mobile Number: config="${domainConfig["Mobile Number:"]}", value="${itemvalue.mobile}", valid=${mobileValid}`);
      console.log(`  - Fax Number: config="${domainConfig["Fax Number:"]}", value="${itemvalue.fax}", valid=${faxValid}`);
      
      const hasContactInfo = telephoneValid || emailValid || mobileValid || faxValid;
      console.log(`üîç [DEBUG] hasContactInfo result: ${hasContactInfo}`);
        
      if (hasContactInfo) {
        formattedContent += showRawTags
          ? `&lt;${removeStrongTags ? "" : "strong"}&gt;For more information, please contact us with the details below:&lt;/${removeStrongTags ? "" : "strong"}&gt;&lt;br/&gt;&lt;br/&gt;`
          : `${removeStrongTags ? "For more information, please contact us with the details below:<br/><br/>" : "<strong>For more information, please contact us with the details below:</strong><br/><br/>"}`;
        formattedContent += formatLabel("Contact Telephone", "Contact Telephone");
        formattedContent += formatLabel("Contact Email", "Contact Email");
        formattedContent += formatLabel("Mobile Number", "Mobile Number");
        formattedContent += formatLabel("Fax Number", "Fax Number");
        console.log("‚úÖ [DEBUG] Contact section added to formatted content");
      } else {
        console.log("‚ùå [DEBUG] No contact section added - no valid contact information found");
      }
      
      // Social media section - only show if there's actual data AND configuration
      const normalizeSocialMediaValueForConsolidate = (key, value) => {
        if (!value) return value;
        if (domain === "akama.com" && key.toLowerCase() === "twitter") {
          return value.replace(/x\.com/gi, "twitter.com");
        }
        return value;
      };
      const socialMediaFields = ["Facebook", "Twitter", "LinkedIn", "Pinterest", "Instagram", "Tiktok", "Youtube"];
      const socialMediaItems = [];
      socialMediaFields.forEach(key => {
        const lowercaseKey = key.toLowerCase();
        const normalizedValue = normalizeSocialMediaValueForConsolidate(key, itemvalue[lowercaseKey]);
        if (domainConfig[key] === "TRUE" && normalizedValue && normalizedValue.trim() !== "") {
          socialMediaItems.push({ key, value: normalizedValue });
        }
      });
      
      // Only show header if there are actual items
      if (socialMediaItems.length > 0) {
        formattedContent += showRawTags
          ? `&lt;${removeStrongTags ? "" : "strong"}&gt;Social Media Profiles:&lt;/${removeStrongTags ? "" : "strong"}&gt;&lt;br/&gt;`
          : `${removeStrongTags ? "Social Media Profiles:<br/>" : "<strong>Social Media Profiles:</strong><br/>"}`;
        socialMediaItems.forEach(item => {
          formattedContent += showRawTags
            ? `&lt;a href="${item.value}" target="_blank"&gt;${item.value}&lt;/a&gt;&lt;br/&gt;`
            : `<a href="${item.value}" target="_blank">${item.value}</a><br/>`;
        });
        formattedContent += showRawTags ? "&lt;br/&gt;" : "<br/>";
      }
      
      console.log("‚úÖ Data consolidated successfully");
      console.log("üîç [DEBUG] Generated content length:", formattedContent.length);
      console.log("üîç [DEBUG] Generated content preview:", formattedContent.substring(0, 200) + "...");
      console.log("üîç [DEBUG] Full generated content:", formattedContent);
      return formattedContent;
      
    } catch (error) {
      console.error("‚ùå Error consolidating data:", error);
      return null;
    }
  }

  async function injectConsolidatedDataToFroala() {
    console.log("üîç Injecting consolidated data to rich text editor (detecting all supported editors)...");
    
    try {
      // Get consolidated content
      let consolidatedContent = await consolidateData();
      
      // Fallback: If no consolidated content, try to get just the description
      if (!consolidatedContent) {
        console.warn("‚ö†Ô∏è No consolidated content available, attempting to inject description only...");
        
        try {
          // Get campaign data from Chrome storage
          const result = await chrome.storage.local.get(["CampaignData"]);
          let campaignData = result.CampaignData || {};
          
          // If CampaignData is empty, try to get it from background script
          if (!campaignData || Object.keys(campaignData).length === 0) {
            const response = await new Promise((resolve) => {
              chrome.runtime.sendMessage({ 
                type: "FETCH_CAMPAIGN_DATA"
              }, (response) => {
                if (chrome.runtime.lastError) {
                  resolve({ error: chrome.runtime.lastError.message });
                } else {
                  resolve(response);
                }
              });
            });
            
            if (response && response.CampaignData) {
              campaignData = response.CampaignData;
            }
          }
          
          // Check if we have the nested structure or direct structure
          let nestedCampaign;
          if (Object.keys(campaignData).length > 0) {
            if (campaignData.campaignData) {
              nestedCampaign = campaignData;
            } else {
              nestedCampaign = Object.values(campaignData)[0];
              if (!nestedCampaign?.campaignData) {
                nestedCampaign = { campaignData: campaignData };
              }
            }
          }
          
          // Get description from descriptionBox or longDescriptionBox
          if (nestedCampaign?.campaignData) {
            const description = nestedCampaign.campaignData.descriptionBox || 
                               nestedCampaign.campaignData.longDescriptionBox || 
                               "";
            
            if (description && description.trim() !== "") {
              // Format description with line breaks
              consolidatedContent = description.replace(/\n/g, "<br/>");
              console.log("‚úÖ Found description, will inject description only");
            } else {
              console.warn("‚ö†Ô∏è No description found in CampaignData");
              return false;
            }
          } else {
            console.warn("‚ö†Ô∏è No CampaignData found");
            return false;
          }
        } catch (error) {
          console.error("‚ùå Error getting description fallback:", error);
          return false;
        }
      }
      
      let editor = null;
      let editorType = null;
      let editorMetadata = {}; // Store additional info like iframe, instance, etc.
      
      // Comprehensive editor detection - try all supported editors
      
      // 1. Try Froala editor
      if (!editor) {
        const froalaSelector = ".fr-element[contenteditable='true']";
        editor = document.querySelector(froalaSelector);
        if (editor) {
          editorType = 'froala';
          console.log("‚úÖ Found Froala editor");
        }
      }
      
      // 2. Try TinyMCE
      if (!editor) {
        // TinyMCE uses iframes with id="tinymce" or class="mceContentBody"
        const tinyMCEIframes = document.querySelectorAll('iframe[id*="tinymce"], iframe[class*="tinymce"]');
        for (const iframe of tinyMCEIframes) {
          try {
            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
            const iframeBody = iframeDoc.body;
            if (iframeBody && (iframeBody.id === 'tinymce' || iframeBody.classList.contains('mceContentBody'))) {
              editor = iframeBody;
              editorType = 'tinymce';
              editorMetadata.iframe = iframe;
              console.log("‚úÖ Found TinyMCE editor via iframe");
              break;
            }
          } catch (e) {
            console.warn("‚ö†Ô∏è Could not access TinyMCE iframe:", e);
          }
        }
        
        // Also check for direct TinyMCE body
        if (!editor) {
          const tinyMCEDirect = document.querySelector('#tinymce.mceContentBody, body#tinymce, body.mceContentBody');
          if (tinyMCEDirect) {
            editor = tinyMCEDirect;
            editorType = 'tinymce';
            console.log("‚úÖ Found TinyMCE editor (direct)");
          }
        }
      }
      
      // 3. Try Quill editor
      if (!editor) {
        const quillSelectors = [
          ".ql-editor[contenteditable='true']",
          "[contenteditable='true'].ql-editor",
          ".ql-container .ql-editor",
          ".quill .ql-editor"
        ];
        for (const selector of quillSelectors) {
          editor = document.querySelector(selector);
          if (editor) {
            editorType = 'quill';
            console.log(`‚úÖ Found Quill editor using selector: ${selector}`);
            break;
          }
        }
      }
      
      // 4. Try Summernote
      if (!editor) {
        const summernoteSelectors = [
          ".note-editable[contenteditable='true']",
          "[contenteditable='true'].note-editable",
          ".summernote[contenteditable='true']"
        ];
        for (const selector of summernoteSelectors) {
          editor = document.querySelector(selector);
          if (editor) {
            editorType = 'summernote';
            console.log(`‚úÖ Found Summernote editor using selector: ${selector}`);
            break;
          }
        }
      }
      
      // 5. Try CKEditor 5 (newer version)
      if (!editor) {
        const ckeditor5Selectors = [
          ".ck-editor__editable[contenteditable='true']",
          ".ck-content[contenteditable='true']",
          ".ck.ck-editor__editable[contenteditable='true']",
          "[contenteditable='true'].ck-editor__editable",
          "[contenteditable='true'].ck-content"
        ];
        for (const selector of ckeditor5Selectors) {
          editor = document.querySelector(selector);
          if (editor) {
            editorType = 'ckeditor5';
            console.log(`‚úÖ Found CKEditor 5 editor using selector: ${selector}`);
            break;
          }
        }
        
        // Pattern matching for CKEditor 5
        if (!editor) {
          const allEditable = document.querySelectorAll('[contenteditable="true"]');
          for (const elem of allEditable) {
            if (elem.closest('.ck-editor') || 
                elem.classList.contains('ck-editor__editable') || 
                elem.classList.contains('ck-content') ||
                elem.closest('[class*="ck-editor"]')) {
              editor = elem;
              editorType = 'ckeditor5';
              console.log("‚úÖ Found CKEditor 5 editor via pattern matching");
              break;
            }
          }
        }
      }
      
      // 6. Try CKEditor 4, 3, 1, 0 (older versions - all use similar structure)
      if (!editor) {
        // CKEditor 4/3/1/0 use iframes with class "cke_wysiwyg_frame" or similar
        const ckeditorIframeSelectors = [
          "iframe.cke_wysiwyg_frame",
          "iframe[class*='cke_wysiwyg']",
          "iframe[class*='cke_']"
        ];
        
        for (const iframeSelector of ckeditorIframeSelectors) {
          const ckeditorIframe = document.querySelector(iframeSelector);
          if (ckeditorIframe) {
            try {
              const iframeDoc = ckeditorIframe.contentDocument || ckeditorIframe.contentWindow.document;
              const iframeBody = iframeDoc.body;
              if (iframeBody && (iframeBody.classList.contains('cke_editable') || 
                                 iframeBody.classList.contains('cke_contents_ltr') ||
                                 iframeBody.classList.contains('cke_contents_rtl'))) {
                editor = iframeBody;
                editorType = 'ckeditor'; // Generic for all CKEditor versions
                editorMetadata.iframe = ckeditorIframe;
                console.log(`‚úÖ Found CKEditor editor (version 0-4) via iframe: ${iframeSelector}`);
                break;
              }
            } catch (e) {
              console.warn(`‚ö†Ô∏è Could not access CKEditor iframe content (${iframeSelector}):`, e);
            }
          }
        }
        
        // Direct CKEditor editable elements (versions 0-4)
        if (!editor) {
          const ckeditorSelectors = [
            ".cke_editable[contenteditable='true']",
            "body.cke_editable[contenteditable='true']",
            "[contenteditable='true'].cke_editable",
            ".cke_contents_ltr[contenteditable='true']",
            ".cke_contents_rtl[contenteditable='true']",
            ".cke_editor [contenteditable='true']"
          ];
          
          for (const selector of ckeditorSelectors) {
            editor = document.querySelector(selector);
            if (editor) {
              editorType = 'ckeditor';
              console.log(`‚úÖ Found CKEditor editor (version 0-4) using selector: ${selector}`);
              break;
            }
          }
        }
        
        // Pattern matching for CKEditor (versions 0-4)
        if (!editor) {
          const allEditable = document.querySelectorAll('[contenteditable="true"]');
          for (const elem of allEditable) {
            if (elem.classList.contains('cke_editable') || 
                elem.classList.contains('cke_contents_ltr') ||
                elem.classList.contains('cke_contents_rtl') ||
                elem.closest('.cke_editor') ||
                elem.closest('[class*="cke_"]')) {
              editor = elem;
              editorType = 'ckeditor';
              console.log("‚úÖ Found CKEditor editor (version 0-4) via pattern matching");
              break;
            }
          }
        }
      }
      
      // 7. Try other common editors
      if (!editor) {
        // Redactor
        const redactorEditor = document.querySelector('.redactor-box [contenteditable="true"], .redactor-editor[contenteditable="true"]');
        if (redactorEditor) {
          editor = redactorEditor;
          editorType = 'redactor';
          console.log("‚úÖ Found Redactor editor");
        }
      }
      
      if (!editor) {
        // Aloha Editor
        const alohaEditor = document.querySelector('.aloha-editable[contenteditable="true"], [contenteditable="true"].aloha-editable');
        if (alohaEditor) {
          editor = alohaEditor;
          editorType = 'aloha';
          console.log("‚úÖ Found Aloha editor");
        }
      }
      
      if (!editor) {
        // ContentEditable (generic fallback)
        const genericEditable = document.querySelector('[contenteditable="true"]');
        if (genericEditable) {
          editor = genericEditable;
          editorType = 'generic';
          console.log("‚úÖ Found generic contenteditable element");
        }
      }
      
      if (!editor) {
        console.warn("‚ö†Ô∏è No rich text editor found (tried: Froala, TinyMCE, Quill, Summernote, CKEditor 0-5, Redactor, Aloha, generic contenteditable)");
        return false;
      }
      
      // Focus the editor
      try {
        editor.focus();
      } catch (e) {
        console.warn("‚ö†Ô∏è Could not focus editor:", e);
      }
      
      // Unified injection system - try API first, then direct injection
      
      // 1. Try TinyMCE API
      if (editorType === 'tinymce') {
        if (typeof tinymce !== 'undefined' && tinymce.editors && tinymce.editors.length > 0) {
          try {
            let tinyMCEInstance = null;
            
            // Try to find instance by body element
            for (let i = 0; i < tinymce.editors.length; i++) {
              const ed = tinymce.editors[i];
              if (ed.getBody && ed.getBody() === editor) {
                tinyMCEInstance = ed;
                break;
              }
            }
            
            // Try by ID
            if (!tinyMCEInstance) {
              const editorId = editor.id || editor.getAttribute('data-id') || 
                             (editorMetadata.iframe ? editorMetadata.iframe.id : null);
              if (editorId) {
                tinyMCEInstance = tinymce.get(editorId);
              }
            }
            
            // Use first available editor if still not found
            if (!tinyMCEInstance && tinymce.editors.length > 0) {
              tinyMCEInstance = tinymce.editors[0];
            }
            
            if (tinyMCEInstance && tinyMCEInstance.setContent) {
              tinyMCEInstance.setContent(consolidatedContent);
              tinyMCEInstance.save();
              tinyMCEInstance.fire('change');
              console.log("‚úÖ Content injected to TinyMCE using API");
              return true;
            }
          } catch (e) {
            console.warn("‚ö†Ô∏è TinyMCE API injection failed, trying direct injection:", e);
          }
        }
      }
      
      // 2. Try CKEditor API (all versions 0-5)
      if (editorType === 'ckeditor' || editorType === 'ckeditor5') {
        // CKEditor 5 uses a different API structure than CKEditor 0-4
        if (editorType === 'ckeditor5') {
          // Try CKEditor 5 API methods
          let ckeditor5Instance = null;
          
          // Method 1: Check if editor instance is stored on the element
          if (editor.ckeditorInstance) {
            ckeditor5Instance = editor.ckeditorInstance;
          }
          
          // Method 2: Try to find via CKEditor 5 global objects
          if (!ckeditor5Instance) {
            // CKEditor 5 might expose editors via window.CKEDITOR or window.ClassicEditor, etc.
            const editorContainer = editor.closest('.ck-editor') || editor.closest('[class*="ck-editor"]');
            if (editorContainer) {
              // Check for instance stored on container
              if (editorContainer.ckeditorInstance) {
                ckeditor5Instance = editorContainer.ckeditorInstance;
              }
              
              // Check for data attribute with instance reference
              const instanceId = editorContainer.getAttribute('data-editor-id') || 
                                editorContainer.id;
              if (instanceId && window.CKEDITOR && window.CKEDITOR.instances) {
                ckeditor5Instance = window.CKEDITOR.instances[instanceId];
              }
            }
          }
          
          // Method 3: Try to find via document.querySelector and check for instance
          if (!ckeditor5Instance) {
            // CKEditor 5 instances might be stored in a global registry
            if (window.CKEDITOR && window.CKEDITOR.instances) {
              for (const instanceId in window.CKEDITOR.instances) {
                const instance = window.CKEDITOR.instances[instanceId];
                // CKEditor 5 instances have sourceElement or editableElement
                if (instance && (
                    (instance.sourceElement && instance.sourceElement === editor) ||
                    (instance.editing && instance.editing.view && instance.editing.view.domRoot === editor) ||
                    (instance.ui && instance.ui.element && instance.ui.element.contains(editor))
                  )) {
                  ckeditor5Instance = instance;
                  break;
                }
              }
            }
          }
          
          // Method 4: Try ClassicEditor, BalloonEditor, etc. global objects
          if (!ckeditor5Instance) {
            const editorTypes = ['ClassicEditor', 'BalloonEditor', 'InlineEditor', 'DecoupledEditor', 'Editor'];
            for (const editorTypeName of editorTypes) {
              if (window[editorTypeName] && window[editorTypeName].instances) {
                for (const instance of window[editorTypeName].instances) {
                  if (instance && (
                      instance.sourceElement === editor ||
                      (instance.editing && instance.editing.view && instance.editing.view.domRoot === editor)
                    )) {
                    ckeditor5Instance = instance;
                    break;
                  }
                }
                if (ckeditor5Instance) break;
              }
            }
          }
          
          // Use CKEditor 5 API if available
          if (ckeditor5Instance) {
            try {
              // CKEditor 5 uses setData method
              if (ckeditor5Instance.setData) {
                ckeditor5Instance.setData(consolidatedContent);
                console.log(`‚úÖ Content injected to CKEditor 5 using setData API`);
                return true;
              }
              // Alternative: direct data property
              if (ckeditor5Instance.data) {
                ckeditor5Instance.data.set(consolidatedContent);
                console.log(`‚úÖ Content injected to CKEditor 5 using data.set API`);
                return true;
              }
            } catch (e) {
              console.warn("‚ö†Ô∏è CKEditor 5 API injection failed, trying direct injection:", e);
            }
          }
        }
        
        // CKEditor 0-4 API (original code)
        let ckeditorInstance = null;
        
        if (window.CKEDITOR && window.CKEDITOR.instances) {
          // Method 1: Find by container
          const editorContainer = editor.closest('.cke_editor') || 
                                  editor.closest('[class*="cke_editor"]') ||
                                  editor.closest('.ck-editor') ||
                                  (editorMetadata.iframe ? editorMetadata.iframe.closest('.cke_editor') : null);
          
          if (editorContainer) {
            const containerId = editorContainer.id || 
                               editorContainer.getAttribute('id') ||
                               editorContainer.getAttribute('data-cke-id');
            if (containerId && window.CKEDITOR.instances[containerId]) {
              ckeditorInstance = window.CKEDITOR.instances[containerId];
            }
          }
          
          // Method 2: Iterate through all instances
          if (!ckeditorInstance) {
            for (const instanceId in window.CKEDITOR.instances) {
              const instance = window.CKEDITOR.instances[instanceId];
              if (instance && instance.container) {
                const instanceElement = instance.container.$ || instance.container;
                if (instanceElement && (
                    instanceElement.contains(editor) ||
                    (editorMetadata.iframe && instanceElement.contains(editorMetadata.iframe)) ||
                    (editorMetadata.iframe && instanceElement.querySelector('iframe.cke_wysiwyg_frame') === editorMetadata.iframe)
                  )) {
                  ckeditorInstance = instance;
                  break;
                }
              }
            }
          }
          
          // Method 3: Find by iframe name
          if (!ckeditorInstance && editorMetadata.iframe) {
            const iframeName = editorMetadata.iframe.name || editorMetadata.iframe.getAttribute('name');
            if (iframeName) {
              for (const instanceId in window.CKEDITOR.instances) {
                const instance = window.CKEDITOR.instances[instanceId];
                if (instance && instance.name === iframeName) {
                  ckeditorInstance = instance;
                  break;
                }
              }
            }
          }
          
          // Method 4: Try data attribute
          if (!ckeditorInstance) {
            const editorId = editor.getAttribute('data-cke-instance-id');
            if (editorId && window.CKEDITOR.instances[editorId]) {
              ckeditorInstance = window.CKEDITOR.instances[editorId];
            }
          }
        }
        
        // Use CKEditor API if available
        if (ckeditorInstance && ckeditorInstance.setData) {
          try {
            ckeditorInstance.setData(consolidatedContent);
            console.log(`‚úÖ Content injected to CKEditor using setData API`);
            return true;
          } catch (e) {
            console.warn("‚ö†Ô∏è CKEditor setData failed, trying direct injection:", e);
          }
        }
      }
      
      // 3. Try Quill API
      if (editorType === 'quill') {
        try {
          // Quill instances are often stored on the element
          const quillInstance = editor.__quill || editor.quill;
          if (quillInstance && quillInstance.root === editor && quillInstance.clipboard) {
            quillInstance.clipboard.dangerouslyPasteHTML(consolidatedContent);
            console.log("‚úÖ Content injected to Quill using API");
            return true;
          }
          
          // Alternative: Try to find Quill instance via container
          const quillContainer = editor.closest('.ql-container') || editor.closest('.quill');
          if (quillContainer && quillContainer.__quill) {
            quillContainer.__quill.clipboard.dangerouslyPasteHTML(consolidatedContent);
            console.log("‚úÖ Content injected to Quill using API (via container)");
            return true;
          }
        } catch (e) {
          console.warn("‚ö†Ô∏è Quill API injection failed, trying direct injection:", e);
        }
      }
      
      // 4. Try Summernote API
      if (editorType === 'summernote') {
        try {
          const summernoteContainer = editor.closest('.note-editor') || editor.closest('.summernote');
          if (summernoteContainer && summernoteContainer.summernote) {
            $(summernoteContainer).summernote('code', consolidatedContent);
            console.log("‚úÖ Content injected to Summernote using API");
            return true;
          }
        } catch (e) {
          console.warn("‚ö†Ô∏è Summernote API injection failed, trying direct injection:", e);
        }
      }
      
      // 5. Try Froala API
      if (editorType === 'froala') {
        try {
          const froalaContainer = editor.closest('.fr-wrapper') || editor.closest('.froala-editor');
          if (froalaContainer && froalaContainer.froalaEditor) {
            froalaContainer.froalaEditor('html.set', consolidatedContent);
            console.log("‚úÖ Content injected to Froala using API");
            return true;
          }
        } catch (e) {
          console.warn("‚ö†Ô∏è Froala API injection failed, trying direct injection:", e);
        }
      }
      
      // 6. Generic direct injection (fallback for all editors)
      try {
        // For CKEditor 5, we need special handling
        if (editorType === 'ckeditor5') {
          // Remove placeholder element if it exists
          const placeholder = editor.querySelector('.ck-placeholder');
          if (placeholder) {
            placeholder.remove();
          }
          
          // Clear existing content (but preserve structure)
          const existingParagraphs = editor.querySelectorAll('p');
          existingParagraphs.forEach(p => {
            // Keep the paragraph structure but clear content
            p.innerHTML = '';
          });
          
          // If there are no paragraphs, create one
          if (editor.querySelectorAll('p').length === 0) {
            const newP = document.createElement('p');
            editor.appendChild(newP);
          }
          
          // Set content in the first paragraph or directly
          const firstP = editor.querySelector('p') || editor;
          if (firstP === editor) {
            // Direct injection
            editor.innerHTML = consolidatedContent;
          } else {
            // Inject into paragraph
            firstP.innerHTML = consolidatedContent;
          }
          
          // For CKEditor 5, we need to trigger specific events in sequence
          // 1. Focus the editor first
          editor.focus();
          
          // 2. Trigger input events that CKEditor 5 listens to
          const inputEvent = new InputEvent('input', {
            bubbles: true,
            cancelable: true,
            inputType: 'insertText',
            data: consolidatedContent
          });
          editor.dispatchEvent(inputEvent);
          
          // 3. Trigger beforeinput
          const beforeInputEvent = new InputEvent('beforeinput', {
            bubbles: true,
            cancelable: true,
            inputType: 'insertText',
            data: consolidatedContent
          });
          editor.dispatchEvent(beforeInputEvent);
          
          // 4. Try to find and update CKEditor 5 model via instance
          const editorContainer = editor.closest('.ck-editor');
          if (editorContainer) {
            // Try multiple ways to find the instance
            let instance = editorContainer.ckeditorInstance;
            if (!instance && window.CKEDITOR && window.CKEDITOR.instances) {
              const instanceId = editorContainer.id || editorContainer.getAttribute('data-editor-id');
              if (instanceId) {
                instance = window.CKEDITOR.instances[instanceId];
              }
            }
            
            // If we found an instance, try to update it
            if (instance) {
              try {
                // Try setData method
                if (typeof instance.setData === 'function') {
                  instance.setData(consolidatedContent);
                  console.log("‚úÖ CKEditor 5 instance updated via setData");
                } else if (instance.model && instance.model.document) {
                  // Try to update the model directly
                  instance.model.change(writer => {
                    const root = instance.model.document.getRoot();
                    writer.remove(writer.createRangeIn(root));
                    writer.insertText(consolidatedContent.replace(/<[^>]*>/g, ''), root);
                  });
                  console.log("‚úÖ CKEditor 5 model updated directly");
                }
              } catch (e) {
                console.warn("‚ö†Ô∏è Could not update CKEditor 5 instance:", e);
              }
            }
          }
          
          // 5. Trigger standard events
          editor.dispatchEvent(new Event('change', { bubbles: true }));
          editor.dispatchEvent(new Event('blur', { bubbles: true }));
          editor.dispatchEvent(new Event('focus', { bubbles: true }));
          
          console.log(`‚úÖ Content injected directly to CKEditor 5 editor`);
          return true;
        }
        
        // For other editors, use standard injection
        // Clear existing content
        editor.innerHTML = '';
        
        // Set new content
        editor.innerHTML = consolidatedContent;
        
        // Trigger standard events
        editor.dispatchEvent(new Event('input', { bubbles: true }));
        editor.dispatchEvent(new Event('change', { bubbles: true }));
        
        // Editor-specific events
        if (editorType === 'ckeditor' || editorType === 'ckeditor5') {
          // For CKEditor 5, we need to trigger specific events and update the model
          if (editorType === 'ckeditor5') {
            // Remove placeholder if present
            const placeholder = editor.querySelector('.ck-placeholder');
            if (placeholder) {
              placeholder.remove();
            }
            
            // Trigger input event (CKEditor 5 listens for this)
            editor.dispatchEvent(new InputEvent('input', { 
              bubbles: true, 
              cancelable: true,
              data: consolidatedContent,
              inputType: 'insertText'
            }));
            
            // Trigger beforeinput event
            editor.dispatchEvent(new InputEvent('beforeinput', { 
              bubbles: true, 
              cancelable: true,
              data: consolidatedContent,
              inputType: 'insertText'
            }));
            
            // Try to find and update CKEditor 5 instance
            const editorContainer = editor.closest('.ck-editor');
            if (editorContainer) {
              // Try to find instance via various methods
              let ckeditor5Instance = null;
              
              // Check for instance on container
              if (editorContainer.ckeditorInstance) {
                ckeditor5Instance = editorContainer.ckeditorInstance;
              }
              
              // Check window.CKEDITOR.instances
              if (!ckeditor5Instance && window.CKEDITOR && window.CKEDITOR.instances) {
                const instanceId = editorContainer.id || editorContainer.getAttribute('data-editor-id');
                if (instanceId) {
                  ckeditor5Instance = window.CKEDITOR.instances[instanceId];
                }
              }
              
              // Try to find via iteration
              if (!ckeditor5Instance && window.CKEDITOR && window.CKEDITOR.instances) {
                for (const instanceId in window.CKEDITOR.instances) {
                  const instance = window.CKEDITOR.instances[instanceId];
                  if (instance && (
                      (instance.sourceElement && instance.sourceElement === editor) ||
                      (instance.editing && instance.editing.view && instance.editing.view.domRoot === editor)
                    )) {
                    ckeditor5Instance = instance;
                    break;
                  }
                }
              }
              
              // Update via instance if found
              if (ckeditor5Instance) {
                try {
                  if (ckeditor5Instance.setData) {
                    ckeditor5Instance.setData(consolidatedContent);
                  } else if (ckeditor5Instance.data && ckeditor5Instance.data.set) {
                    ckeditor5Instance.data.set(consolidatedContent);
                  }
                } catch (e) {
                  console.warn("‚ö†Ô∏è Could not update CKEditor 5 via instance:", e);
                }
              }
            }
            
            // Also trigger standard CKEditor events
            editor.dispatchEvent(new CustomEvent('ckeditor-change', { bubbles: true, detail: { data: consolidatedContent } }));
          } else {
            // CKEditor 0-4 events
            editor.dispatchEvent(new CustomEvent('ckeditor-change', { bubbles: true, detail: { data: consolidatedContent } }));
            // Try to fire instance events if available
            if (window.CKEDITOR && window.CKEDITOR.instances) {
              for (const instanceId in window.CKEDITOR.instances) {
                const instance = window.CKEDITOR.instances[instanceId];
                if (instance && instance.container && (instance.container.$ || instance.container).contains(editor)) {
                  try {
                    instance.fire('change');
                    instance.fire('dataReady');
                  } catch (e) {
                    // Ignore
                  }
                  break;
                }
              }
            }
          }
        } else if (editorType === 'quill') {
          editor.dispatchEvent(new CustomEvent('text-change', { bubbles: true }));
        } else if (editorType === 'summernote') {
          editor.dispatchEvent(new CustomEvent('summernote.change', { bubbles: true }));
        } else if (editorType === 'tinymce') {
          editor.dispatchEvent(new CustomEvent('tinymce-change', { bubbles: true }));
        }
        
        console.log(`‚úÖ Content injected directly to ${editorType} editor`);
        return true;
      } catch (err) {
        console.error(`‚ùå Error injecting to ${editorType}:`, err);
        
        // Final fallback: textContent
        try {
          editor.textContent = consolidatedContent;
          editor.dispatchEvent(new Event('input', { bubbles: true }));
          editor.dispatchEvent(new Event('change', { bubbles: true }));
          console.log(`‚úÖ Content injected using textContent fallback for ${editorType}`);
          return true;
        } catch (e) {
          console.error(`‚ùå Final fallback for ${editorType} also failed:`, e);
          return false;
        }
      }
      
    } catch (error) {
      console.error("‚ùå Error injecting data to rich text editor:", error);
      return false;
    }
  }

  // --- Visual Feedback System ---
  function createProgressIndicator() {
    // Remove existing indicator if any
    const existing = document.getElementById('automation-progress');
    if (existing) existing.remove();
    
    const indicator = document.createElement('div');
    indicator.id = 'automation-progress';
    indicator.style.cssText = `
      position: fixed;
      top: 20px;
      left: 20px;
      right: auto;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      z-index: 100000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      min-width: 250px;
      backdrop-filter: blur(10px);
      cursor: move;
      user-select: none;
      transition: all 0.3s ease;
    `;
    
    // Add edge movement functionality (default: upper left)
    let isDragging = false;
    let isMinimized = false;
    let currentEdge = 'top-left';
    let dragOffset = { x: 0, y: 0 };
    
    // Make indicator draggable (only when not minimized)
    indicator.addEventListener('mousedown', (e) => {
      if (e.target.classList.contains('minimize-btn') || e.target.classList.contains('edge-btn')) return;
      if (isMinimized) return; // Disable dragging when minimized
      
      isDragging = true;
      const rect = indicator.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left;
      dragOffset.y = e.clientY - rect.top;
      
      indicator.style.cursor = 'grabbing';
      e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isDragging || isMinimized) return; // Don't drag when minimized
      
      const x = e.clientX - dragOffset.x;
      const y = e.clientY - dragOffset.y;
      
      // Keep indicator within viewport bounds
      const maxX = window.innerWidth - indicator.offsetWidth;
      const maxY = window.innerHeight - indicator.offsetHeight;
      
      indicator.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
      indicator.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
      indicator.style.right = 'auto';
      indicator.style.bottom = 'auto';
    });
    
    document.addEventListener('mouseup', () => {
      if (!isDragging || isMinimized) return; // Don't snap when minimized
      
      isDragging = false;
      indicator.style.cursor = 'move';
      
      // Snap to nearest edge
      snapToEdge();
    });
    
    function snapToEdge() {
      const rect = indicator.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      
      // Determine which corner is closest
      const distanceToTopLeft = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerY, 2));
      const distanceToTopRight = Math.sqrt(Math.pow(windowWidth - centerX, 2) + Math.pow(centerY, 2));
      const distanceToBottomLeft = Math.sqrt(Math.pow(centerX, 2) + Math.pow(windowHeight - centerY, 2));
      const distanceToBottomRight = Math.sqrt(Math.pow(windowWidth - centerX, 2) + Math.pow(windowHeight - centerY, 2));
      
      const minDistance = Math.min(distanceToTopLeft, distanceToTopRight, distanceToBottomLeft, distanceToBottomRight);
      
      if (minDistance === distanceToTopLeft) {
        currentEdge = 'top-left';
        indicator.style.top = '20px';
        indicator.style.left = '20px';
        indicator.style.right = 'auto';
        indicator.style.bottom = 'auto';
        indicator.style.transform = 'none';
      } else if (minDistance === distanceToTopRight) {
        currentEdge = 'top-right';
        indicator.style.top = '20px';
        indicator.style.right = '20px';
        indicator.style.left = 'auto';
        indicator.style.bottom = 'auto';
        indicator.style.transform = 'none';
      } else if (minDistance === distanceToBottomLeft) {
        currentEdge = 'bottom-left';
        indicator.style.bottom = '20px';
        indicator.style.left = '20px';
        indicator.style.right = 'auto';
        indicator.style.top = 'auto';
        indicator.style.transform = 'none';
      } else {
        currentEdge = 'bottom-right';
        indicator.style.bottom = '20px';
        indicator.style.right = '20px';
        indicator.style.left = 'auto';
        indicator.style.top = 'auto';
        indicator.style.transform = 'none';
      }
    }
    
    // Add minimize/maximize functionality
    function toggleMinimize() {
      isMinimized = !isMinimized;
      
      if (isMinimized) {
        // Store current position before minimizing
        const currentRect = indicator.getBoundingClientRect();
        const currentPosition = {
          top: indicator.style.top,
          left: indicator.style.left,
          right: indicator.style.right,
          bottom: indicator.style.bottom,
          transform: indicator.style.transform
        };
        
        // Minimize to progress icon
        indicator.style.minWidth = '60px';
        indicator.style.padding = '10px';
        indicator.style.borderRadius = '50%';
        indicator.style.cursor = 'pointer'; // Change cursor to pointer when minimized
        
        // Ensure position is maintained at corner
        if (currentEdge === 'top-left') {
          indicator.style.top = '20px';
          indicator.style.left = '20px';
          indicator.style.right = 'auto';
          indicator.style.bottom = 'auto';
          indicator.style.transform = 'none';
        } else if (currentEdge === 'top-right') {
          indicator.style.top = '20px';
          indicator.style.right = '20px';
          indicator.style.left = 'auto';
          indicator.style.bottom = 'auto';
          indicator.style.transform = 'none';
        } else if (currentEdge === 'bottom-left') {
          indicator.style.bottom = '20px';
          indicator.style.left = '20px';
          indicator.style.right = 'auto';
          indicator.style.top = 'auto';
          indicator.style.transform = 'none';
        } else if (currentEdge === 'bottom-right') {
          indicator.style.bottom = '20px';
          indicator.style.right = '20px';
          indicator.style.left = 'auto';
          indicator.style.top = 'auto';
          indicator.style.transform = 'none';
        }
        
        indicator.innerHTML = `
          <div style="display: flex; align-items: center; justify-content: center; flex-direction: column; cursor: pointer;">
            <div style="background: #4CAF50; width: 8px; height: 8px; border-radius: 50%; margin-bottom: 4px; animation: pulse 2s infinite;"></div>
            <div style="font-size: 10px; text-align: center; line-height: 1.2;">
              <div id="progress-percentage">0%</div>
              <div style="font-size: 8px; opacity: 0.8;">Step</div>
            </div>
          </div>
        `;
        
        // Add click handler for minimized state to maximize
        indicator.addEventListener('click', function maximizeHandler(e) {
          if (isMinimized) {
            e.stopPropagation();
            console.log("üîÑ Maximizing progress indicator");
            toggleMinimize(); // This will maximize it
            indicator.removeEventListener('click', maximizeHandler); // Remove this specific handler
          }
        });
        
      } else {
        // Restore full indicator with proper content
        indicator.style.minWidth = '250px';
        indicator.style.padding = '15px 20px';
        indicator.style.borderRadius = '10px';
        indicator.style.cursor = 'move'; // Restore move cursor
        
        // Restore the full progress indicator content (like the second image)
        indicator.innerHTML = `
          <div style="display: flex; align-items: center; margin-bottom: 5px;">
            <div style="background: #4CAF50; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; animation: pulse 2s infinite;"></div>
            <strong>Automation Progress</strong>
          </div>
          <div style="background: rgba(255,255,255,0.3); height: 4px; border-radius: 2px; margin: 8px 0;">
            <div id="progress-bar-fill" style="background: #4CAF50; height: 100%; width: 0%; border-radius: 2px; transition: width 0.3s ease;"></div>
          </div>
          <div id="step-info" style="font-size: 12px; opacity: 0.9;">
            Step 0 of 0 (0%)
          </div>
          <div id="current-action" style="font-size: 11px; opacity: 0.8; margin-top: 4px;">
            Ready to start
          </div>
        `;
        
        // Ensure position is maintained at edge when maximizing
        if (currentEdge === 'top-left') {
          indicator.style.top = '20px';
          indicator.style.left = '20px';
          indicator.style.right = 'auto';
          indicator.style.bottom = 'auto';
          indicator.style.transform = 'none';
        } else if (currentEdge === 'top-right') {
          indicator.style.top = '20px';
          indicator.style.right = '20px';
          indicator.style.left = 'auto';
          indicator.style.bottom = 'auto';
          indicator.style.transform = 'none';
        } else if (currentEdge === 'bottom-left') {
          indicator.style.bottom = '20px';
          indicator.style.left = '20px';
          indicator.style.right = 'auto';
          indicator.style.top = 'auto';
          indicator.style.transform = 'none';
        } else if (currentEdge === 'bottom-right') {
          indicator.style.bottom = '20px';
          indicator.style.right = '20px';
          indicator.style.left = 'auto';
          indicator.style.top = 'auto';
          indicator.style.transform = 'none';
        } else if (currentEdge === 'top') {
          indicator.style.top = '20px';
          indicator.style.left = '50%';
          indicator.style.right = 'auto';
          indicator.style.bottom = 'auto';
          indicator.style.transform = 'translateX(-50%)';
        } else if (currentEdge === 'bottom') {
          indicator.style.bottom = '20px';
          indicator.style.left = '50%';
          indicator.style.top = 'auto';
          indicator.style.right = 'auto';
          indicator.style.transform = 'translateX(-50%)';
        } else if (currentEdge === 'left') {
          indicator.style.left = '20px';
          indicator.style.top = '50%';
          indicator.style.right = 'auto';
          indicator.style.bottom = 'auto';
          indicator.style.transform = 'translateY(-50%)';
        } else if (currentEdge === 'right') {
          indicator.style.right = '20px';
          indicator.style.top = '50%';
          indicator.style.left = 'auto';
          indicator.style.bottom = 'auto';
          indicator.style.transform = 'translateY(-50%)';
        }
        
        // Re-add control buttons
        const minimizeBtn = document.createElement('button');
        minimizeBtn.className = 'minimize-btn';
        minimizeBtn.innerHTML = '‚àí';
        minimizeBtn.style.cssText = `
          position: absolute;
          top: 5px;
          right: 5px;
          background: rgba(255,255,255,0.2);
          border: none;
          color: white;
          width: 20px;
          height: 20px;
          border-radius: 50%;
          cursor: pointer;
          font-size: 12px;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: background 0.2s ease;
        `;
        
        minimizeBtn.addEventListener('mouseenter', () => {
          minimizeBtn.style.background = 'rgba(255,255,255,0.3)';
        });
        
        minimizeBtn.addEventListener('mouseleave', () => {
          minimizeBtn.style.background = 'rgba(255,255,255,0.2)';
        });
        
        minimizeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleMinimize();
        });
        
        // Re-add edge movement buttons
        const edgeControls = document.createElement('div');
        edgeControls.style.cssText = `
          position: absolute;
          top: 5px;
          left: 5px;
          display: flex;
          gap: 2px;
        `;
        
        const corners = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
        corners.forEach(corner => {
          const btn = document.createElement('button');
          btn.className = 'edge-btn';
          btn.innerHTML = corner.split('-').map(word => word.charAt(0).toUpperCase()).join('');
          btn.title = `Move to ${corner} corner`;
          btn.style.cssText = `
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 16px;
            height: 16px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
          `;
          
          btn.addEventListener('mouseenter', () => {
            btn.style.background = 'rgba(255,255,255,0.3)';
          });
          
          btn.addEventListener('mouseleave', () => {
            btn.style.background = 'rgba(255,255,255,0.2)';
          });
          
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            currentEdge = corner;
            
            // Reset positioning
            indicator.style.left = 'auto';
            indicator.style.right = 'auto';
            indicator.style.top = 'auto';
            indicator.style.bottom = 'auto';
            indicator.style.transform = 'none';
            
            // Position based on corner
            switch (corner) {
              case 'top-left':
                indicator.style.top = '20px';
                indicator.style.left = '20px';
                break;
              case 'top-right':
                indicator.style.top = '20px';
                indicator.style.right = '20px';
                break;
              case 'bottom-left':
                indicator.style.bottom = '20px';
                indicator.style.left = '20px';
                break;
              case 'bottom-right':
                indicator.style.bottom = '20px';
                indicator.style.right = '20px';
                break;
            }
          });
          
          edgeControls.appendChild(btn);
        });
        
        indicator.appendChild(minimizeBtn);
        indicator.appendChild(edgeControls);
        
        // Content will be updated by updateProgressIndicator
      }
    }
    
    // Add minimize button
    const minimizeBtn = document.createElement('button');
    minimizeBtn.className = 'minimize-btn';
    minimizeBtn.innerHTML = '‚àí';
    minimizeBtn.style.cssText = `
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
    `;
    
    minimizeBtn.addEventListener('mouseenter', () => {
      minimizeBtn.style.background = 'rgba(255,255,255,0.3)';
    });
    
    minimizeBtn.addEventListener('mouseleave', () => {
      minimizeBtn.style.background = 'rgba(255,255,255,0.2)';
    });
    
    minimizeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleMinimize();
    });
    
    // Add edge movement buttons
    const edgeControls = document.createElement('div');
    edgeControls.style.cssText = `
      position: absolute;
      top: 5px;
      left: 5px;
      display: flex;
      gap: 2px;
    `;
    
    const corners = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    corners.forEach(corner => {
      const btn = document.createElement('button');
      btn.className = 'edge-btn';
      btn.innerHTML = corner.split('-').map(word => word.charAt(0).toUpperCase()).join('');
      btn.title = `Move to ${corner} corner`;
      btn.style.cssText = `
        background: rgba(255,255,255,0.2);
        border: none;
        color: white;
        width: 16px;
        height: 16px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s ease;
      `;
      
      btn.addEventListener('mouseenter', () => {
        btn.style.background = 'rgba(255,255,255,0.3)';
      });
      
      btn.addEventListener('mouseleave', () => {
        btn.style.background = 'rgba(255,255,255,0.2)';
      });
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        currentEdge = corner;
        
        // Reset positioning
        indicator.style.left = 'auto';
        indicator.style.right = 'auto';
        indicator.style.top = 'auto';
        indicator.style.bottom = 'auto';
        indicator.style.transform = 'none';
        
        // Position based on corner
        switch (corner) {
          case 'top-left':
            indicator.style.top = '20px';
            indicator.style.left = '20px';
            break;
          case 'top-right':
            indicator.style.top = '20px';
            indicator.style.right = '20px';
            break;
          case 'bottom-left':
            indicator.style.bottom = '20px';
            indicator.style.left = '20px';
            break;
          case 'bottom-right':
            indicator.style.bottom = '20px';
            indicator.style.right = '20px';
            break;
        }
      });
      
      edgeControls.appendChild(btn);
    });
    
    indicator.appendChild(minimizeBtn);
    indicator.appendChild(edgeControls);
    
    document.body.appendChild(indicator);
    return indicator;
  }
  
  function updateProgressIndicator(stepIndex, totalSteps, currentAction, elementInfo) {
    const indicator = document.getElementById('automation-progress');
    if (!indicator) return;
    
    const progress = Math.round((stepIndex / totalSteps) * 100);
    
    // Check if indicator is minimized
    const isMinimized = indicator.style.borderRadius === '50%';
    
    if (isMinimized) {
      // Update minimized state
      const progressElement = indicator.querySelector('#progress-percentage');
      if (progressElement) {
        progressElement.textContent = `${progress}%`;
      }
    } else {
      // Update expanded state
      const progressBar = `
        <div style="background: rgba(255,255,255,0.3); height: 4px; border-radius: 2px; margin: 8px 0;">
          <div style="background: #4CAF50; height: 100%; width: ${progress}%; border-radius: 2px; transition: width 0.3s ease;"></div>
        </div>
      `;
      
      // Preserve control buttons
      const minimizeBtn = indicator.querySelector('.minimize-btn');
      const edgeControls = indicator.querySelector('div[style*="position: absolute"][style*="top: 5px"][style*="left: 5px"]');
      
      // Get step label from automation steps
      let stepLabel = currentAction;
      try {
        const steps = window.automationSteps || [];
        if (steps[stepIndex] && steps[stepIndex].description) {
          stepLabel = steps[stepIndex].description;
        }
      } catch (error) {
        console.warn("Could not get step label:", error);
      }

      indicator.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 5px;">
          <div style="background: #4CAF50; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; animation: pulse 2s infinite;"></div>
          <strong>Automation Progress</strong>
        </div>
        ${progressBar}
        <div style="font-size: 12px; opacity: 0.9;">
          Step ${stepIndex + 1} of ${totalSteps} (${progress}%)
        </div>
        <div style="font-size: 11px; opacity: 0.8; margin-top: 4px; max-width: 200px; word-wrap: break-word;">
          ${stepLabel}
        </div>
      `;
      
      // Re-add control buttons
      if (minimizeBtn) {
        indicator.appendChild(minimizeBtn);
      }
      if (edgeControls) {
        indicator.appendChild(edgeControls);
      }
    }
    
    // Add pulse animation
    if (!document.getElementById('automation-progress-styles')) {
      const style = document.createElement('style');
      style.id = 'automation-progress-styles';
      style.textContent = `
        @keyframes pulse {
          0% { opacity: 1; }
          50% { opacity: 0.5; }
          100% { opacity: 1; }
        }
      `;
      document.head.appendChild(style);
    }
  }
  
  function highlightElement(element, stepIndex, action, value = '') {
    if (!element) return;
    
    // Store original styles
    if (!element._originalStyles) {
      element._originalStyles = {
        border: element.style.border,
        backgroundColor: element.style.backgroundColor,
        boxShadow: element.style.boxShadow,
        transition: element.style.transition
      };
    }
    
    // Apply highlight styles
    element.style.transition = 'all 0.3s ease';
    element.style.border = '3px solid #4CAF50';
    element.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
    element.style.boxShadow = '0 0 15px rgba(76, 175, 80, 0.5)';
    
    // Add step number indicator
    const stepIndicator = document.createElement('div');
    stepIndicator.className = 'automation-step-indicator';
    stepIndicator.style.cssText = `
      position: absolute;
      top: -8px;
      right: -8px;
      background: #4CAF50;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
      z-index: 100001;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    stepIndicator.textContent = stepIndex + 1;
    
    // Make element position relative if not already
    const originalPosition = element.style.position;
    if (!originalPosition || originalPosition === 'static') {
      element.style.position = 'relative';
    }
    
    element.appendChild(stepIndicator);
    
    // Show tooltip with action details
    const tooltip = document.createElement('div');
    tooltip.className = 'automation-tooltip';
    tooltip.style.cssText = `
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 100002;
      margin-bottom: 5px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    tooltip.textContent = `${action}${value ? `: "${value}"` : ''}`;
    element.appendChild(tooltip);
    
    // Remove highlight after delay
    setTimeout(() => {
      if (element._originalStyles) {
        element.style.border = element._originalStyles.border;
        element.style.backgroundColor = element._originalStyles.backgroundColor;
        element.style.boxShadow = element._originalStyles.boxShadow;
        element.style.transition = element._originalStyles.transition;
      }
      
      const indicator = element.querySelector('.automation-step-indicator');
      if (indicator) indicator.remove();
      
      const tooltipEl = element.querySelector('.automation-tooltip');
      if (tooltipEl) tooltipEl.remove();
    }, 2000);
  }
  
  function validateFieldFill(element, expectedValue) {
    if (!element) return false;
    
    // Use inner input/textarea for typeahead wrappers so we validate the real value, not wrapper textContent (e.g. "16Filling" from highlight)
    let valueEl = element;
    if (element.tagName !== 'INPUT' && element.tagName !== 'TEXTAREA') {
      const inner = element.querySelector('input, textarea');
      if (inner) valueEl = inner;
    }
    const tagName = valueEl.tagName.toLowerCase();
    let actualValue;
    if (valueEl.tagName === 'INPUT' || valueEl.tagName === 'TEXTAREA') {
      actualValue = valueEl.value != null ? String(valueEl.value) : '';
    } else {
      actualValue = (valueEl.value != null ? String(valueEl.value) : (valueEl.textContent || '')).trim();
    }
    const actualTrimmed = actualValue.trim();
    let isFilled = actualTrimmed !== '';
    const expectedEmpty = expectedValue == null || (typeof expectedValue === 'string' && String(expectedValue).trim() === '');
    // When no value was supplied (expected empty): valid only if field is actually empty (data "out" = must not pass as filled)
    if (expectedEmpty) {
      const valid = !isFilled;
      console.log(`üîç Field validation (expected empty): actual="${actualValue}", filled=${isFilled}, valid=${valid}`);
      return valid;
    }
    const expectedTrimmed = String(expectedValue).trim();
    
    // Helper function to normalize phone numbers (remove formatting)
    const normalizePhone = (phoneStr) => {
      if (!phoneStr || typeof phoneStr !== 'string') return '';
      // Remove all non-digit characters except +
      return phoneStr.replace(/[^\d+]/g, '');
    };
    
    // Check if this is a phone field
    const isPhoneFieldElement = () => {
      if (!element) return false;
      const name = (element.name || '').toLowerCase();
      const id = (element.id || '').toLowerCase();
      const type = (element.type || '').toLowerCase();
      const className = (element.className || '').toLowerCase();
      const placeholder = (element.placeholder || '').toLowerCase();
      
      const phoneKeywords = ['phone', 'telephone', 'mobile', 'fax', 'tel', 'contactphone', 'contacttelephone'];
      return phoneKeywords.some(keyword => 
        name.includes(keyword) || 
        id.includes(keyword) || 
        className.includes(keyword) ||
        placeholder.includes(keyword)
      ) || type === 'tel';
    };

    // Local fallbacks in case helpers are scoped elsewhere
    const normalizeCountryStringLocal = typeof normalizeCountryString === 'function'
      ? normalizeCountryString
      : (value) => String(value || '').toLowerCase().replace(/[^a-z0-9]/g, '');

    const getCountryAliasSetLocal = typeof getCountryAliasSet === 'function'
      ? getCountryAliasSet
      : (value) => {
          const normalized = normalizeCountryStringLocal(value);
          const aliasMap = {
            usa: [
              'usa',
              'us',
              'unitedstates',
              'unitedstatesofamerica',
              'u s',
              'u s a',
              'u.s.',
              'u.s.a.',
              'america',
              'theunitedstates',
              'theunitedstatesofamerica'
            ],
            uk: [
              'uk',
              'unitedkingdom',
              'greatbritain',
              'britain',
              'gb',
              'gbr',
              'u.k.',
              'england',
              'scotland',
              'wales',
              'northernireland'
            ],
            australia: ['australia', 'au', 'aus'],
            canada: ['canada', 'ca', 'can'],
            newzealand: ['newzealand', 'new zealand', 'nz']
          };
          const aliases = new Set([normalized]);
          Object.keys(aliasMap).forEach((key) => {
            const normalizedAliases = aliasMap[key].map((alias) => normalizeCountryStringLocal(alias));
            if (normalizedAliases.includes(normalized) || key === normalized) {
              aliases.add(key);
              normalizedAliases.forEach((alias) => aliases.add(alias));
            }
          });
          return aliases;
        };

    const isCountrySelectLocal = typeof isCountrySelect === 'function'
      ? isCountrySelect
      : (el) => {
          if (!el) return false;
          const name = (el.getAttribute('name') || '').toLowerCase();
          const id = (el.getAttribute('id') || '').toLowerCase();
          const className = (el.getAttribute('class') || '').toLowerCase();
          return name.includes('country') || id.includes('country') || className.includes('country');
        };
    
    // Helper function to check if an attribute contains element references or HTML
    const getAttributeWithElementReferences = (element, attrName) => {
      if (!element) return null;
      
      const attrValue = element.getAttribute(attrName);
      if (!attrValue) return null;
      
      // Attributes that typically contain element IDs (space-separated)
      const elementReferenceAttributes = [
        'aria-controls',      // IDs of elements controlled by this element
        'aria-labelledby',     // IDs of elements that label this element
        'aria-describedby',    // IDs of elements that describe this element
        'aria-owns',           // IDs of elements owned by this element
        'aria-activedescendant', // ID of the active descendant
        'aria-flowto',         // IDs of elements that follow this one
        'for'                  // ID of the element this label is for (on <label>)
      ];
      
      // Attributes that might contain HTML content
      const htmlContentAttributes = [
        'data-content',        // Custom data attribute that might contain HTML
        'data-html',           // Custom data attribute for HTML
        'title',              // Tooltip that might contain HTML entities
        'aria-label'          // Accessible label (usually plain text, but might have entities)
      ];
      
      // Attributes that are plain text (no element references or HTML)
      const plainTextAttributes = [
        'placeholder',         // Placeholder text (plain text only)
        'value',               // Form value (plain text)
        'name',                // Form field name
        'id',                  // Element ID
        'class',               // CSS classes
        'type'                 // Input type
      ];
      
      const result = {
        attribute: attrName,
        value: attrValue,
        containsElementReferences: false,
        containsHTML: false,
        referencedElements: [],
        isPlainText: false
      };
      
      // Check if attribute contains element references
      if (elementReferenceAttributes.includes(attrName)) {
        result.containsElementReferences = true;
        // Split by spaces to get individual IDs
        const elementIds = attrValue.trim().split(/\s+/).filter(id => id.length > 0);
        result.referencedElements = elementIds.map(id => {
          try {
            const refElement = document.getElementById(id) || 
                              document.querySelector(`[id="${id}"]`) ||
                              document.querySelector(`[name="${id}"]`);
            return {
              id: id,
              found: !!refElement,
              element: refElement,
              tagName: refElement ? refElement.tagName : null,
              textContent: refElement ? refElement.textContent?.trim().substring(0, 50) : null
            };
          } catch (e) {
            return { id: id, found: false, error: e.message };
          }
        });
      }
      
      // Check if attribute might contain HTML
      if (htmlContentAttributes.includes(attrName)) {
        // Check for HTML tags in the attribute value
        const htmlTagPattern = /<[^>]+>/;
        result.containsHTML = htmlTagPattern.test(attrValue);
      }
      
      // Check if it's a plain text attribute
      if (plainTextAttributes.includes(attrName)) {
        result.isPlainText = true;
      }
      
      return result;
    };
    
    // Helper function to check all attributes that might contain element references or HTML
    const getAllAttributesWithReferences = (element) => {
      if (!element) return [];
      
      const attributesToCheck = [
        'aria-controls',
        'aria-labelledby',
        'aria-describedby',
        'aria-owns',
        'aria-activedescendant',
        'aria-flowto',
        'for',
        'placeholder',
        'data-content',
        'data-html',
        'title',
        'aria-label'
      ];
      
      const results = [];
      attributesToCheck.forEach(attrName => {
        const result = getAttributeWithElementReferences(element, attrName);
        if (result && result.value) {
          results.push(result);
        }
      });
      
      return results;
    };
    
    let isCorrect = actualTrimmed.includes(expectedTrimmed) || expectedTrimmed.includes(actualTrimmed);
    
    // Special handling for phone fields - normalize before comparison
    if (isPhoneFieldElement()) {
      const normalizedExpected = normalizePhone(String(expectedValue || ''));
      const normalizedActual = normalizePhone(String(actualValue || ''));
      
      // Compare normalized values
      isCorrect = !expectedValue || 
                 normalizedActual === normalizedExpected ||
                 normalizedActual.includes(normalizedExpected) ||
                 normalizedExpected.includes(normalizedActual);
      
      console.log(`üîç Phone field validation: expected="${expectedValue}" (normalized: "${normalizedExpected}"), actual="${actualValue}" (normalized: "${normalizedActual}"), filled=${isFilled}, correct=${isCorrect}`);
    }
    // Special handling for SELECT elements
    else if (tagName === 'select') {
      const selectedOption = element.options[element.selectedIndex];
      if (selectedOption) {
        const selectedText = selectedOption.textContent.trim();
        const selectedValue = selectedOption.value;
        
        // For select elements, validate against both the selected text and value
        isCorrect = !expectedValue || 
                   selectedText.toLowerCase().includes(expectedValue.toLowerCase()) ||
                   expectedValue.toLowerCase().includes(selectedText.toLowerCase()) ||
                   selectedValue === expectedValue ||
                   actualValue === expectedValue;

        // Country alias validation (e.g., United States vs USA)
        if (!isCorrect && expectedValue && isCountrySelectLocal(element)) {
          const aliasSet = getCountryAliasSetLocal(expectedValue);
          const normalizedSelectedText = normalizeCountryStringLocal(selectedText);
          const normalizedSelectedValue = normalizeCountryStringLocal(selectedValue);
          const normalizedActualValue = normalizeCountryStringLocal(actualValue);
          isCorrect = aliasSet.has(normalizedSelectedText) ||
                      aliasSet.has(normalizedSelectedValue) ||
                      aliasSet.has(normalizedActualValue);
        }
        
        console.log(`üîç SELECT validation: expected="${expectedValue}", selectedText="${selectedText}", selectedValue="${selectedValue}", actualValue="${actualValue}", filled=${isFilled}, correct=${isCorrect}`);
      } else {
        console.log(`üîç SELECT validation: expected="${expectedValue}", actual="${actualValue}", filled=${isFilled}, correct=${isCorrect} (no selected option)`);
      }
    } else {
      console.log(`üîç Field validation: expected="${expectedValue}", actual="${actualValue}", filled=${isFilled}, correct=${isCorrect}`);
    }
    
    return isFilled && isCorrect;
  }

  // --- Notification Modal Functions ---
  function showDomainEligibilityModal(message) {
    // Create modal overlay
    const modalOverlay = document.createElement('div');
    modalOverlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999999;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;

    // Create modal content
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      background: white;
      border-radius: 12px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      text-align: center;
      position: relative;
    `;

    // Create close button
    const closeButton = document.createElement('button');
    closeButton.innerHTML = '√ó';
    closeButton.style.cssText = `
      position: absolute;
      top: 15px;
      right: 20px;
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s;
    `;
    closeButton.onmouseover = () => closeButton.style.backgroundColor = '#f0f0f0';
    closeButton.onmouseout = () => closeButton.style.backgroundColor = 'transparent';

    // Create icon
    const icon = document.createElement('div');
    icon.innerHTML = '‚ö†Ô∏è';
    icon.style.cssText = `
      font-size: 48px;
      margin-bottom: 20px;
    `;

    // Create title
    const title = document.createElement('h2');
    title.textContent = 'Domain Not Configured';
    title.style.cssText = `
      margin: 0 0 15px 0;
      color: #333;
      font-size: 24px;
      font-weight: 600;
    `;

    // Create message
    const messageDiv = document.createElement('div');
    messageDiv.textContent = message;
    messageDiv.style.cssText = `
      color: #666;
      font-size: 16px;
      line-height: 1.5;
      margin-bottom: 25px;
    `;

    // Create refresh button
    const refreshButton = document.createElement('button');
    refreshButton.textContent = 'Refresh Page';
    refreshButton.style.cssText = `
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.2s;
    `;
    refreshButton.onmouseover = () => refreshButton.style.backgroundColor = '#0056b3';
    refreshButton.onmouseout = () => refreshButton.style.backgroundColor = '#007bff';

    // Assemble modal
    modalContent.appendChild(closeButton);
    modalContent.appendChild(icon);
    modalContent.appendChild(title);
    modalContent.appendChild(messageDiv);
    modalContent.appendChild(refreshButton);
    modalOverlay.appendChild(modalContent);

    // Add to page
    document.body.appendChild(modalOverlay);

    // Event handlers
    let closeModal = () => {
      document.body.removeChild(modalOverlay);
    };

    closeButton.onclick = closeModal;
    refreshButton.onclick = async () => {
      // Clear completion status for this domain before reloading
      const completionKey = getTabSpecificCompletionKey();
      const resumeKey = getTabSpecificResumeIndexKey();
      console.log(`üîÑ [REFRESH] Clearing completion status for key: ${completionKey}`);
      
      // Reset in-memory automation state first
      if (window.__AUTOMATION_STATE__) {
        window.__AUTOMATION_STATE__.isCompleted = false;
        window.__AUTOMATION_STATE__.status = AutomationStatus.IDLE;
        console.log(`üîÑ [REFRESH] Reset in-memory automation state`);
      }
      
      // Clear completion data and reset resume index, then reload
      return new Promise((resolve) => {
        let operationsCompleted = 0;
        const totalOperations = 2;
        
        const checkComplete = () => {
          operationsCompleted++;
          if (operationsCompleted === totalOperations) {
            console.log(`‚úÖ [REFRESH] All reset operations completed, reloading page...`);
            window.location.reload();
          }
        };
        
        // Clear completion data from chrome.storage.local
        CHROME_API.storage.local.remove([completionKey], () => {
          if (CHROME_API.lastError) {
            console.error(`‚ùå [REFRESH] Error clearing completion status:`, CHROME_API.lastError);
          } else {
            console.log(`‚úÖ [REFRESH] Completion status cleared successfully`);
          }
          checkComplete();
        });
        
        // Reset resume index (domain + current run) to 0
        clearResumeIndex();
        console.log(`‚úÖ [REFRESH] Reset resume index to 0`);
        checkComplete();
      });
    };
    modalOverlay.onclick = (e) => {
      if (e.target === modalOverlay) {
        closeModal();
      }
    };

    // Prevent body scroll
    document.body.style.overflow = 'hidden';

    // Clean up on close
    const originalCloseModal = closeModal;
    closeModal = () => {
      document.body.style.overflow = '';
      originalCloseModal();
    };
  }

  // --- Screenshot Capture with Drag Selection Function ---
  async function captureScreenshotWithSelection() {
    return new Promise((resolve, reject) => {
      // Remove any existing screenshot selection overlays
      const existingOverlay = document.querySelector('[data-screenshot-selection="true"]');
      if (existingOverlay) {
        existingOverlay.remove();
      }

      // Create overlay container
      const overlayContainer = document.createElement('div');
      overlayContainer.setAttribute('data-screenshot-selection', 'true');
      overlayContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1000000;
        pointer-events: none;
      `;

      // Create 4 overlay sections to cover area outside selection (top, bottom, left, right)
      const overlayTop = document.createElement('div');
      overlayTop.className = 'screenshot-overlay-section';
      overlayTop.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        background: rgba(0, 0, 0, 0.3);
        pointer-events: auto;
        cursor: crosshair;
        user-select: none;
      `;

      const overlayBottom = document.createElement('div');
      overlayBottom.className = 'screenshot-overlay-section';
      overlayBottom.style.cssText = `
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        background: rgba(0, 0, 0, 0.3);
        pointer-events: auto;
        cursor: crosshair;
        user-select: none;
      `;

      const overlayLeft = document.createElement('div');
      overlayLeft.className = 'screenshot-overlay-section';
      overlayLeft.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        background: rgba(0, 0, 0, 0.3);
        pointer-events: auto;
        cursor: crosshair;
        user-select: none;
      `;

      const overlayRight = document.createElement('div');
      overlayRight.className = 'screenshot-overlay-section';
      overlayRight.style.cssText = `
        position: absolute;
        top: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.3);
        pointer-events: auto;
        cursor: crosshair;
        user-select: none;
      `;

      // Create selection rectangle (border only, no background overlay)
      const selectionRect = document.createElement('div');
      selectionRect.style.cssText = `
        position: absolute;
        border: 2px dashed #4CAF50;
        background: transparent;
        pointer-events: none;
        display: none;
        z-index: 1000001;
      `;

      // Create info display
      const infoDisplay = document.createElement('div');
      infoDisplay.style.cssText = `
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 12px;
        pointer-events: none;
        display: none;
        z-index: 1000001;
      `;

      // Create toolbar (will be positioned outside selection area)
      const toolbar = document.createElement('div');
      toolbar.style.cssText = `
        position: fixed;
        background: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        z-index: 1000002;
        display: none;
        flex-direction: column;
        gap: 12px;
        align-items: center;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        pointer-events: auto;
      `;

      const toolbarText = document.createElement('span');
      toolbarText.textContent = 'Drag to select area, then click Capture';
      toolbarText.style.cssText = `
        color: #333;
        font-size: 14px;
        margin-right: 8px;
      `;

      const captureButton = document.createElement('button');
      captureButton.textContent = 'Capture';
      captureButton.style.cssText = `
        background: #28a745;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
      `;
      captureButton.onmouseover = () => captureButton.style.backgroundColor = '#218838';
      captureButton.onmouseout = () => captureButton.style.backgroundColor = '#28a745';

      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'Cancel';
      cancelButton.style.cssText = `
        background: #dc3545;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
      `;
      cancelButton.onmouseover = () => cancelButton.style.backgroundColor = '#c82333';
      cancelButton.onmouseout = () => cancelButton.style.backgroundColor = '#dc3545';

      const buttonRow = document.createElement('div');
      buttonRow.style.cssText = `
        display: flex;
        gap: 12px;
        align-items: center;
      `;
      buttonRow.appendChild(captureButton);
      buttonRow.appendChild(cancelButton);

      toolbar.appendChild(toolbarText);
      toolbar.appendChild(buttonRow);

      overlayContainer.appendChild(overlayTop);
      overlayContainer.appendChild(overlayBottom);
      overlayContainer.appendChild(overlayLeft);
      overlayContainer.appendChild(overlayRight);
      overlayContainer.appendChild(selectionRect);
      overlayContainer.appendChild(infoDisplay);
      document.body.appendChild(overlayContainer);
      document.body.appendChild(toolbar);

      // Initialize overlay to cover entire screen
      overlayTop.style.height = '100%';
      overlayBottom.style.display = 'none';
      overlayLeft.style.display = 'none';
      overlayRight.style.display = 'none';

      // Prevent body scroll
      const originalOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';

      let isSelecting = false;
      let startX = 0;
      let startY = 0;
      let currentX = 0;
      let currentY = 0;
      let selectedArea = null;

      // Update selection rectangle and overlay sections
      const updateSelection = () => {
        const left = Math.min(startX, currentX);
        const top = Math.min(startY, currentY);
        const width = Math.abs(currentX - startX);
        const height = Math.abs(currentY - startY);

        if (width === 0 || height === 0) {
          // No selection yet, cover entire screen
          overlayTop.style.height = '100%';
          overlayBottom.style.display = 'none';
          overlayLeft.style.display = 'none';
          overlayRight.style.display = 'none';
          selectionRect.style.display = 'none';
          toolbar.style.display = 'none';
          return;
        }

        selectionRect.style.left = left + 'px';
        selectionRect.style.top = top + 'px';
        selectionRect.style.width = width + 'px';
        selectionRect.style.height = height + 'px';
        selectionRect.style.display = 'block';

        // Update overlay sections to create a "hole" in the overlay
        // Top section: from top to selection top
        overlayTop.style.height = top + 'px';
        overlayTop.style.display = top > 0 ? 'block' : 'none';
        
        // Bottom section: from selection bottom to page bottom
        const bottomTop = top + height;
        overlayBottom.style.top = bottomTop + 'px';
        overlayBottom.style.height = (window.innerHeight - bottomTop) + 'px';
        overlayBottom.style.display = bottomTop < window.innerHeight ? 'block' : 'none';
        
        // Left section: from left edge to selection left, between top and bottom of selection
        overlayLeft.style.top = top + 'px';
        overlayLeft.style.left = '0';
        overlayLeft.style.width = left + 'px';
        overlayLeft.style.height = height + 'px';
        overlayLeft.style.display = left > 0 ? 'block' : 'none';
        
        // Right section: from selection right to page right, between top and bottom of selection
        const rightLeft = left + width;
        overlayRight.style.top = top + 'px';
        overlayRight.style.left = rightLeft + 'px';
        overlayRight.style.width = (window.innerWidth - rightLeft) + 'px';
        overlayRight.style.height = height + 'px';
        overlayRight.style.display = rightLeft < window.innerWidth ? 'block' : 'none';

        // Update info display
        infoDisplay.textContent = `${width} √ó ${height}px`;
        infoDisplay.style.left = (left + width / 2 - 40) + 'px';
        infoDisplay.style.top = (top - 30) + 'px';
        infoDisplay.style.display = 'block';

        // Position toolbar outside the selection area
        // Try to place it below the selection, or above if not enough space
        const spaceBelow = window.innerHeight - (top + height);
        const spaceAbove = top;
        const toolbarHeight = 60; // Approximate toolbar height
        
        if (spaceBelow > toolbarHeight + 20) {
          // Place below selection
          toolbar.style.top = (top + height + 20) + 'px';
          toolbar.style.left = (left + width / 2) + 'px';
          toolbar.style.transform = 'translateX(-50%)';
        } else if (spaceAbove > toolbarHeight + 20) {
          // Place above selection
          toolbar.style.top = (top - toolbarHeight - 20) + 'px';
          toolbar.style.left = (left + width / 2) + 'px';
          toolbar.style.transform = 'translateX(-50%)';
        } else {
          // Place to the right of selection
          toolbar.style.top = top + 'px';
          toolbar.style.left = (left + width + 20) + 'px';
          toolbar.style.transform = 'none';
        }
        
        toolbar.style.display = 'flex';

        selectedArea = { left, top, width, height };
      };

      // Mouse event handlers for overlay sections
      const handleMouseDown = (e) => {
        if (e.target === captureButton || e.target === cancelButton || e.target === toolbar || toolbar.contains(e.target)) return;
        isSelecting = true;
        startX = e.clientX;
        startY = e.clientY;
        currentX = e.clientX;
        currentY = e.clientY;
        updateSelection();
      };

      const handleMouseMove = (e) => {
        if (!isSelecting) return;
        currentX = e.clientX;
        currentY = e.clientY;
        updateSelection();
      };

      const handleMouseUp = () => {
        if (isSelecting) {
          isSelecting = false;
        }
      };

      overlayTop.addEventListener('mousedown', handleMouseDown);
      overlayBottom.addEventListener('mousedown', handleMouseDown);
      overlayLeft.addEventListener('mousedown', handleMouseDown);
      overlayRight.addEventListener('mousedown', handleMouseDown);

      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);

      // Capture button click
      captureButton.onclick = async () => {
        if (!selectedArea || selectedArea.width === 0 || selectedArea.height === 0) {
          alert('Please select an area first by dragging on the screen.');
          return;
        }

        try {
          // Disable UI
          captureButton.disabled = true;
          captureButton.textContent = 'Capturing...';
          toolbarText.textContent = 'Capturing screenshot...';

          // Request background script to capture visible tab
          const dataUrl = await new Promise((resolve, reject) => {
            try {
              chrome.runtime.sendMessage(
                { type: 'CAPTURE_VISIBLE_TAB' },
                (response) => {
                  if (chrome.runtime.lastError) {
                    reject({ 
                      error: 'Failed to capture tab', 
                      details: chrome.runtime.lastError.message,
                      code: chrome.runtime.lastError.message 
                    });
                  } else if (response && response.dataUrl) {
                    resolve(response.dataUrl);
                  } else {
                    reject({ 
                      error: 'Failed to capture tab', 
                      details: 'No dataUrl in response',
                      response: response 
                    });
                  }
                }
              );
            } catch (error) {
              reject({ 
                error: 'Failed to send capture request', 
                details: error?.message || String(error),
                originalError: error 
              });
            }
          });
          
          // Create image to get dimensions and crop
          const img = new Image();
          img.onload = async () => {
            try {
              // Create canvas for cropping
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              
              // Account for device pixel ratio
              const dpr = window.devicePixelRatio || 1;
              const scaleX = img.width / window.innerWidth;
              const scaleY = img.height / window.innerHeight;
              
              // Calculate crop coordinates (accounting for scaling)
              const cropX = selectedArea.left * scaleX;
              const cropY = selectedArea.top * scaleY;
              const cropWidth = selectedArea.width * scaleX;
              const cropHeight = selectedArea.height * scaleY;
              
              // Set canvas size to selected area
              canvas.width = cropWidth;
              canvas.height = cropHeight;
              
              // Draw cropped portion
              ctx.drawImage(
                img,
                cropX, cropY, cropWidth, cropHeight,
                0, 0, cropWidth, cropHeight
              );
              
              // Convert to blob
              canvas.toBlob(async (blob) => {
                try {
                  // Convert blob to base64
                  const reader = new FileReader();
                  reader.onloadend = async () => {
                    const base64Data = reader.result;
                    
                    // Get timestamp for filename
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const filename = `screenshot-${timestamp}.png`;
                    
                    // Send to background script for download
                    try {
                      chrome.runtime.sendMessage(
                        {
                          type: 'DOWNLOAD_SCREENSHOT',
                          dataUrl: base64Data,
                          filename: `screenshot/${filename}`
                        },
                        (response) => {
                          if (chrome.runtime.lastError) {
                            console.error('Download error:', chrome.runtime.lastError);
                            // Fallback: try without screenshot folder
                            chrome.runtime.sendMessage(
                              {
                                type: 'DOWNLOAD_SCREENSHOT',
                                dataUrl: base64Data,
                                filename: filename
                              },
                              (fallbackResponse) => {
                                if (chrome.runtime.lastError) {
                                  cleanup();
                                  reject({ 
                                    error: 'Failed to save screenshot', 
                                    details: chrome.runtime.lastError.message,
                                    code: chrome.runtime.lastError.message 
                                  });
                                } else if (fallbackResponse && fallbackResponse.success) {
                                  cleanup();
                                  toolbarText.textContent = `Screenshot saved: ${filename}`;
                                  toolbarText.style.color = '#28a745';
                                  setTimeout(() => {
                                    resolve({ success: true, filename });
                                  }, 1500);
                                } else {
                                  cleanup();
                                  reject({ 
                                    error: 'Failed to save screenshot', 
                                    details: fallbackResponse?.error || 'Unknown error in fallback',
                                    response: fallbackResponse 
                                  });
                                }
                              }
                            );
                          } else if (response && response.success) {
                            cleanup();
                            toolbarText.textContent = `Screenshot saved: ${filename}`;
                            toolbarText.style.color = '#28a745';
                            setTimeout(() => {
                              resolve({ success: true, filename });
                            }, 1500);
                          } else {
                            cleanup();
                            reject({ 
                              error: 'Failed to save screenshot', 
                              details: response?.error || 'Unknown error',
                              response: response 
                            });
                          }
                        }
                      );
                    } catch (error) {
                      cleanup();
                      reject({ 
                        error: 'Failed to send screenshot to background script', 
                        details: error?.message || String(error),
                        originalError: error 
                      });
                    }
                  };
                  reader.readAsDataURL(blob);
                } catch (error) {
                  cleanup();
                  reject({ 
                    error: 'Failed to process screenshot', 
                    details: error?.message || String(error),
                    originalError: error 
                  });
                }
              }, 'image/png');
            } catch (error) {
              cleanup();
              reject({ 
                error: 'Failed to crop screenshot', 
                details: error?.message || String(error),
                originalError: error 
              });
            }
          };
          
          img.onerror = () => {
            cleanup();
            reject({ error: 'Failed to load captured image' });
          };
          
          img.src = dataUrl;
        } catch (error) {
          cleanup();
          // Ensure error is properly formatted
          const errorMessage = error?.message || error?.error || String(error);
          reject({ 
            error: 'Failed to capture screenshot', 
            details: errorMessage,
            originalError: error 
          });
        }
      };

      // Cancel button click
      cancelButton.onclick = () => {
        cleanup();
        reject({ error: 'User cancelled screenshot' });
      };

      // Cleanup function
      const cleanup = () => {
        document.body.style.overflow = originalOverflow;
        if (overlayContainer.parentNode) {
          overlayContainer.remove();
        }
        if (toolbar.parentNode) {
          toolbar.remove();
        }
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };

      // Escape key to cancel
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          cleanup();
          document.removeEventListener('keydown', escapeHandler);
          reject({ error: 'User cancelled screenshot' });
        }
      };
      document.addEventListener('keydown', escapeHandler);
    });
  }

  // --- Full Screen Screenshot Capture Function ---
  async function captureFullScreenScreenshot() {
    try {
      // Request background script to capture visible tab
      const dataUrl = await new Promise((resolve, reject) => {
        chrome.runtime.sendMessage(
          { type: 'CAPTURE_VISIBLE_TAB' },
          (response) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
            } else if (response && response.dataUrl) {
              resolve(response.dataUrl);
            } else {
              reject(new Error('Failed to capture tab'));
            }
          }
        );
      });

      // Get timestamp for filename
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `screenshot-${timestamp}.png`;

      // Send to background script for download
      return new Promise((resolve, reject) => {
        chrome.runtime.sendMessage(
          {
            type: 'DOWNLOAD_SCREENSHOT',
            dataUrl: dataUrl,
            filename: `screenshot/${filename}`
          },
          (response) => {
            if (chrome.runtime.lastError) {
              // Fallback: try without screenshot folder
              chrome.runtime.sendMessage(
                {
                  type: 'DOWNLOAD_SCREENSHOT',
                  dataUrl: dataUrl,
                  filename: filename
                },
                (fallbackResponse) => {
                  if (chrome.runtime.lastError) {
                    reject({ error: 'Failed to save screenshot', details: chrome.runtime.lastError.message });
                  } else {
                    resolve({ success: true, filename });
                  }
                }
              );
            } else if (response && response.success) {
              resolve({ success: true, filename });
            } else {
              reject({ error: 'Failed to save screenshot', details: response?.error || 'Unknown error' });
            }
          }
        );
      });
    } catch (error) {
      throw { error: 'Failed to capture screenshot', details: error };
    }
  }

  // --- Screenshot Modal Function ---
  function showScreenshotModal() {
    return new Promise((resolve, reject) => {
      // Remove any existing screenshot modals
      const existingModal = document.querySelector('[data-screenshot-modal="true"]');
      if (existingModal) {
        existingModal.remove();
      }

      // Create modal overlay (no background overlay when positioned in corner)
      const modalOverlay = document.createElement('div');
      modalOverlay.setAttribute('data-screenshot-modal', 'true');
      modalOverlay.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 999999;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      `;

      // Create modal content
      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
        background: white;
        border-radius: 8px;
        padding: 16px;
        max-width: 320px;
        width: auto;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        text-align: center;
        position: relative;
        transition: transform 0.3s ease;
      `;

      // Create minimize button
      const minimizeButton = document.createElement('button');
      minimizeButton.innerHTML = '‚àí';
      minimizeButton.setAttribute('title', 'Minimize');
      minimizeButton.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        background: #6c757d;
        color: white;
        border: none;
        width: 24px;
        height: 24px;
        border-radius: 4px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
        line-height: 1;
        padding: 0;
      `;
      minimizeButton.onmouseover = () => minimizeButton.style.backgroundColor = '#5a6268';
      minimizeButton.onmouseout = () => minimizeButton.style.backgroundColor = '#6c757d';

      // Create minimized camera icon (initially hidden)
      const cameraIcon = document.createElement('div');
      cameraIcon.setAttribute('data-camera-icon', 'true');
      cameraIcon.innerHTML = 'üì∏';
      cameraIcon.style.cssText = `
        width: 60px;
        height: 60px;
        background: white;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      `;
      cameraIcon.onmouseover = () => {
        cameraIcon.style.transform = 'scale(1.1)';
        cameraIcon.style.boxShadow = '0 6px 16px rgba(0, 0, 0, 0.4)';
      };
      cameraIcon.onmouseout = () => {
        cameraIcon.style.transform = 'scale(1)';
        cameraIcon.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
      };

      // Create icon
      const icon = document.createElement('div');
      icon.innerHTML = 'üì∏';
      icon.style.cssText = `
        font-size: 32px;
        margin-bottom: 8px;
      `;

      // Create title
      const title = document.createElement('h2');
      title.textContent = 'Screenshot Required';
      title.style.cssText = `
        margin: 0 0 8px 0;
        color: #333;
        font-size: 18px;
        font-weight: 600;
      `;

      // Create message
      const messageDiv = document.createElement('div');
      messageDiv.textContent = 'Click "Take Screenshot" to select an area, then click "Done" to resume.';
      messageDiv.style.cssText = `
        color: #666;
        font-size: 13px;
        line-height: 1.4;
        margin-bottom: 12px;
      `;

      // Create status message (initially hidden)
      const statusMessage = document.createElement('div');
      statusMessage.style.cssText = `
        color: #28a745;
        font-size: 12px;
        margin-bottom: 8px;
        min-height: 16px;
        display: none;
      `;

      // Create button container
      const buttonContainer = document.createElement('div');
      buttonContainer.style.cssText = `
        display: flex;
        gap: 8px;
        justify-content: center;
        flex-wrap: wrap;
      `;

      // Create Take Screenshot button
      const screenshotButton = document.createElement('button');
      screenshotButton.textContent = 'Take Screenshot';
      screenshotButton.style.cssText = `
        background: #007bff;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
        min-width: 120px;
      `;
      screenshotButton.onmouseover = () => screenshotButton.style.backgroundColor = '#0056b3';
      screenshotButton.onmouseout = () => screenshotButton.style.backgroundColor = '#007bff';

      // Create Done button
      const continueButton = document.createElement('button');
      continueButton.textContent = 'Done';
      continueButton.style.cssText = `
        background: #28a745;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
        min-width: 90px;
      `;
      continueButton.onmouseover = () => continueButton.style.backgroundColor = '#218838';
      continueButton.onmouseout = () => continueButton.style.backgroundColor = '#28a745';

      // Screenshot button click handler - triggers drag selection
      screenshotButton.onclick = async () => {
        // Minimize modal to allow selection
        minimizeModal();
        
        // Update status
        statusMessage.style.display = 'block';
        statusMessage.textContent = 'Drag to select area...';
        statusMessage.style.color = '#007bff';

        try {
          const result = await captureScreenshotWithSelection();
          if (result && result.success) {
            // Restore modal to show result
            restoreModal();
            statusMessage.textContent = `‚úì Screenshot saved: ${result.filename}`;
            statusMessage.style.color = '#28a745';
            sendSystemNotification("CB-PHAA Screenshot", `Screenshot saved: ${result.filename}`);
          } else {
            restoreModal();
            statusMessage.textContent = '‚ö† Screenshot capture completed with warnings';
            statusMessage.style.color = '#ffc107';
          }
        } catch (error) {
          console.error('Screenshot error:', error);
          restoreModal();
          
          // Handle different error formats
          const errorMessage = error?.error || error?.message || (typeof error === 'string' ? error : 'Unknown error');
          const errorDetails = error?.details || (error?.stack ? error.stack : null);
          
          if (errorMessage === 'User cancelled screenshot') {
            statusMessage.textContent = 'Screenshot cancelled';
            statusMessage.style.color = '#6c757d';
          } else {
            statusMessage.textContent = `‚úó Failed to capture screenshot: ${errorMessage}`;
            statusMessage.style.color = '#dc3545';
            // Log detailed error for debugging
            if (errorDetails) {
              console.error('Screenshot error details:', errorDetails);
            }
          }
        }
      };

      // Assemble modal
      modalContent.appendChild(minimizeButton);
      buttonContainer.appendChild(screenshotButton);
      buttonContainer.appendChild(continueButton);
      modalContent.appendChild(icon);
      modalContent.appendChild(title);
      modalContent.appendChild(messageDiv);
      modalContent.appendChild(statusMessage);
      modalContent.appendChild(buttonContainer);
      modalOverlay.appendChild(modalContent);
      modalOverlay.appendChild(cameraIcon);

      // Add to page
      document.body.appendChild(modalOverlay);

      // State management
      let isMinimized = false;

      // Minimize function
      const minimizeModal = () => {
        isMinimized = true;
        modalContent.style.display = 'none';
        cameraIcon.style.display = 'flex';
        // Allow scrolling when minimized
        document.body.style.overflow = '';
      };

      // Restore function
      const restoreModal = () => {
        isMinimized = false;
        modalContent.style.display = 'block';
        cameraIcon.style.display = 'none';
        // Don't prevent scrolling - allow users to scroll freely
      };

      // Don't prevent body scroll - modal is positioned fixed in corner
      // Allow users to scroll freely while modal is visible

      // Clean up function
      const cleanup = () => {
        if (modalOverlay.parentNode) {
          document.body.removeChild(modalOverlay);
        }
        // Remove scroll listener
        window.removeEventListener('scroll', scrollHandler, true);
      };

      // Scroll handler to minimize modal
      const scrollHandler = () => {
        if (!isMinimized) {
          minimizeModal();
        }
      };

      // Add scroll event listener to minimize on scroll
      window.addEventListener('scroll', scrollHandler, true);

      // Event handlers
      minimizeButton.onclick = (e) => {
        e.stopPropagation();
        minimizeModal();
      };

      cameraIcon.onclick = () => {
        restoreModal();
      };

      continueButton.onclick = () => {
        cleanup();
        resolve({ success: true, action: 'continue' });
      };

      // Prevent closing on overlay click when minimized
      modalOverlay.onclick = (e) => {
        if (e.target === modalOverlay && !isMinimized) {
          // Don't close on overlay click - force user to click a button
        }
      };
    });
  }

  // --- Pause Modal Function ---
  function showPauseModal(step = null) {
    return new Promise((resolve) => {
      // Remove any existing pause modals
      const existingModal = document.querySelector('[data-pause-modal="true"]');
      if (existingModal) {
        existingModal.remove();
      }

      // Get step description, fallback to default message if not available
      const stepDescription = (step && step.description) ? step.description : 'Pause step is triggered and it will only continue if you have pressed the Done button.';

      // Create modal overlay (positioned in corner like screenshot modal)
      const modalOverlay = document.createElement('div');
      modalOverlay.setAttribute('data-pause-modal', 'true');
      modalOverlay.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 999999;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      `;

      // Create modal content
      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
        background: white;
        border-radius: 8px;
        padding: 16px;
        max-width: 320px;
        width: auto;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        text-align: center;
        position: relative;
        transition: transform 0.3s ease;
      `;

      // Create minimize button
      const minimizeButton = document.createElement('button');
      minimizeButton.innerHTML = '‚àí';
      minimizeButton.setAttribute('title', 'Minimize');
      minimizeButton.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        background: #6c757d;
        color: white;
        border: none;
        width: 24px;
        height: 24px;
        border-radius: 4px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
        line-height: 1;
        padding: 0;
      `;
      minimizeButton.onmouseover = () => minimizeButton.style.backgroundColor = '#5a6268';
      minimizeButton.onmouseout = () => minimizeButton.style.backgroundColor = '#6c757d';

      // Create minimized pause icon (initially hidden)
      const pauseIcon = document.createElement('div');
      pauseIcon.setAttribute('data-pause-icon', 'true');
      pauseIcon.innerHTML = '‚è∏Ô∏è';
      pauseIcon.style.cssText = `
        width: 60px;
        height: 60px;
        background: white;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      `;
      pauseIcon.onmouseover = () => {
        pauseIcon.style.transform = 'scale(1.1)';
        pauseIcon.style.boxShadow = '0 6px 16px rgba(0, 0, 0, 0.4)';
      };
      pauseIcon.onmouseout = () => {
        pauseIcon.style.transform = 'scale(1)';
        pauseIcon.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
      };

      // Create icon
      const icon = document.createElement('div');
      icon.innerHTML = '‚è∏Ô∏è';
      icon.style.cssText = `
        font-size: 32px;
        margin-bottom: 8px;
      `;

      // Create title
      const title = document.createElement('h2');
      title.textContent = 'Automation Pause';
      title.style.cssText = `
        margin: 0 0 8px 0;
        color: #333;
        font-size: 18px;
        font-weight: 600;
      `;

      // Create message (from step description)
      const messageDiv = document.createElement('div');
      messageDiv.textContent = stepDescription;
      messageDiv.style.cssText = `
        color: #000;
        font-size: 15px;
        line-height: 1.5;
        margin-bottom: 12px;
      `;

      // Create footer
      const footerDiv = document.createElement('div');
      footerDiv.textContent = 'To resume automation please click done.';
      footerDiv.style.cssText = `
        color: #888;
        font-size: 12px;
        line-height: 1.4;
        margin-bottom: 12px;
        font-style: italic;
      `;

      // Create button container
      const buttonContainer = document.createElement('div');
      buttonContainer.style.cssText = `
        display: flex;
        gap: 8px;
        justify-content: center;
      `;

      // Create Done button
      const doneButton = document.createElement('button');
      doneButton.textContent = 'Done';
      doneButton.style.cssText = `
        background: #28a745;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
        min-width: 90px;
      `;
      doneButton.onmouseover = () => doneButton.style.backgroundColor = '#218838';
      doneButton.onmouseout = () => doneButton.style.backgroundColor = '#28a745';

      // Assemble modal
      modalContent.appendChild(minimizeButton);
      buttonContainer.appendChild(doneButton);
      modalContent.appendChild(icon);
      modalContent.appendChild(title);
      modalContent.appendChild(messageDiv);
      modalContent.appendChild(footerDiv);
      modalContent.appendChild(buttonContainer);
      modalOverlay.appendChild(modalContent);
      modalOverlay.appendChild(pauseIcon);

      // Add to page
      document.body.appendChild(modalOverlay);

      // State management
      let isMinimized = false;

      // Minimize function
      const minimizeModal = () => {
        isMinimized = true;
        modalContent.style.display = 'none';
        pauseIcon.style.display = 'flex';
        // Allow scrolling when minimized
        document.body.style.overflow = '';
      };

      // Restore function
      const restoreModal = () => {
        isMinimized = false;
        modalContent.style.display = 'block';
        pauseIcon.style.display = 'none';
        // Prevent scrolling when modal is visible
        document.body.style.overflow = 'hidden';
      };

      // Prevent body scroll initially
      document.body.style.overflow = 'hidden';

      // Auto-minimize on scroll attempt

      // Add scroll detection listeners
      const scrollHandlers = [];
      
      // Handle wheel events (mouse scroll)
      const wheelHandler = (e) => {
        if (!isMinimized) {
          // Don't minimize if interacting with modal
          if (e.target && modalOverlay.contains(e.target)) {
            return;
          }
          minimizeModal();
        }
      };
      document.addEventListener('wheel', wheelHandler, { passive: true, capture: false });
      scrollHandlers.push({ eventType: 'wheel', handler: wheelHandler });
      
      // Handle touch events (mobile scroll)
      const touchHandler = (e) => {
        if (!isMinimized && e.touches.length > 0) {
          // Don't minimize if touching the modal
          if (e.target && modalOverlay.contains(e.target)) {
            return;
          }
          minimizeModal();
        }
      };
      document.addEventListener('touchstart', touchHandler, { passive: true, capture: false });
      scrollHandlers.push({ eventType: 'touchstart', handler: touchHandler });
      
      // Handle keyboard scroll (arrow keys, page up/down, etc.)
      const keyHandler = (e) => {
        const scrollKeys = ['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', 'Home', 'End'];
        if (scrollKeys.includes(e.key)) {
          if (!isMinimized) {
            minimizeModal();
          }
        }
      };
      document.addEventListener('keydown', keyHandler, { passive: true, capture: false });
      scrollHandlers.push({ eventType: 'keydown', handler: keyHandler });

      // Clean up function
      const cleanup = () => {
        document.body.style.overflow = '';
        // Remove scroll detection listeners
        scrollHandlers.forEach(({ eventType, handler }) => {
          document.removeEventListener(eventType, handler, { capture: false });
        });
        if (modalOverlay.parentNode) {
          document.body.removeChild(modalOverlay);
        }
      };

      // Event handlers
      minimizeButton.onclick = (e) => {
        e.stopPropagation();
        minimizeModal();
      };

      pauseIcon.onclick = () => {
        restoreModal();
      };

      doneButton.onclick = () => {
        cleanup();
        resolve({ success: true, action: 'done' });
      };

      // Prevent closing on overlay click
      modalOverlay.onclick = (e) => {
        if (e.target === modalOverlay && !isMinimized) {
          // Don't close on overlay click - force user to click Done button
        }
      };
    });
  }

  // --- Category Requirement Modal Function (Enhanced UX) ---
  function showCategoryRequirementModal(domain, hasCitation = true) {
    // Remove any existing category modals
    const existingModal = document.querySelector('[data-category-modal="true"]');
    if (existingModal) {
      existingModal.remove();
    }

    // Create modal overlay
    const modalOverlay = document.createElement('div');
    modalOverlay.setAttribute('data-category-modal', 'true');
    modalOverlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.75);
      z-index: 999999;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      animation: fadeIn 0.3s ease;
    `;

    // Add fade-in animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      @keyframes slideUp {
        from { transform: translateY(20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
    `;
    document.head.appendChild(style);

    // Create modal content
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      background: white;
      border-radius: 16px;
      padding: 40px;
      max-width: 550px;
      width: 90%;
      box-shadow: 0 24px 48px rgba(0, 0, 0, 0.4);
      text-align: center;
      position: relative;
      animation: slideUp 0.3s ease;
    `;

    // Create close button
    const closeButton = document.createElement('button');
    closeButton.innerHTML = '√ó';
    closeButton.style.cssText = `
      position: absolute;
      top: 15px;
      right: 20px;
      background: none;
      border: none;
      font-size: 28px;
      cursor: pointer;
      color: #999;
      width: 35px;
      height: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
    `;
    closeButton.onmouseover = () => {
      closeButton.style.backgroundColor = '#f0f0f0';
      closeButton.style.color = '#333';
    };
    closeButton.onmouseout = () => {
      closeButton.style.backgroundColor = 'transparent';
      closeButton.style.color = '#999';
    };

    // Create icon (different for category requirement)
    const icon = document.createElement('div');
    icon.innerHTML = 'üìã';
    icon.style.cssText = `
      font-size: 64px;
      margin-bottom: 20px;
      line-height: 1;
    `;

    // Create title
    const title = document.createElement('h2');
    title.textContent = 'Category Required';
    title.style.cssText = `
      margin: 0 0 12px 0;
      color: #333;
      font-size: 28px;
      font-weight: 700;
    `;

    // Create subtitle
    const subtitle = document.createElement('div');
    subtitle.textContent = 'Main Category Setup Required';
    subtitle.style.cssText = `
      color: #666;
      font-size: 16px;
      margin-bottom: 24px;
      font-weight: 500;
    `;

    // Create message
    const messageDiv = document.createElement('div');
    if (hasCitation) {
      messageDiv.innerHTML = `
        <p style="color: #555; font-size: 16px; line-height: 1.6; margin: 0 0 16px 0;">
          The automation for <strong>${domain}</strong> requires a <strong>Main Category</strong> to be set up in your citation.
        </p>
        <p style="color: #666; font-size: 15px; line-height: 1.6; margin: 0;">
          Please complete the <strong>Main Category</strong> field in your Campaign Citations under Working Data, then refresh this page to continue with automation.
        </p>
      `;
    } else {
      messageDiv.innerHTML = `
        <p style="color: #555; font-size: 16px; line-height: 1.6; margin: 0 0 16px 0;">
          The domain <strong>${domain}</strong> has not been added to your Campaign Citations.
        </p>
        <p style="color: #666; font-size: 15px; line-height: 1.6; margin: 0;">
          Please add this domain to your Campaign Citations and set up the required <strong>Main Category</strong> field, then refresh this page to continue.
        </p>
      `;
    }
    messageDiv.style.cssText = `
      text-align: left;
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 28px;
      border-left: 4px solid #007bff;
    `;

    // Create action buttons container
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    `;

    // Create refresh button (primary)
    const refreshButton = document.createElement('button');
    refreshButton.textContent = 'Refresh Page';
    refreshButton.style.cssText = `
      background: #007bff;
      color: white;
      border: none;
      padding: 14px 32px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
    `;
    refreshButton.onmouseover = () => {
      refreshButton.style.backgroundColor = '#0056b3';
      refreshButton.style.boxShadow = '0 4px 12px rgba(0, 123, 255, 0.4)';
      refreshButton.style.transform = 'translateY(-1px)';
    };
    refreshButton.onmouseout = () => {
      refreshButton.style.backgroundColor = '#007bff';
      refreshButton.style.boxShadow = '0 2px 8px rgba(0, 123, 255, 0.3)';
      refreshButton.style.transform = 'translateY(0)';
    };

    // Create close/cancel button (secondary)
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Close';
    cancelButton.style.cssText = `
      background: #f8f9fa;
      color: #495057;
      border: 2px solid #dee2e6;
      padding: 14px 32px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    `;
    cancelButton.onmouseover = () => {
      cancelButton.style.backgroundColor = '#e9ecef';
      cancelButton.style.borderColor = '#adb5bd';
    };
    cancelButton.onmouseout = () => {
      cancelButton.style.backgroundColor = '#f8f9fa';
      cancelButton.style.borderColor = '#dee2e6';
    };

    // Assemble modal
    buttonContainer.appendChild(refreshButton);
    buttonContainer.appendChild(cancelButton);
    modalContent.appendChild(closeButton);
    modalContent.appendChild(icon);
    modalContent.appendChild(title);
    modalContent.appendChild(subtitle);
    modalContent.appendChild(messageDiv);
    modalContent.appendChild(buttonContainer);
    modalOverlay.appendChild(modalContent);

    // Add to page
    document.body.appendChild(modalOverlay);

    // Event handlers
    let closeModal = () => {
      document.body.style.overflow = '';
      if (modalOverlay.parentNode) {
        document.body.removeChild(modalOverlay);
      }
      if (style.parentNode) {
        document.head.removeChild(style);
      }
    };

    closeButton.onclick = closeModal;
    cancelButton.onclick = closeModal;
    refreshButton.onclick = async () => {
      // Clear completion status for this domain before reloading
      const completionKey = getTabSpecificCompletionKey();
      const resumeKey = getTabSpecificResumeIndexKey();
      console.log(`üîÑ [REFRESH] Clearing completion status for key: ${completionKey}`);
      
      // Reset in-memory automation state first
      if (window.__AUTOMATION_STATE__) {
        window.__AUTOMATION_STATE__.isCompleted = false;
        window.__AUTOMATION_STATE__.status = AutomationStatus.IDLE;
        console.log(`üîÑ [REFRESH] Reset in-memory automation state`);
      }
      
      // Clear completion data and reset resume index, then reload
      return new Promise((resolve) => {
        let operationsCompleted = 0;
        const totalOperations = 2;
        
        const checkComplete = () => {
          operationsCompleted++;
          if (operationsCompleted === totalOperations) {
            console.log(`‚úÖ [REFRESH] All reset operations completed, reloading page...`);
            window.location.reload();
          }
        };
        
        // Clear completion data from chrome.storage.local
        CHROME_API.storage.local.remove([completionKey], () => {
          if (CHROME_API.lastError) {
            console.error(`‚ùå [REFRESH] Error clearing completion status:`, CHROME_API.lastError);
          } else {
            console.log(`‚úÖ [REFRESH] Completion status cleared successfully`);
          }
          checkComplete();
        });
        
        // Reset resume index (domain + current run) to 0
        clearResumeIndex();
        console.log(`‚úÖ [REFRESH] Reset resume index to 0`);
        checkComplete();
      });
    };
    modalOverlay.onclick = (e) => {
      if (e.target === modalOverlay) {
        closeModal();
      }
    };

    // Prevent body scroll
    document.body.style.overflow = 'hidden';

    // Prevent ESC key from closing (keep it visible until user takes action)
    const escHandler = (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
      }
    };
    window.addEventListener('keydown', escHandler, true);
    
    // Clean up ESC handler on close
    const originalCloseModal = closeModal;
    closeModal = () => {
      window.removeEventListener('keydown', escHandler, true);
      originalCloseModal();
    };
  }

  // --- Domain Eligibility Check Function ---
  async function checkDomainEligibility() {
    try {
      console.log(`üîç [DOMAIN_ELIGIBILITY] Checking domain eligibility...`);
      
      // First, check if user is logged in and has credentials
      // Don't show domain configuration popup if user is not logged in or has no credentials
      const authStatus = await new Promise((resolve) => {
        CHROME_API.runtime.sendMessage({ type: "GET_AUTH_STATUS" }, (response) => {
          if (CHROME_API.lastError) {
            console.warn("Auth status fetch error:", CHROME_API.lastError.message);
            // Fallback to storage check
            CHROME_API.storage.local.get(["isLoggedIn", "CampaignData"], (result) => {
              resolve({
                isAuthenticated: result.isLoggedIn || false,
                hasCredentials: !!result.CampaignData
              });
            });
          } else if (response && response.success && response.authStatus) {
            resolve({
              isAuthenticated: response.authStatus.isAuthenticated || response.authStatus.storage?.isLoggedIn || false,
              hasCredentials: response.authStatus.storage?.hasCampaignData || false
            });
          } else {
            // Fallback to storage check
            CHROME_API.storage.local.get(["isLoggedIn", "CampaignData"], (result) => {
              resolve({
                isAuthenticated: result.isLoggedIn || false,
                hasCredentials: !!result.CampaignData
              });
            });
          }
        });
      });

      // Check authentication and credentials
      if (!authStatus.isAuthenticated || !authStatus.hasCredentials) {
        console.log(`‚ö†Ô∏è [DOMAIN_ELIGIBILITY] User is not logged in or has no credentials. Skipping domain eligibility check.`);
        console.log(`üìä [DOMAIN_ELIGIBILITY] Auth status:`, authStatus);
        return {
          eligible: false,
          reason: `User is not logged in or has no credentials`,
          showModal: false // Don't show modal if user is not logged in
        };
      }

      console.log(`‚úÖ [DOMAIN_ELIGIBILITY] User is authenticated and has credentials. Proceeding with domain eligibility check.`);
      
      const originalHostname = window.location.hostname.toLowerCase();
      const currentDomain = extractBaseDomain(originalHostname);
      console.log(`üåê [DOMAIN_ELIGIBILITY] Original hostname: ${originalHostname}`);
      console.log(`üåê [DOMAIN_ELIGIBILITY] Extracted base domain: ${currentDomain}`);
      
      // First, try to get automation for the base domain (e.g., "all.biz" from "welcome.all.biz")
      console.log(`üîç [DOMAIN_ELIGIBILITY] Checking if automation exists for base domain: ${currentDomain}`);
      
      let automationResponse = await new Promise((resolve) => {
        CHROME_API.runtime.sendMessage({ type: "GET_AUTOMATION", domainName: currentDomain }, (response) => {
          if (CHROME_API.lastError) {
            console.warn("Automation fetch error:", CHROME_API.lastError.message);
            resolve(null);
          } else {
            resolve(response);
          }
        });
      });

      // If not found with base domain and original hostname is different, try original hostname
      if ((!automationResponse || !automationResponse.success || !automationResponse.automation) && originalHostname !== currentDomain) {
        console.log(`üîÑ [DOMAIN_ELIGIBILITY] No automation found for base domain ${currentDomain}, trying original hostname: ${originalHostname}`);
        automationResponse = await new Promise((resolve) => {
          CHROME_API.runtime.sendMessage({ type: "GET_AUTOMATION", domainName: originalHostname }, (response) => {
            if (CHROME_API.lastError) {
              console.warn("Automation fetch error:", CHROME_API.lastError.message);
              resolve(null);
            } else {
              resolve(response);
            }
          });
        });
      }

      if (!automationResponse || !automationResponse.success || !automationResponse.automation) {
        console.warn(`‚ùå [DOMAIN_ELIGIBILITY] No automation found for domain: ${currentDomain} (also tried: ${originalHostname})`);
        console.log(`üí° [DOMAIN_ELIGIBILITY] This domain is not configured for automation in automationSteps/automationTask collections`);
        return { 
          eligible: false, 
          reason: `No automation configured for domain: ${currentDomain}`,
          showModal: false // Don't show modal for unsupported domains
        };
      }

      console.log(`‚úÖ [DOMAIN_ELIGIBILITY] Automation found for domain: ${currentDomain}`);
      console.log(`üìö [DOMAIN_ELIGIBILITY] Source collection: ${automationResponse.automation.sourceCollection || 'Unknown'}`);

      // Validate domain authority - check both original hostname and extracted base domain
      const automationDomainName = automationResponse.automation.domainName;
      const isOriginalSupported = isDomainSupported(originalHostname, automationDomainName);
      const isBaseSupported = isDomainSupported(currentDomain, automationDomainName);
      
      if (!isOriginalSupported && !isBaseSupported) {
        console.error(`‚ùå [DOMAIN_ELIGIBILITY] Domain authority validation failed: Current domain "${originalHostname}" (base: "${currentDomain}") does not match automation domainName "${automationDomainName}"`);
        return { 
          eligible: false, 
          reason: `Domain not supported: Current domain "${currentDomain}" does not match automation domainName "${automationDomainName}"` 
        };
      }
      
      if (isOriginalSupported) {
        console.log(`‚úÖ [DOMAIN_ELIGIBILITY] Domain authority validated: Original hostname "${originalHostname}" is supported by automation domainName "${automationDomainName}"`);
      } else if (isBaseSupported) {
        console.log(`‚úÖ [DOMAIN_ELIGIBILITY] Domain authority validated: Base domain "${currentDomain}" is supported by automation domainName "${automationDomainName}"`);
      }

      // Get controller settings to check if categories are required
      // Default to false - only require categories if explicitly set to true
      let requiredCategory = false;
      let domainCitation = null;

      // DEBUG: Log the entire automation object to see what we're working with
      console.log(`üîç [DOMAIN_ELIGIBILITY] Full automation object:`, JSON.stringify(automationResponse.automation, null, 2));
      console.log(`üîç [DOMAIN_ELIGIBILITY] Has controller:`, !!automationResponse.automation.controller);
      
      if (automationResponse.automation.controller) {
        console.log(`üîç [DOMAIN_ELIGIBILITY] Controller object keys:`, Object.keys(automationResponse.automation.controller));
        console.log(`üîç [DOMAIN_ELIGIBILITY] Controller.requiredCategory value:`, automationResponse.automation.controller.requiredCategory);
        console.log(`üîç [DOMAIN_ELIGIBILITY] Controller.requiredCategory === true:`, automationResponse.automation.controller.requiredCategory === true);
        console.log(`üîç [DOMAIN_ELIGIBILITY] Controller.requiredCategory === false:`, automationResponse.automation.controller.requiredCategory === false);
        console.log(`üîç [DOMAIN_ELIGIBILITY] Controller.requiredCategory type:`, typeof automationResponse.automation.controller.requiredCategory);
        console.log(`üîç [DOMAIN_ELIGIBILITY] Controller.requiredCategory is undefined:`, automationResponse.automation.controller.requiredCategory === undefined);
        console.log(`üîç [DOMAIN_ELIGIBILITY] Controller.requiredCategory is null:`, automationResponse.automation.controller.requiredCategory === null);
        console.log(`üîç [DOMAIN_ELIGIBILITY] Controller.requiredCategory string value:`, String(automationResponse.automation.controller.requiredCategory));
        
        // Handle string "false" or "true" values
        const rawValue = automationResponse.automation.controller.requiredCategory;
        let normalizedValue = rawValue;
        
        // Convert string "false" to boolean false
        if (typeof rawValue === 'string') {
          const lowerStr = rawValue.toLowerCase().trim();
          if (lowerStr === 'false' || lowerStr === '0' || lowerStr === '') {
            normalizedValue = false;
            console.log(`üîÑ [DOMAIN_ELIGIBILITY] Converted string "${rawValue}" to boolean false`);
          } else if (lowerStr === 'true' || lowerStr === '1') {
            normalizedValue = true;
            console.log(`üîÑ [DOMAIN_ELIGIBILITY] Converted string "${rawValue}" to boolean true`);
          }
        }
        
        // Only set to true if explicitly set to boolean true (after normalization)
        // If undefined, null, false, string "false", or not set, default to false
        if (normalizedValue === true) {
          requiredCategory = true;
          console.log(`‚úÖ [DOMAIN_ELIGIBILITY] requiredCategory set to TRUE (explicitly set to true)`);
        } else {
          // If undefined, null, false, string "false", or any other value, default to false
          requiredCategory = false;
          console.log(`‚úÖ [DOMAIN_ELIGIBILITY] requiredCategory set to FALSE (raw value: ${rawValue}, normalized: ${normalizedValue}, type: ${typeof rawValue})`);
        }
        console.log(`üéõÔ∏è [DOMAIN_ELIGIBILITY] Final requiredCategory setting: ${requiredCategory}`);
      } else {
        console.log(`üéõÔ∏è [DOMAIN_ELIGIBILITY] No controller found, using default requiredCategory: ${requiredCategory} (false)`);
      }

      // ALWAYS check if domain exists in citations (regardless of requiredCategory)
      // This ensures automation only runs for domains that have been added to Campaign Citations
      console.log(`üîç [DOMAIN_ELIGIBILITY] Checking if domain exists in citations...`);
      
      // First try to get CampaignData from background script (ensures fresh data)
      let campaignData = null;
      try {
        campaignData = await new Promise((resolve) => {
          CHROME_API.runtime.sendMessage({ type: "FETCH_CAMPAIGN_DATA" }, (response) => {
            if (CHROME_API.lastError) {
              console.warn("CampaignData fetch error:", CHROME_API.lastError.message);
              // Fallback to direct storage read
              CHROME_API.storage.local.get(["CampaignData"], (result) => {
                if (CHROME_API.lastError) {
                  console.warn("CampaignData storage error:", CHROME_API.lastError.message);
                  resolve({});
                } else {
                  resolve(result);
                }
              });
            } else if (response && response.CampaignData) {
              console.log("‚úÖ [DOMAIN_ELIGIBILITY] Got CampaignData from background script (via chrome.storage.local)");
              console.log("üì¶ [DOMAIN_ELIGIBILITY] Data source: chrome.storage.local (not IndexedDB)");
              resolve({ CampaignData: response.CampaignData });
            } else {
              // Fallback to direct storage read
              console.log("üì¶ [DOMAIN_ELIGIBILITY] Falling back to direct chrome.storage.local read");
              CHROME_API.storage.local.get(["CampaignData"], (result) => {
                if (CHROME_API.lastError) {
                  console.warn("CampaignData storage error:", CHROME_API.lastError.message);
                  resolve({});
                } else {
                  resolve(result);
                }
              });
            }
          });
        });
      } catch (error) {
        console.warn("Error fetching CampaignData from background, falling back to storage:", error);
        // Fallback to direct storage read
        console.log("üì¶ [DOMAIN_ELIGIBILITY] Falling back to direct chrome.storage.local read (error path)");
        campaignData = await new Promise((resolve) => {
          CHROME_API.storage.local.get(["CampaignData"], (result) => {
            if (CHROME_API.lastError) {
              console.warn("CampaignData storage error:", CHROME_API.lastError.message);
              resolve({});
            } else {
              resolve(result);
            }
          });
        });
      }

      if (!campaignData || !campaignData.CampaignData) {
        console.warn("‚ö†Ô∏è [DOMAIN_ELIGIBILITY] No CampaignData found");
        showDomainEligibilityModal("This domain has not been added to the Campaign Citations under Working Data. Please add the citation and fill in all required fields before proceeding. Once done, refresh this page to continue.");
        
        return { 
          eligible: false, 
          reason: `No campaign data found`,
          showModal: true
        };
      }

      const CampaignData = campaignData.CampaignData;
      console.log(`üìä [DOMAIN_ELIGIBILITY] CampaignData structure:`, CampaignData);

      // Find citations array
      let citations = null;
      if (Array.isArray(CampaignData)) {
        // CampaignData is an array, find the first one with citations
        for (const campaign of CampaignData) {
          if (campaign.citations && Array.isArray(campaign.citations)) {
            citations = campaign.citations;
            break;
          }
        }
      } else if (CampaignData.citations && Array.isArray(CampaignData.citations)) {
        citations = CampaignData.citations;
      } else if (CampaignData.campaignData && CampaignData.campaignData.citations && Array.isArray(CampaignData.campaignData.citations)) {
        citations = CampaignData.campaignData.citations;
      }

      if (!citations || !Array.isArray(citations)) {
        console.warn("‚ö†Ô∏è [DOMAIN_ELIGIBILITY] No citations array found in CampaignData");
        showDomainEligibilityModal("This domain has not been added to the Campaign Citations under Working Data. Please add the citation and fill in all required fields before proceeding. Once done, refresh this page to continue.");
        
        return { 
          eligible: false, 
          reason: `No citations array found in CampaignData`,
          showModal: true
        };
      }

      console.log(`üìã [DOMAIN_ELIGIBILITY] Found ${citations.length} citations`);
      
      // Log all citation sites for debugging
      const citationSites = citations.map(c => c.site).filter(Boolean);
      console.log(`üìã [DOMAIN_ELIGIBILITY] All citation sites in array:`, citationSites);
      console.log(`üîç [DOMAIN_ELIGIBILITY] Looking for domain: "${currentDomain}"`);
      console.log(`üîç [DOMAIN_ELIGIBILITY] Domain comparison - exact match:`, citationSites.includes(currentDomain));
      
      // Check if current domain exists in citations (exact match first)
      domainCitation = citations.find(citation => citation.site === currentDomain);
      
      // If not found, try with www prefix
      if (!domainCitation) {
        const domainWithWww = `www.${currentDomain}`;
        console.log(`üîç [DOMAIN_ELIGIBILITY] Trying with www prefix: "${domainWithWww}"`);
        domainCitation = citations.find(citation => citation.site === domainWithWww);
      }
      
      // If still not found, try case-insensitive match and also try removing www prefix from citation sites
      if (!domainCitation) {
        console.log(`üîç [DOMAIN_ELIGIBILITY] Trying case-insensitive match and www prefix removal...`);
        domainCitation = citations.find(citation => {
          if (!citation.site) return false;
          const citationSite = extractBaseDomain(citation.site);
          return citationSite === currentDomain.toLowerCase();
        });
      }
      
      if (!domainCitation) {
        console.warn(`‚ùå [DOMAIN_ELIGIBILITY] Domain ${currentDomain} not found in citations`);
        console.warn(`‚ùå [DOMAIN_ELIGIBILITY] Available citation sites:`, citationSites);
        showDomainEligibilityModal("This domain has not been added to the Campaign Citations under Working Data. Please add the citation and fill in all required fields before proceeding. Once done, refresh this page to continue.");
        
        return { 
          eligible: false, 
          reason: `Domain ${currentDomain} not found in campaign citations`,
          showModal: true,
          categoryInfo: {
            required: requiredCategory,
            domainNotFound: true
          }
        };
      }

      console.log(`‚úÖ [DOMAIN_ELIGIBILITY] Domain found in citations:`, domainCitation);

      // Now check categories if requiredCategory is true
      // Note: domainCitation is already found above, so we just need to validate categories
      if (requiredCategory) {
        console.log(`üîç [DOMAIN_ELIGIBILITY] Categories are required, validating from domainCitation...`);

        // --- REFACTORED: Enhanced Category Validation with Proper Trimming ---
        // Normalize category field names (handle both camelCase and lowercase)
        const rawMainCategory = domainCitation.mainCategory || domainCitation.maincategory || '';
        const rawSubCategory = domainCitation.subCategory || domainCitation.subcategory || '';
        
        // Trim and validate mainCategory (fixes whitespace-only issue)
        const mainCategory = typeof rawMainCategory === 'string' ? rawMainCategory.trim() : '';
        const subCategory = typeof rawSubCategory === 'string' ? rawSubCategory.trim() : '';

        console.log(`üìã [DOMAIN_ELIGIBILITY] Category validation (refactored):`, {
          requiredCategory,
          rawMainCategory: rawMainCategory || 'Not set',
          mainCategory: mainCategory || 'Not set (after trim)',
          rawSubCategory: rawSubCategory || 'Not set',
          subCategory: subCategory || 'Not set (after trim)',
          mainCategoryValid: mainCategory.length > 0,
          subCategoryValid: subCategory.length > 0
        });

        // Only check mainCategory if requiredCategory is true
        // Double-check requiredCategory is actually boolean true (not truthy string or other value)
        const isRequiredCategoryTrue = requiredCategory === true && typeof requiredCategory === 'boolean';
        
        console.log(`üîç [DOMAIN_ELIGIBILITY] Category check - requiredCategory: ${requiredCategory}, isRequiredCategoryTrue: ${isRequiredCategoryTrue}, type: ${typeof requiredCategory}`);
        
        if (isRequiredCategoryTrue) {
          // Validate mainCategory is present and not empty after trimming
          if (!mainCategory || mainCategory.length === 0) {
            console.warn(`‚ùå [DOMAIN_ELIGIBILITY] Missing or empty mainCategory for domain ${currentDomain}`);
            console.warn(`   ‚Ä¢ Raw value: "${rawMainCategory}"`);
            console.warn(`   ‚Ä¢ After trim: "${mainCategory}"`);
            console.warn(`   ‚Ä¢ Required because requiredCategory = true (verified as boolean true)`);
            
            // Show enhanced category requirement modal with better UX
            showCategoryRequirementModal(currentDomain, true);
            
            return { 
              eligible: false, 
              reason: `Missing required mainCategory for domain ${currentDomain} (empty or whitespace-only)`,
              showModal: true,
              categoryInfo: {
                required: true,
                mainCategory: mainCategory,
                subCategory: subCategory,
                rawMainCategory: rawMainCategory
              }
            };
          } else {
            // Main category is present and valid - proceed with automation
            console.log(`‚úÖ [DOMAIN_ELIGIBILITY] Main category validated successfully: "${mainCategory}"`);
            console.log(`   ‚Ä¢ Category is present and non-empty after trimming`);
            console.log(`   ‚Ä¢ Automation can proceed`);
          }
        } else {
          console.log(`‚ÑπÔ∏è [DOMAIN_ELIGIBILITY] Categories not required (requiredCategory = ${requiredCategory}, type: ${typeof requiredCategory})`);
          console.log(`‚ÑπÔ∏è [DOMAIN_ELIGIBILITY] Skipping category validation - automation can proceed without categories`);
        }

        // subCategory is always optional, but log status for debugging
        if (subCategory && subCategory.length > 0) {
          console.log(`‚úÖ [DOMAIN_ELIGIBILITY] SubCategory is set: "${subCategory}" (optional)`);
        } else {
          console.log(`‚ÑπÔ∏è [DOMAIN_ELIGIBILITY] SubCategory not set for domain ${currentDomain} (optional - not required)`);
        }
      } else {
        console.log(`‚ÑπÔ∏è [DOMAIN_ELIGIBILITY] Categories not required for this domain (requiredCategory = false)`);
      }

      console.log(`‚úÖ [DOMAIN_ELIGIBILITY] Domain eligibility check passed`);
      console.log(`   ‚Ä¢ Domain: ${currentDomain}`);
      console.log(`   ‚Ä¢ Automation exists: Yes`);
      console.log(`   ‚Ä¢ Source collection: ${automationResponse.automation.sourceCollection || 'Unknown'}`);
      console.log(`   ‚Ä¢ requiredCategory: ${requiredCategory}`);
      console.log(`   ‚Ä¢ mainCategory: ${domainCitation ? (domainCitation.mainCategory || domainCitation.maincategory || 'Not required') : 'Not required'}`);
      console.log(`   ‚Ä¢ subCategory: ${domainCitation ? (domainCitation.subCategory || domainCitation.subcategory || 'Not set (optional)') : 'Not set (optional)'}`);

      return { 
        eligible: true, 
        reason: "Domain is eligible and has automation configured",
        domainCitation: domainCitation,
        requiredCategory: requiredCategory,
        automation: automationResponse.automation
      };

    } catch (error) {
      console.error("‚ùå [DOMAIN_ELIGIBILITY] Error checking domain eligibility:", error);
      return { 
        eligible: false, 
        reason: `Error checking domain eligibility: ${error.message}` 
      };
    }
  }

  // --- Eligibility Check Function ---
  async function checkUserEligibility() {
    try {
      console.log(`üîç [ELIGIBILITY] Starting comprehensive eligibility check...`);
      
      // Check basic eligibility via background script
      const eligibilityResponse = await new Promise((resolve) => {
        CHROME_API.runtime.sendMessage({ type: "CHECK_ELIGIBILITY" }, (response) => {
          if (CHROME_API.lastError) {
            console.warn("Chrome runtime error during eligibility check:", CHROME_API.lastError.message);
            resolve({ eligible: false, reason: "Extension communication error" });
          } else {
            resolve(response);
          }
        });
      });

      if (!eligibilityResponse || !eligibilityResponse.eligible) {
        return {
          eligible: false,
          reason: eligibilityResponse?.reason || "Unknown eligibility error",
          citationsRemaining: 0
        };
      }

      // Get user data for citation calculation
      const userData = await new Promise((resolve) => {
        CHROME_API.storage.local.get(["userId", "plan_subscribers", "user_roles"], (result) => {
          if (CHROME_API.lastError) {
            console.warn("Storage error during user data retrieval:", CHROME_API.lastError.message);
            resolve({});
          } else {
            resolve(result);
          }
        });
      });

      const { userId, plan_subscribers, user_roles } = userData;

      if (!userId) {
        return {
          eligible: false,
          reason: "User ID not found",
          citationsRemaining: 0
        };
      }

      // Calculate citation usage
      let totalCitations = 0;
      let usedCitations = 0;
      let citationsRemaining = 0;

      if (plan_subscribers && plan_subscribers.plans) {
        // Get total citations from plan
        totalCitations = plan_subscribers.plans.citations || 0;
        
        // Get used citations from user data
        const citationData = await new Promise((resolve) => {
          CHROME_API.storage.local.get([`citations_${userId}`], (result) => {
            if (CHROME_API.lastError) {
              console.warn("Storage error during citation data retrieval:", CHROME_API.lastError.message);
              resolve({});
            } else {
              resolve(result);
            }
          });
        });

        usedCitations = citationData[`citations_${userId}`] || 0;
        citationsRemaining = Math.max(0, totalCitations - usedCitations);
      }

      console.log(`üìä [ELIGIBILITY] Citation calculation:`, {
        totalCitations,
        usedCitations,
        citationsRemaining,
        planStatus: plan_subscribers?.status,
        userRole: user_roles?.role
      });

      // Check if user has remaining citations
      if (citationsRemaining <= 0) {
        return {
          eligible: false,
          reason: `No citations remaining (${usedCitations}/${totalCitations} used)`,
          citationsRemaining: 0,
          totalCitations,
          usedCitations
        };
      }

      return {
        eligible: true,
        reason: eligibilityResponse.reason || "User is eligible",
        citationsRemaining,
        totalCitations,
        usedCitations,
        planStatus: plan_subscribers?.status,
        userRole: user_roles?.role
      };

    } catch (error) {
      console.error("‚ùå [ELIGIBILITY] Error during eligibility check:", error);
      return {
        eligible: false,
        reason: `Eligibility check failed: ${error.message}`,
        citationsRemaining: 0
      };
    }
  }


  // --- Manual Eligibility Check Function (for popup/UI) ---
  async function performManualEligibilityCheck() {
    try {
      console.log(`üîç [MANUAL] Performing manual eligibility check...`);
      
      // Check domain eligibility first
      const domainEligibilityResult = await checkDomainEligibility();
      if (!domainEligibilityResult.eligible) {
        return domainEligibilityResult;
      }
      
      const eligibilityResult = await checkUserEligibility();
      
      // Show toast notification only
      
      // Also show toast notification
      if (eligibilityResult.eligible) {
        showToast(`‚úÖ Eligible: ${eligibilityResult.citationsRemaining} citations remaining`);
      } else {
        const message = eligibilityResult.citationsRemaining === 0 && eligibilityResult.totalCitations > 0 
          ? `‚ùå No Citations Remaining (${eligibilityResult.usedCitations}/${eligibilityResult.totalCitations} used)`
          : `‚ùå Not Eligible: ${eligibilityResult.reason}`;
        showToast(message);
      }
      
      return eligibilityResult;
      
    } catch (error) {
      console.error("‚ùå [MANUAL] Error during manual eligibility check:", error);
      showToast("‚ùå Error checking eligibility");
      return {
        eligible: false,
        reason: "Error during eligibility check",
        citationsRemaining: 0
      };
    }
  }

  // --- Checkpoint System Functions ---
  /** Check if campaignData.citation[domain].citationscheckpoint is true for the given domain */
  function hasCitationsCheckpointForDomain(CampaignData, domain) {
    if (!CampaignData || !domain) return false;
    const domainNorm = domain.toLowerCase().replace(/^www\./, '');
    const check = (obj) => obj && typeof obj === 'object' && (obj.citationscheckpoint === true || obj.citationscheckpoint === 'true');
    const findIn = (obj) => {
      if (!obj || typeof obj !== 'object') return false;
      if (obj[domain] && check(obj[domain])) return true;
      if (obj[`www.${domain}`] && check(obj[`www.${domain}`])) return true;
      for (const k of Object.keys(obj)) {
        const keyDomain = (k || '').toLowerCase().replace(/^www\./, '');
        if (keyDomain === domainNorm && check(obj[k])) return true;
      }
      return false;
    };
    if (findIn(CampaignData.citation)) return true;
    if (CampaignData.campaignData && findIn(CampaignData.campaignData.citation)) return true;
    if (CampaignData.citations && typeof CampaignData.citations === 'object' && !Array.isArray(CampaignData.citations) && findIn(CampaignData.citations)) return true;
    if (CampaignData.campaignData && CampaignData.campaignData.citations && typeof CampaignData.campaignData.citations === 'object' && !Array.isArray(CampaignData.campaignData.citations) && findIn(CampaignData.campaignData.citations)) return true;
    return false;
  }

  async function findCheckpointStep(steps) {
    try {
      console.log(`üîç [CHECKPOINT] Searching for checkpoint action in ${steps.length} steps...`);
      
      for (let i = 0; i < steps.length; i++) {
        const step = steps[i];
        // Look for step with action: "checkpoint"
        if (step.action === "checkpoint") {
          console.log(`‚úÖ [CHECKPOINT] Found checkpoint action at step ${i}:`, {
            action: step.action,
            selector: step.selector,
            label: step.label,
            valueKey: step.valueKey
          });
          return {
            stepIndex: i,
            step: step,
            found: true
          };
        }
      }
      
      console.log(`‚ö†Ô∏è [CHECKPOINT] No checkpoint action found in ${steps.length} steps`);
      return {
        stepIndex: -1,
        step: null,
        found: false
      };
      
    } catch (error) {
      console.error("‚ùå [CHECKPOINT] Error finding checkpoint:", error);
      return {
        stepIndex: -1,
        step: null,
        found: false
      };
    }
  }

  async function checkCitationUpdateStatus(domain) {
    try {
      console.log(`üîç [CITATION] Checking citation update status for domain: ${domain}`);
      
      // Get current citation data
      const citationData = await new Promise((resolve) => {
        CHROME_API.storage.local.get([`citations_${domain}`, `citation_status_${domain}`], (result) => {
          if (CHROME_API.lastError) {
            console.warn("Storage error during citation status check:", CHROME_API.lastError.message);
            resolve({});
          } else {
            resolve(result);
          }
        });
      });

      const currentCitationCount = citationData[`citations_${domain}`] || 0;
      const lastStatus = citationData[`citation_status_${domain}`] || 'unknown';
      
      console.log(`üìä [CITATION] Current citation data:`, {
        domain,
        currentCitationCount,
        lastStatus
      });

      // Check if citation status has been updated (this would be set by the background script)
      const statusUpdateKey = `citation_updated_${domain}`;
      const statusUpdateData = await new Promise((resolve) => {
        CHROME_API.storage.local.get([statusUpdateKey], (result) => {
          if (CHROME_API.lastError) {
            console.warn("Storage error during status update check:", CHROME_API.lastError.message);
            resolve({});
          } else {
            resolve(result);
          }
        });
      });

      const isUpdated = statusUpdateData[statusUpdateKey] === true;
      
      if (isUpdated) {
        console.log(`üîÑ [CITATION] Citation status updated for domain: ${domain}`);
        // Clear the update flag
        CHROME_API.storage.local.remove([statusUpdateKey], () => {
          console.log(`üßπ [CITATION] Cleared citation update flag for domain: ${domain}`);
        });
      }

      return {
        isUpdated,
        currentCitationCount,
        lastStatus,
        domain
      };

    } catch (error) {
      console.error("‚ùå [CITATION] Error checking citation update status:", error);
      return {
        isUpdated: false,
        currentCitationCount: 0,
        lastStatus: 'error',
        domain
      };
    }
  }

  function showCheckpointModal(checkpointInfo, citationInfo) {
    return new Promise((resolve) => {
      try {
        // Remove any existing modal
        const existingModal = document.getElementById('checkpoint-modal');
        if (existingModal) {
          existingModal.remove();
        }

        const modal = DOM_UTILS.createElement('div');
        modal.id = 'checkpoint-modal';
        
        // Modal backdrop with improved styling
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.6);
          backdrop-filter: blur(4px);
          z-index: 10000;
          display: flex;
          align-items: center;
          justify-content: center;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
          animation: fadeIn 0.2s ease-in;
        `;

        // Add fade-in animation
        const style = document.createElement('style');
        style.textContent = `
          @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
          }
          @keyframes slideUp {
            from { 
              opacity: 0;
              transform: translateY(20px);
            }
            to { 
              opacity: 1;
              transform: translateY(0);
            }
          }
        `;
        document.head.appendChild(style);

        // Modal content with improved design
        const modalContent = DOM_UTILS.createElement('div');
        modalContent.style.cssText = `
          background: white;
          border-radius: 16px;
          padding: 0;
          max-width: 550px;
          width: 90%;
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
          overflow: hidden;
          animation: slideUp 0.3s ease-out;
        `;

        // Header section with icon
        const header = DOM_UTILS.createElement('div');
        header.style.cssText = `
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          padding: 24px;
          text-align: center;
          color: white;
        `;

        // Icon/Emoji for checkpoint
        const icon = DOM_UTILS.createElement('div');
        icon.style.cssText = `
          font-size: 48px;
          margin-bottom: 12px;
        `;
        icon.textContent = 'üéØ';

        const title = DOM_UTILS.createElement('h3');
        title.style.cssText = `
          margin: 0;
          color: white;
          font-size: 24px;
          font-weight: 700;
          letter-spacing: -0.5px;
        `;
        title.textContent = 'Checkpoint Reached';

        header.appendChild(icon);
        header.appendChild(title);

        // Body section
        const body = DOM_UTILS.createElement('div');
        body.style.cssText = `
          padding: 28px;
        `;

        // Step number badge
        const stepBadge = DOM_UTILS.createElement('div');
        stepBadge.style.cssText = `
          display: inline-block;
          background: #f0f4ff;
          color: #667eea;
          padding: 6px 14px;
          border-radius: 20px;
          font-size: 13px;
          font-weight: 600;
          margin-bottom: 20px;
        `;
        stepBadge.textContent = `Step ${checkpointInfo.stepIndex + 1}`;

        // Description content (from step.description)
        const description = DOM_UTILS.createElement('div');
        description.style.cssText = `
          color: #333;
          font-size: 16px;
          line-height: 1.6;
          margin-bottom: 24px;
          min-height: 60px;
        `;
        
        // Use step.description if available, otherwise use default message
        const stepDescription = checkpointInfo.step && checkpointInfo.step.description 
          ? checkpointInfo.step.description.trim() 
          : `You have reached a checkpoint at step ${checkpointInfo.stepIndex + 1}. Do you want to proceed from this checkpoint? All steps prior to this checkpoint will be skipped, and automation will continue from step ${checkpointInfo.stepIndex + 1} until completion.`;
        
        description.textContent = stepDescription;

        // Info box
        const infoBox = DOM_UTILS.createElement('div');
        infoBox.style.cssText = `
          background: #f8f9fa;
          border-left: 4px solid #667eea;
          border-radius: 8px;
          padding: 16px;
          margin-bottom: 24px;
        `;

        const infoText = DOM_UTILS.createElement('div');
        infoText.style.cssText = `
          font-size: 14px;
          color: #666;
          line-height: 1.5;
        `;
        infoText.innerHTML = `
          <strong>What happens next?</strong><br/>
          If you click "Yes, Continue", the automation will proceed from step ${checkpointInfo.stepIndex + 1} and continue until all remaining steps are completed.
        `;

        infoBox.appendChild(infoText);

        body.appendChild(stepBadge);
        body.appendChild(description);
        body.appendChild(infoBox);

        // Buttons container
        const buttonsContainer = DOM_UTILS.createElement('div');
        buttonsContainer.style.cssText = `
          display: flex;
          gap: 12px;
          justify-content: flex-end;
          padding: 0 28px 28px 28px;
        `;

        // No button (Cancel)
        const noButton = DOM_UTILS.createElement('button');
        noButton.style.cssText = `
          background: #f5f5f5;
          color: #666;
          border: 1px solid #e0e0e0;
          padding: 12px 28px;
          border-radius: 8px;
          font-size: 15px;
          font-weight: 500;
          cursor: pointer;
          min-width: 120px;
          transition: all 0.2s ease;
        `;
        noButton.textContent = 'Cancel';

        // Yes button (Continue)
        const yesButton = DOM_UTILS.createElement('button');
        yesButton.style.cssText = `
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border: none;
          padding: 12px 28px;
          border-radius: 8px;
          font-size: 15px;
          font-weight: 600;
          cursor: pointer;
          min-width: 120px;
          transition: all 0.2s ease;
          box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        `;
        yesButton.textContent = 'Yes, Continue';

        // Button hover effects
        yesButton.addEventListener('mouseenter', () => {
          yesButton.style.transform = 'translateY(-2px)';
          yesButton.style.boxShadow = '0 6px 16px rgba(102, 126, 234, 0.5)';
        });
        yesButton.addEventListener('mouseleave', () => {
          yesButton.style.transform = 'translateY(0)';
          yesButton.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.4)';
        });

        noButton.addEventListener('mouseenter', () => {
          noButton.style.background = '#eeeeee';
          noButton.style.borderColor = '#d0d0d0';
        });
        noButton.addEventListener('mouseleave', () => {
          noButton.style.background = '#f5f5f5';
          noButton.style.borderColor = '#e0e0e0';
        });

        // Event handlers
        yesButton.addEventListener('click', () => {
          modal.remove();
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
          resolve({ proceed: true, checkpointIndex: checkpointInfo.stepIndex });
        });

        noButton.addEventListener('click', () => {
          modal.remove();
          if (style.parentNode) {
            style.parentNode.removeChild(style);
          }
          resolve({ proceed: false, checkpointIndex: -1 });
        });

        // Close on backdrop click
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.remove();
            if (style.parentNode) {
              style.parentNode.removeChild(style);
            }
            resolve({ proceed: false, checkpointIndex: -1 });
          }
        });

        // Prevent modal content clicks from closing
        modalContent.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Assemble modal
        modalContent.appendChild(header);
        modalContent.appendChild(body);
        buttonsContainer.appendChild(noButton);
        buttonsContainer.appendChild(yesButton);
        modalContent.appendChild(buttonsContainer);
        modal.appendChild(modalContent);
        DOM_UTILS.appendChild(document.body, modal);

        console.log(`üì¢ [MODAL] Checkpoint modal displayed for step ${checkpointInfo.stepIndex} with description: "${stepDescription.substring(0, 50)}..."`);

      } catch (error) {
        console.error("‚ùå [MODAL] Error showing checkpoint modal:", error);
        resolve({ proceed: false, checkpointIndex: -1 });
      }
    });
  }

  // --- Manual Checkpoint Check Function (for popup/UI) ---
  async function checkCheckpointStatus() {
    try {
      console.log(`üéØ [MANUAL] Performing manual checkpoint check...`);
      
      const domain = extractBaseDomain(window.location.hostname);
      
      // Load steps to find checkpoint
      const steps = await loadSteps();
      if (!steps || steps.length === 0) {
        return {
          found: false,
          reason: "No automation steps found",
          checkpointIndex: -1
        };
      }
      
      // Find checkpoint
      const checkpointInfo = await findCheckpointStep(steps);
      
      if (!checkpointInfo.found) {
        return {
          found: false,
          reason: "No checkpoint found in automation steps",
          checkpointIndex: -1
        };
      }
      
      // Check citation update status
      const citationInfo = await checkCitationUpdateStatus(domain);
      
      return {
        found: true,
        checkpointIndex: checkpointInfo.stepIndex,
        step: checkpointInfo.step,
        citationUpdated: citationInfo.isUpdated,
        citationInfo: citationInfo,
        domain: domain
      };
      
    } catch (error) {
      console.error("‚ùå [MANUAL] Error during checkpoint check:", error);
      return {
        found: false,
        reason: "Error during checkpoint check",
        checkpointIndex: -1,
        error: error.message
      };
    }
  }

  // --- Main Automation Logic ---
  async function runAutomation(freshStart = false, options = {}) {
    console.log(`üöÄ [DEBUG] ===== AUTOMATION STARTED =====`);
    console.log(`   ‚Ä¢ Fresh start: ${freshStart}`);
    console.log(`   ‚Ä¢ Current URL: ${window.location.href}`);
    console.log(`   ‚Ä¢ Page title: ${document.title}`);
    console.log(`   ‚Ä¢ Timestamp: ${new Date().toISOString()}`);
    
    // Check domain eligibility first
    console.log(`üîç [DOMAIN_ELIGIBILITY] Checking domain eligibility before automation...`);
    const domainEligibilityCheck = await checkDomainEligibility();
    
    if (!domainEligibilityCheck.eligible) {
      console.log(`‚ùå [DOMAIN_ELIGIBILITY] Domain not eligible: ${domainEligibilityCheck.reason}`);
      
      updateAutomationStatus(AutomationStatus.ABORTED, {
        error: `Domain eligibility check failed: ${domainEligibilityCheck.reason}`,
        endTime: new Date()
      });
      return;
    }
    
    // Store requiredCategory setting for use during step execution
    window.__AUTOMATION_REQUIRED_CATEGORY__ = domainEligibilityCheck.requiredCategory || false;
    console.log(`üìã [AUTOMATION] Stored requiredCategory setting: ${window.__AUTOMATION_REQUIRED_CATEGORY__}`);
    
    // Check user eligibility after domain eligibility passes
    console.log(`üîç [ELIGIBILITY] Checking user eligibility before automation...`);
    const eligibilityCheck = await checkUserEligibility();
    
    if (!eligibilityCheck.eligible) {
      console.log(`‚ùå [ELIGIBILITY] User not eligible: ${eligibilityCheck.reason}`);
      
      // Show detailed ineligibility notification
      const notificationMessage = eligibilityCheck.citationsRemaining === 0 && eligibilityCheck.totalCitations > 0 
        ? `‚ùå No Citations Remaining (${eligibilityCheck.usedCitations}/${eligibilityCheck.totalCitations} used)`
        : `‚ùå Not Eligible: ${eligibilityCheck.reason}`;
      
      showToast(notificationMessage);
      
      updateAutomationStatus(AutomationStatus.ABORTED, {
        error: `Eligibility check failed: ${eligibilityCheck.reason}`,
        endTime: new Date()
      });
      return;
    }
    
    console.log(`‚úÖ [ELIGIBILITY] User is eligible: ${eligibilityCheck.reason}`);
    console.log(`üìä [ELIGIBILITY] Citation status: ${eligibilityCheck.citationsRemaining} remaining`);
    
    // Show eligibility success notification with citation info
    showToast(`‚úÖ Eligible: ${eligibilityCheck.citationsRemaining} citations remaining`);
    
    // Check if automation is already completed for this domain (unless fresh start)
    if (!freshStart) {
      const completionKey = getTabSpecificCompletionKey();
      const completionResult = await chrome.storage.local.get([completionKey]);
      const completionData = completionResult[completionKey];
      
      if (completionData && completionData.completed) {
        console.log(`üèÅ [COMPLETION] Automation already completed for this domain`);
        console.log(`   ‚Ä¢ Completed at: ${completionData.completedAt}`);
        console.log(`   ‚Ä¢ Domain: ${completionData.domain}`);
        console.log(`   ‚Ä¢ Total steps: ${completionData.totalSteps}`);
        console.log(`   ‚Ä¢ Final URL: ${completionData.finalUrl}`);
        console.log(`‚è≠Ô∏è [COMPLETION] Skipping automation start - already completed`);
        
        // Show completion message
        showToast('Automation Already Completed');
        updateAutomationStatus(AutomationStatus.COMPLETED, {
          endTime: new Date(completionData.completedAt),
          isCompleted: true,
          currentStep: completionData.totalSteps
        });
        
        return;
      }
    }
    
    console.log(`   ‚Ä¢ User agent: ${navigator.userAgent.substring(0, 100)}...`);
    console.log(`üîß [DEBUG] Multiple valueKey support enabled - use format: "key1 + key2 + key3" (separated by ", ")`);
    
    // Initialize tab ID
    await getCurrentTabId();
    console.log(`üè∑Ô∏è [DOMAIN] Running automation for domain: ${extractBaseDomain(window.location.hostname)}`);
    
    // Check if automation is already running (prevent multiple instances)
    if (automationRunning || automationStarting) {
      console.log(`‚ö†Ô∏è Automation already running/starting, skipping auto-start`);
      return;
    }
    
    // Update status to starting
    updateAutomationStatus(AutomationStatus.STARTING, {
      startTime: new Date(),
      domain: extractBaseDomain(window.location.hostname),
      sessionId: Date.now().toString()
    });
    
    
    automationRunning = true;
    automationStarting = false;
    
    if (freshStart) {
      // Clear both resume index (domain + current run) and completion flag for fresh start
      clearResumeIndex();
      console.log(`üîÑ Fresh start: Reset resume index to 0 (domain + current run)`);
      const completionKey = getTabSpecificCompletionKey();
      chrome.storage.local.remove([completionKey], () => {
        console.log(`üîÑ Fresh start: Cleared completion flag for domain: ${extractBaseDomain(window.location.hostname)}`);
      });
    }
    const steps = await loadSteps();
    window.automationSteps = steps; // Make steps available globally for indicator
    if (!steps || steps.length === 0) {
      console.warn("‚ùå No automation steps found for this domain.");
      automationRunning = false;
      automationStarting = false;
      reportAutomationStatus({ isRunning: false, status: 'error', error: 'No automation steps found' });
      
      // Remove progress indicator if no steps are available
      const progressIndicator = document.getElementById('automation-progress');
      if (progressIndicator) {
        progressIndicator.remove();
        console.log("üóëÔ∏è Progress indicator removed - no automation steps available");
      }
      
      return;
    }
    
    // Create progress indicator now that we have steps
    createProgressIndicator();
    console.log(`üìä Progress indicator created for ${steps.length} steps`);
    
    // --- CHECKPOINT SYSTEM INTEGRATION ---
    const domain = extractBaseDomain(window.location.hostname);
    
    // First, check CampaignData.citation for citationscheckpoint flag
    let shouldStartAtCheckpoint = false;
    let checkpointDisabledByCitation = false;
    window.__CHECKPOINT_DISABLED__ = false;
    window.__CHECKPOINT_ALLOWED__ = true;
    try {
      const { CampaignData = {} } = await new Promise((resolve) => {
        CHROME_API.storage.local.get(["CampaignData"], (result) => {
          if (CHROME_API.lastError) {
            console.warn("Storage error during citationscheckpoint check:", CHROME_API.lastError.message);
            resolve({});
          } else {
            resolve(result);
          }
        });
      });
      
      console.log(`üîç [CHECKPOINT] Checking CampaignData for citationscheckpoint flag for domain: ${domain}...`);
      
      // Helper function to check if a citation object has citationscheckpoint flag
      const checkCitationCheckpoint = (citationObj, source) => {
        if (citationObj && typeof citationObj === 'object') {
          if (citationObj.citationscheckpoint === true || citationObj.citationscheckpoint === "true") {
            if (!checkpointDisabledByCitation) {
              shouldStartAtCheckpoint = true;
              console.log(`‚úÖ [CHECKPOINT] Found citationscheckpoint: true in ${source}`);
            } else {
              console.log(`‚ÑπÔ∏è [CHECKPOINT] citationscheckpoint true ignored due to explicit false in ${source}`);
            }
            return true;
          }
          if (citationObj.citationscheckpoint === false || citationObj.citationscheckpoint === "false") {
            checkpointDisabledByCitation = true;
            shouldStartAtCheckpoint = false;
            console.log(`üõë [CHECKPOINT] Found citationscheckpoint: false in ${source} - skipping checkpoint`);
            return true;
          }
        }
        return false;
      };
      
      // Helper function to find citation matching current domain
      const findDomainCitation = (citationsArray) => {
        if (!citationsArray || !Array.isArray(citationsArray)) return null;
        
        // Find citation for current domain using consistent domain extraction
        return citationsArray.find(citation => {
          if (!citation.site) return false;
          const citationSite = extractBaseDomain(citation.site);
          return citationSite === domain;
        });
      };

      const findDomainCitationInObject = (citationsObj) => {
        if (!citationsObj || typeof citationsObj !== 'object') return null;
        if (citationsObj[domain]) return citationsObj[domain];
        if (citationsObj[`www.${domain}`]) return citationsObj[`www.${domain}`];
        const matchKey = Object.keys(citationsObj).find((key) => {
          const normalizedKey = key.toLowerCase();
          const keyDomain = extractBaseDomain(key);
          return keyDomain === domain || normalizedKey === domain || normalizedKey === `www.${domain}`;
        });
        if (matchKey) return citationsObj[matchKey];
        const values = Object.values(citationsObj).filter((value) => value && typeof value === 'object');
        return values.find((value) => {
          if (!value.site) return false;
          const citationSite = extractBaseDomain(value.site);
          return citationSite === domain;
        }) || null;
      };
      
      // Check CampaignData.citation (singular) - could be object or keyed by domain: citation[domain]
      if (CampaignData.citation && typeof CampaignData.citation === 'object') {
        const domainCitation = findDomainCitationInObject(CampaignData.citation);
        if (domainCitation && typeof domainCitation === 'object') {
          checkCitationCheckpoint(domainCitation, `CampaignData.citation[${domain}]`);
        } else {
          checkCitationCheckpoint(CampaignData.citation, 'CampaignData.citation');
        }
      }
      
      // Check CampaignData.campaignData.citation (nested) - support citation[domain].citationscheckpoint
      if (!checkpointDisabledByCitation && CampaignData.campaignData && CampaignData.campaignData.citation && typeof CampaignData.campaignData.citation === 'object') {
        const domainCitation = findDomainCitationInObject(CampaignData.campaignData.citation);
        if (domainCitation && typeof domainCitation === 'object') {
          checkCitationCheckpoint(domainCitation, `CampaignData.campaignData.citation[${domain}]`);
        } else {
          checkCitationCheckpoint(CampaignData.campaignData.citation, 'CampaignData.campaignData.citation');
        }
      }
      
      // Check CampaignData.citations.citationscheckpoint directly (if citations is an object)
      if (!checkpointDisabledByCitation && CampaignData.citations && typeof CampaignData.citations === 'object' && !Array.isArray(CampaignData.citations)) {
        // If citations is keyed by domain, prefer that entry
        const domainCitation = findDomainCitationInObject(CampaignData.citations);
        if (domainCitation && typeof domainCitation === 'object') {
          checkCitationCheckpoint(domainCitation, `CampaignData.citations[${domain}]`);
        } else {
          checkCitationCheckpoint(CampaignData.citations, 'CampaignData.citations');
        }
      }
      
      // Find citations array and check for domain-specific citation
      let citations = null;
      if (Array.isArray(CampaignData)) {
        // CampaignData is an array - check all campaigns for domain match
        for (const campaign of CampaignData) {
          // Check campaign.citation (singular) first
          if (!checkpointDisabledByCitation && campaign.citation && typeof campaign.citation === 'object') {
            checkCitationCheckpoint(campaign.citation, `campaign[${CampaignData.indexOf(campaign)}].citation`);
          }
          
          // Check campaign.campaignData.citation (nested) - support citation[domain].citationscheckpoint
          if (!checkpointDisabledByCitation && campaign.campaignData && campaign.campaignData.citation && typeof campaign.campaignData.citation === 'object') {
            const domainCitation = findDomainCitationInObject(campaign.campaignData.citation);
            if (domainCitation && typeof domainCitation === 'object') {
              checkCitationCheckpoint(domainCitation, `campaign[${CampaignData.indexOf(campaign)}].campaignData.citation[${domain}]`);
            } else {
              checkCitationCheckpoint(campaign.campaignData.citation, `campaign[${CampaignData.indexOf(campaign)}].campaignData.citation`);
            }
          }
          
          // Check campaign.citations.citationscheckpoint directly (if citations is an object)
          if (!checkpointDisabledByCitation && campaign.citations && typeof campaign.citations === 'object' && !Array.isArray(campaign.citations)) {
            const domainCitation = findDomainCitationInObject(campaign.citations);
            if (domainCitation && typeof domainCitation === 'object') {
              checkCitationCheckpoint(domainCitation, `campaign[${CampaignData.indexOf(campaign)}].citations[${domain}]`);
            } else {
              checkCitationCheckpoint(campaign.citations, `campaign[${CampaignData.indexOf(campaign)}].citations`);
            }
          }
          
          // Check citations array for domain match
          if (!checkpointDisabledByCitation && campaign.citations && Array.isArray(campaign.citations)) {
            const domainCitation = findDomainCitation(campaign.citations);
            if (domainCitation) {
              checkCitationCheckpoint(domainCitation, `campaign[${CampaignData.indexOf(campaign)}].citations array for domain: ${domain}`);
            }
          }
        }
      } else {
        // CampaignData is an object - check various paths
        if (CampaignData.citations && Array.isArray(CampaignData.citations)) {
          citations = CampaignData.citations;
        } else if (CampaignData.campaignData && CampaignData.campaignData.citations && typeof CampaignData.campaignData.citations === 'object' && !Array.isArray(CampaignData.campaignData.citations)) {
          if (!checkpointDisabledByCitation) {
            const domainCitation = findDomainCitationInObject(CampaignData.campaignData.citations);
            if (domainCitation && typeof domainCitation === 'object') {
              checkCitationCheckpoint(domainCitation, `CampaignData.campaignData.citations[${domain}]`);
            } else {
              checkCitationCheckpoint(CampaignData.campaignData.citations, 'CampaignData.campaignData.citations');
            }
          }
        } else if (CampaignData.campaignData && CampaignData.campaignData.citations && Array.isArray(CampaignData.campaignData.citations)) {
          citations = CampaignData.campaignData.citations;
        }
        
        // If not found in singular citation, check in citations array for current domain
        if (!checkpointDisabledByCitation && citations && Array.isArray(citations)) {
          const domainCitation = findDomainCitation(citations);
          if (domainCitation) {
            checkCitationCheckpoint(domainCitation, `citations array for domain: ${domain}`);
          }
        }
      }
      
      if (!shouldStartAtCheckpoint && !checkpointDisabledByCitation) {
        console.log(`‚ÑπÔ∏è [CHECKPOINT] No citationscheckpoint flag found, proceeding with normal checkpoint logic`);
      }
    } catch (error) {
      console.error("‚ùå [CHECKPOINT] Error checking citationscheckpoint:", error);
    }
    
    // Load current resume index before checkpoint handling
    const resumeKeyForCheckpoint = getTabSpecificResumeIndexKey();
    let resumeIndexForCheckpoint = 0;
    try {
      const resumeResult = await new Promise((resolve) => {
        CHROME_API.storage.local.get([resumeKeyForCheckpoint], (result) => {
          if (CHROME_API.lastError) {
            console.warn("‚ö†Ô∏è [CHECKPOINT] Error loading resume index:", CHROME_API.lastError.message);
            resolve({});
          } else {
            resolve(result);
          }
        });
      });
      resumeIndexForCheckpoint = resumeResult[resumeKeyForCheckpoint] || 0;
      console.log(`üîç [CHECKPOINT] Current resume index: ${resumeIndexForCheckpoint} (key: ${resumeKeyForCheckpoint})`);
    } catch (error) {
      console.warn("‚ö†Ô∏è [CHECKPOINT] Error accessing resume index before checkpoint:", error);
    }
    
    // Find checkpoint in steps
    const checkpointInfo = await findCheckpointStep(steps);
    
    // When checkpoint exists: it defines the start. Set resume to checkpoint and clear any saved indexes that cause confusion.
    window.__CHECKPOINT_CITATIONSCHECKPOINT_ACTIVE__ = false;
    if (checkpointInfo.found) {
      console.log(`üéØ [CHECKPOINT] Checkpoint found at step ${checkpointInfo.stepIndex}`);
      window.__CHECKPOINT_DISABLED__ = checkpointDisabledByCitation;
      if (checkpointDisabledByCitation) {
        console.log(`‚úÖ [CHECKPOINT] citationscheckpoint is false for domain - skipping checkpoint handling`);
      } else if (!freshStart) {
        // Checkpoint defines the start: set resume index to checkpoint, skip all steps behind it (+ stepsToSkip honored in loop)
        window.__CHECKPOINT_CITATIONSCHECKPOINT_ACTIVE__ = true;
        window.__CHECKPOINT_ALLOWED__ = true; // Show modal when we reach checkpoint step (first time after start)
        await setResumeIndexAndWait(checkpointInfo.stepIndex);
        console.log(`üîÑ [CHECKPOINT] Resume index set to checkpoint ${checkpointInfo.stepIndex} (steps 0-${checkpointInfo.stepIndex - 1} will be skipped)`);
        showToast(`‚úÖ Starting automation from checkpoint at step ${checkpointInfo.stepIndex + 1}`);
      } else {
        // freshStart: user explicitly chose to run from step 0; keep __CHECKPOINT_ALLOWED__ so modal shows when we reach checkpoint
        window.__CHECKPOINT_ALLOWED__ = true;
      }
    } else {
      window.__CHECKPOINT_ALLOWED__ = true;
      if (shouldStartAtCheckpoint) {
        console.warn(`‚ö†Ô∏è [CHECKPOINT] citationscheckpoint flag is true but no checkpoint found in steps`);
      } else {
        console.log(`‚ÑπÔ∏è [CHECKPOINT] No checkpoint found in steps, proceeding normally`);
      }
    }
    
    const key = getTabSpecificResumeIndexKey();
    let resumeIndex = 0, campaignData = {}, pendingUpload = {};
    try {
      const result = await new Promise((resolve) => {
        CHROME_API.storage.local.get([key, "CampaignData", "pendingUpload", RESUME_INDEX_CURRENT_RUN_KEY], (result) => {
          if (CHROME_API.lastError) {
            console.warn("Chrome storage error in runAutomation:", CHROME_API.lastError.message);
            resolve({});
          } else {
            resolve(result);
          }
        });
      });
      const domainIndex = result[key] || 0;
      const currentRunIndex = result[RESUME_INDEX_CURRENT_RUN_KEY] || 0;
      resumeIndex = Math.max(domainIndex, currentRunIndex);
      campaignData = result.CampaignData || {};
      pendingUpload = result.pendingUpload || {};
      console.log(`üîç [DEBUG] Resume index loaded: ${resumeIndex} (domain: ${domainIndex}, currentRun: ${currentRunIndex}, key: ${key})`);
    } catch (err) {
      console.warn("Error accessing Chrome storage in runAutomation:", err);
    }
    
    // Extract nested campaignData structure (similar to other functions)
    // IMPORTANT: Include both campaignData and base64Data for image uploads
    let dataToFlatten = campaignData;
    let base64DataToMerge = null;
    
    if (campaignData && Object.keys(campaignData).length > 0) {
      // Check if campaignData has a 'campaignData' property (nested structure)
      if (campaignData.campaignData) {
        console.log(`üîç [DEBUG] Found nested campaignData structure, using campaignData.campaignData`);
        dataToFlatten = campaignData.campaignData;
        // Also check for base64Data at the same level
        if (campaignData.base64Data) {
          base64DataToMerge = campaignData.base64Data;
          console.log(`üîç [DEBUG] Found base64Data at CampaignData.base64Data level`);
        }
      } else {
        // Try to get the first value (nested structure like { userId: { campaignData: {...} } })
        const firstValue = Object.values(campaignData)[0];
        if (firstValue && typeof firstValue === 'object' && firstValue.campaignData) {
          console.log(`üîç [DEBUG] Found nested structure with userId key, extracting campaignData`);
          dataToFlatten = firstValue.campaignData;
          // Also check for base64Data in the nested structure
          if (firstValue.base64Data) {
            base64DataToMerge = firstValue.base64Data;
            console.log(`üîç [DEBUG] Found base64Data in nested structure`);
          }
        } else if (firstValue && typeof firstValue === 'object') {
          // The first value itself might be the campaignData
          console.log(`üîç [DEBUG] Using first value as campaignData`);
          dataToFlatten = firstValue;
        }
      }
      
      // If base64Data exists at the top level of CampaignData, use it
      if (!base64DataToMerge && campaignData.base64Data) {
        base64DataToMerge = campaignData.base64Data;
        console.log(`üîç [DEBUG] Found base64Data at top level of CampaignData`);
      }
    }
    
    // Merge base64Data into dataToFlatten so it gets flattened together
    if (base64DataToMerge && typeof base64DataToMerge === 'object') {
      console.log(`üîç [DEBUG] Merging base64Data into dataToFlatten`);
      // Merge base64Data keys directly into dataToFlatten
      Object.assign(dataToFlatten, base64DataToMerge);
      console.log(`üîç [DEBUG] Merged base64Data keys:`, Object.keys(base64DataToMerge));
    }
    
    let startIndex = freshStart ? 0 : resumeIndex;
    // When checkpoint exists and !freshStart: ensure we never run steps before checkpoint
    if (!freshStart && checkpointInfo && checkpointInfo.found && !checkpointDisabledByCitation && startIndex < checkpointInfo.stepIndex) {
      startIndex = checkpointInfo.stepIndex;
      setResumeIndex(checkpointInfo.stepIndex);
      console.log(`üîç [CHECKPOINT] Forcing startIndex to ${startIndex} (skip all steps before checkpoint)`);
    }
    // GoTo optimization: if already on target URL, skip GoTo step - but never go below checkpoint
    if (!freshStart && startIndex >= 1 && steps.length > 0 && steps[0].action === 'GoTo' && steps[0].link) {
      var gotoLink = (steps[0].link || '').replace(/\/$/, '');
      var currentUrl = (window.location.href || '').replace(/\/$/, '');
      if (currentUrl === gotoLink || currentUrl.indexOf(gotoLink) === 0) {
        var goToStart = 1;
        var minStart = (checkpointInfo && checkpointInfo.found && !checkpointDisabledByCitation) ? checkpointInfo.stepIndex : 0;
        if (goToStart >= minStart) {
          startIndex = goToStart;
          setResumeIndex(goToStart);
          console.log(`üîç [PAGE] On GoTo target URL - start from step 1 (resumeIndex was ${resumeIndex})`);
        }
      }
    }
    console.log(`üîç [DEBUG] Starting automation from index: ${startIndex} (freshStart: ${freshStart}, resumeIndex: ${resumeIndex})`);
    const flatData = flattenObject(dataToFlatten);
    const fileMap = pendingUpload.files || {};
    
    // Debug: Show phone-related keys in flatData
    const phoneKeys = Object.keys(flatData).filter(k => k.toLowerCase().includes('phone') || k.toLowerCase().includes('telephone'));
    if (phoneKeys.length > 0) {
      console.log(`üìû Phone-related keys found in flatData:`, phoneKeys);
      phoneKeys.forEach(key => {
        console.log(`   ‚Ä¢ ${key}: "${flatData[key]}"`);
      });
    } else {
      console.log(`‚ö†Ô∏è No phone-related keys found in flatData`);
      console.log(`üîç Available keys (first 20):`, Object.keys(flatData).slice(0, 20));
    }
    
    console.log(`üéØ Automation execution details:`);
    console.log(`   ‚Ä¢ Fresh start: ${freshStart}`);
    console.log(`   ‚Ä¢ Resume index: ${resumeIndex}`);
    console.log(`   ‚Ä¢ Start index: ${startIndex}`);
    console.log(`   ‚Ä¢ Total steps: ${steps.length}`);
    console.log(`   ‚Ä¢ Storage key: ${key}`);
    console.log(`   ‚Ä¢ Steps to execute: ${steps.length - startIndex}`);
    
    // Debug: Show all loaded steps
    console.log(`üìã All loaded steps:`);
    steps.forEach((step, index) => {
      console.log(`   Step ${index}: ${step.action} - "${step.selector}" - valueKey: "${step.valueKey || ''}" - label: "${step.label || ''}"`);
    });

    // REFACTORED: Helper function to get alternative key for valueKey
    function getAlternativeKey(valueKey) {
      const alternativeMap = {
        'contactFirstNameBox': 'firstnameAlternative',
        'contactLastNameBox': 'lastnameAlternative',
        'image1Box': 'image1alternative',
        'logoBox': 'logoalternative'
      };
      
      return alternativeMap[valueKey] || null;
    }

    // Helper function to map alternative field names to their corresponding valueKeys
    function getAlternativeValueKey(alternativeFieldName) {
      const alternativeToValueKeyMap = {
        'Contact Telephone': 'contactTelephoneBox',
        'Contact Email': 'contactEmailBox',
        'Mobile Number': 'mobileNumberBox',
        'Fax Number': 'faxNumberBox',
        'Address': 'addressBox',
        'Website': 'websiteBox',
        'Description': 'longDescriptionBox',
        'Business Hours': 'businessHoursBox',
        'Number of Employees': 'employeesBox',
        'Date of Company Formation': 'yearFormationBox',
        'Payment Method': 'paymentMethodsBox',
        'Facebook': 'facebookBox',
        'Twitter': 'twitterBox',
        'LinkedIn': 'linkedinBox',
        'Instagram': 'instagramBox',
        'Pinterest': 'pinterestBox',
        'Tiktok': 'tiktokBox',
        'Youtube': 'youtubeBox',
        'List of Services': 'servicesBox'
      };
      
      return alternativeToValueKeyMap[alternativeFieldName] || null;
    }

    /** Process employeesBox value: if it's a range (e.g. "10-50", "5-20"), pick a value within the range to fill */
    function processEmployeesBoxValue(val, stepIndex) {
      if (val == null || val === '') return val;
      const str = String(val).trim();
      if (!str) return val;
      // Detect range patterns: "10-50", "10 - 50", "10 to 50", "5‚Äì20" (en-dash)
      const rangeMatch = str.match(/^\s*(\d+)\s*[-‚Äì‚Äî]\s*(\d+)\s*$/i) ||
        str.match(/^\s*(\d+)\s+to\s+(\d+)\s*$/i);
      if (rangeMatch) {
        const min = Math.min(parseInt(rangeMatch[1], 10), parseInt(rangeMatch[2], 10));
        const max = Math.max(parseInt(rangeMatch[1], 10), parseInt(rangeMatch[2], 10));
        if (min <= max) {
          // Pick random value within range (inclusive)
          const picked = min + Math.floor(Math.random() * (max - min + 1));
          console.log(`üî¢ [${stepIndex}] employeesBox range "${str}" detected - using random value within range: ${picked}`);
          return String(picked);
        }
      }
      // Not a range - return as-is
      return val;
    }

  // Enhanced element-specific fill function
  async function fillElementByType(element, value, stepIndex, required, fillDelay = 100, validationDelay = 200, method = 'default') {
    const tagName = element.tagName.toLowerCase();
    console.log(`üîß [${stepIndex}] Using fill method '${method}' for ${tagName} element`);
    
    try {
      // Clear field first (skip for BODY - TinyMCE/body clear is done in their fill handlers)
      if (element.tagName.toUpperCase() !== 'BODY') {
        element.value = '';
        element.dispatchEvent(new Event('input', { bubbles: true }));
        element.dispatchEvent(new Event('change', { bubbles: true }));
      }
      
      // Add delay before filling
      if (fillDelay > 0) {
        await new Promise(resolve => setTimeout(resolve, fillDelay));
      }
      
      // Element-specific fill logic
      if (tagName === 'select') {
        return await fillSelectElement(element, value, stepIndex, method, fillDelay, validationDelay);
      } else if (tagName === 'input') {
        return await fillInputElement(element, value, stepIndex, method, fillDelay, validationDelay);
      } else if (tagName === 'textarea') {
        return await fillTextareaElement(element, value, stepIndex, method, fillDelay, validationDelay);
      } else if (tagName === 'body') {
        // TinyMCE body: use TinyMCE API so content actually displays (valueKey fill path)
        const isTinyMCE = element.id === 'tinymce' || element.classList.contains('mceContentBody');
        if (isTinyMCE) {
          return await fillTinyMCEBodyWithValue(element, value, stepIndex);
        }
        return await fillGenericElement(element, value, stepIndex, method);
      } else {
        // Generic fallback for other elements
        return await fillGenericElement(element, value, stepIndex, method, fillDelay, validationDelay);
      }
    } catch (error) {
      console.error(`‚ùå [${stepIndex}] Error in fillElementByType:`, error);
      return { success: false, error: error.message };
    }
  }

  function normalizeCountryString(value) {
    return String(value || '')
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '');
  }

  function getCountryAliasSet(value) {
    const normalized = normalizeCountryString(value);
    const aliasMap = {
      usa: [
        'usa',
        'us',
        'unitedstates',
        'unitedstatesofamerica',
        'u s',
        'u s a',
        'u.s.',
        'u.s.a.',
        'america',
        'theunitedstates',
        'theunitedstatesofamerica'
      ],
      uk: [
        'uk',
        'unitedkingdom',
        'greatbritain',
        'britain',
        'gb',
        'gbr',
        'u.k.',
        'england',
        'scotland',
        'wales',
        'northernireland'
      ],
      australia: ['australia', 'au', 'aus'],
      canada: ['canada', 'ca', 'can'],
      newzealand: ['newzealand', 'new zealand', 'nz']
    };
    const aliases = new Set([normalized]);
    Object.keys(aliasMap).forEach((key) => {
      const normalizedAliases = aliasMap[key].map((alias) => normalizeCountryString(alias));
      if (normalizedAliases.includes(normalized) || key === normalized) {
        aliases.add(key);
        normalizedAliases.forEach((alias) => aliases.add(alias));
      }
    });
    return aliases;
  }

  function isCountrySelect(element) {
    if (!element) return false;
    const name = (element.getAttribute('name') || '').toLowerCase();
    const id = (element.getAttribute('id') || '').toLowerCase();
    const className = (element.getAttribute('class') || '').toLowerCase();
    return name.includes('country') || id.includes('country') || className.includes('country');
  }

  // Fill select element with smart option matching
  async function fillSelectElement(element, value, stepIndex, method, fillDelay = 100, validationDelay = 200) {
    console.log(`üîß [${stepIndex}] Filling SELECT element with value: "${value}"`);
    
    const options = Array.from(element.options);
    let matchedOption = null;
    
    // Method 1: Exact value match
    if (method === 'default' || method === 'method1') {
      matchedOption = options.find(option => option.value === value);
      if (matchedOption) {
        console.log(`‚úÖ [${stepIndex}] Found exact value match: "${matchedOption.textContent}" (${matchedOption.value})`);
      }
    }
    
    // Method 2: Exact text match
    if (!matchedOption && (method === 'default' || method === 'method2')) {
      matchedOption = options.find(option => 
        option.textContent.trim() === value ||
        option.textContent.trim().toLowerCase() === value.toLowerCase()
      );
      if (matchedOption) {
        console.log(`‚úÖ [${stepIndex}] Found exact text match: "${matchedOption.textContent}" (${matchedOption.value})`);
      }
    }

    // Method 2.5: Country alias matching (e.g., United States <-> USA)
    if (!matchedOption && (method === 'default' || method === 'method2' || method === 'retry') && isCountrySelect(element)) {
      const aliasSet = getCountryAliasSet(value);
      matchedOption = options.find(option => {
        const optionText = normalizeCountryString(option.textContent);
        const optionValue = normalizeCountryString(option.value);
        return aliasSet.has(optionText) || aliasSet.has(optionValue);
      });
      if (matchedOption) {
        console.log(`‚úÖ [${stepIndex}] Found country alias match: "${matchedOption.textContent}" (${matchedOption.value})`);
      }
    }
    
    // Method 3: Partial text match
    if (!matchedOption && (method === 'default' || method === 'method3')) {
      matchedOption = options.find(option => 
        option.textContent.trim().toLowerCase().includes(value.toLowerCase()) ||
        value.toLowerCase().includes(option.textContent.trim().toLowerCase())
      );
      if (matchedOption) {
        console.log(`‚úÖ [${stepIndex}] Found partial text match: "${matchedOption.textContent}" (${matchedOption.value})`);
      }
    }
    
    // Method 4: Fuzzy match (remove special characters)
    if (!matchedOption && method === 'retry') {
      const cleanValue = value.toLowerCase().replace(/[^a-z0-9]/g, '');
      matchedOption = options.find(option => {
        const cleanOptionText = option.textContent.trim().toLowerCase().replace(/[^a-z0-9]/g, '');
        return cleanOptionText.includes(cleanValue) || cleanValue.includes(cleanOptionText);
      });
      if (matchedOption) {
        console.log(`‚úÖ [${stepIndex}] Found fuzzy match: "${matchedOption.textContent}" (${matchedOption.value})`);
      }
    }
    
    if (matchedOption) {
      // Select the matched option
      element.value = matchedOption.value;
      element.focus();
      
      console.log(`üîß [${stepIndex}] SELECT element filled: value="${matchedOption.value}", text="${matchedOption.textContent}"`);
      
      // Dispatch select-specific events
      element.dispatchEvent(new Event('focus', { bubbles: true }));
      element.dispatchEvent(new Event('change', { bubbles: true }));
      element.dispatchEvent(new Event('select', { bubbles: true }));
      element.dispatchEvent(new Event('blur', { bubbles: true }));
      
      // Wait for DOM/framework to sync before validating
      const delay = (validationDelay != null && validationDelay > 0) ? validationDelay : 100;
      await new Promise(resolve => setTimeout(resolve, delay));
      
      // Validate the selection
      const isValid = validateFieldFill(element, value);
      return { 
        success: isValid, 
        matchedOption: matchedOption.textContent,
        selectedValue: matchedOption.value,
        selectedText: matchedOption.textContent
      };
    } else {
      // No match found, log available options for debugging
      const availableOptions = options.map(opt => `"${opt.textContent}" (${opt.value})`).join(', ');
      console.warn(`‚ö†Ô∏è [${stepIndex}] No matching option found for "${value}". Available options: ${availableOptions}`);
      return { success: false, error: 'No matching option found' };
    }
  }

  // Fill input element with enhanced event handling (robust approach for tricky sites)
  async function fillInputElement(element, value, stepIndex, method, fillDelay = 100, validationDelay = 200) {
    console.log(`üîß [${stepIndex}] Filling INPUT element with value: "${value}"`);
    
    // Check if this is a Bootstrap Tagsinput or similar tag input component
    // Pattern: Hidden input (id="tags" or similar) with visible bootstrap-tagsinput wrapper
    // OR: Visible input inside bootstrap-tagsinput wrapper
    const isHiddenInput = element.style.display === 'none' || 
                          element.hasAttribute('hidden') ||
                          window.getComputedStyle(element).display === 'none';
    
    const isTagsInput = element.type === 'text' && (
      element.id?.toLowerCase().includes('tag') ||
      element.name?.toLowerCase().includes('tag') ||
      element.classList.contains('tags-input') ||
      element.closest('.bootstrap-tagsinput') ||
      element.closest('[class*="tagsinput"]')
    );
    
    // Also check if there's a bootstrap-tagsinput wrapper nearby
    let tagsInputWrapper = null;
    let visibleTagsInput = null;
    let hiddenInput = null;
    
    // Check if element is inside a bootstrap-tagsinput wrapper
    const parentWrapper = element.closest('.bootstrap-tagsinput, [class*="tagsinput"]');
    if (parentWrapper) {
      tagsInputWrapper = parentWrapper;
      visibleTagsInput = element; // This element is the visible input
      // Find the hidden input (usually a sibling or in parent)
      hiddenInput = element.closest('.form-group, .form-control')?.querySelector('input[type="text"][style*="display: none"], input[type="text"][hidden]') ||
                    document.querySelector(`input[name="${element.name}"][style*="display: none"], input[name="${element.name}"][hidden]`);
      console.log(`üè∑Ô∏è [${stepIndex}] Element is inside Bootstrap Tagsinput wrapper`);
    } else if (isTagsInput || isHiddenInput) {
      // Check for bootstrap-tagsinput wrapper in parent or siblings
      const parent = element.parentElement;
      if (parent) {
        tagsInputWrapper = parent.querySelector('.bootstrap-tagsinput, [class*="tagsinput"]');
        if (tagsInputWrapper) {
          visibleTagsInput = tagsInputWrapper.querySelector('input[type="text"]:not([style*="display: none"]):not([hidden])');
          hiddenInput = element; // This element is the hidden input
          console.log(`üè∑Ô∏è [${stepIndex}] Detected Bootstrap Tagsinput component (hidden input)`);
        }
      }
      
      // Also check siblings
      if (!tagsInputWrapper && element.parentElement) {
        const siblings = Array.from(element.parentElement.children);
        for (const sibling of siblings) {
          if (sibling.classList && (
            sibling.classList.contains('bootstrap-tagsinput') ||
            sibling.classList.toString().includes('tagsinput')
          )) {
            tagsInputWrapper = sibling;
            visibleTagsInput = sibling.querySelector('input[type="text"]:not([style*="display: none"]):not([hidden])');
            hiddenInput = element;
            console.log(`üè∑Ô∏è [${stepIndex}] Found Bootstrap Tagsinput in sibling element`);
            break;
          }
        }
      }
    }
    
    if (method === 'method2') {
      // Simulate typing character by character (fallback method)
      element.focus();
      element.value = '';
      for (let i = 0; i < value.length; i++) {
        element.value += value[i];
        element.dispatchEvent(new Event('input', { bubbles: true }));
        element.dispatchEvent(new Event('keydown', { bubbles: true }));
        element.dispatchEvent(new Event('keyup', { bubbles: true }));
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      element.dispatchEvent(new Event('change', { bubbles: true }));
    } else {
      // Robust approach for tricky sites (primary method)
      // 1. Focus (fires onfocus)
      element.focus();
      
      // 2. Clear value explicitly
      element.value = '';
      
      // 3. Set real value
      element.value = value;
      
      // 4. Fire input & change (important for frameworks + validation)
      element.dispatchEvent(new Event('input', { bubbles: true }));
      element.dispatchEvent(new Event('change', { bubbles: true }));
      
      // 5. Blur (fires onblur)
      element.blur();
      
      // Additional events for better compatibility
      if (method === 'method3') {
        ['keydown', 'keyup', 'keypress'].forEach(eventType => {
          element.dispatchEvent(new Event(eventType, { bubbles: true }));
        });
      }
    }
    
    // Handle Bootstrap Tagsinput component
    // Use the hidden input for value storage, visible input for display
    const targetInput = hiddenInput || element;
    if (tagsInputWrapper && visibleTagsInput) {
      console.log(`üè∑Ô∏è [${stepIndex}] Updating Bootstrap Tagsinput visible component`);
      
      try {
        // Split value by comma to get individual tags
        const tags = value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
        
        // Method 1: Try to use Bootstrap Tagsinput jQuery API if available
        let apiSuccess = false;
        if (window.jQuery) {
          try {
            // Try to find the jQuery element for the hidden input
            const $hiddenInput = window.jQuery(element);
            if ($hiddenInput && $hiddenInput.tagsinput) {
              // Use the tagsinput API
              $hiddenInput.tagsinput('removeAll');
              tags.forEach(tag => {
                $hiddenInput.tagsinput('add', tag);
              });
              apiSuccess = true;
              console.log(`‚úÖ [${stepIndex}] Updated Bootstrap Tagsinput using jQuery API on hidden input`);
            } else if (tagsInputWrapper && window.jQuery(tagsInputWrapper).tagsinput) {
              // Try wrapper element
              const $wrapper = window.jQuery(tagsInputWrapper);
              $wrapper.tagsinput('removeAll');
              tags.forEach(tag => {
                $wrapper.tagsinput('add', tag);
              });
              apiSuccess = true;
              console.log(`‚úÖ [${stepIndex}] Updated Bootstrap Tagsinput using jQuery API on wrapper`);
            }
          } catch (error) {
            console.warn(`‚ö†Ô∏è [${stepIndex}] jQuery/bootstrap-tagsinput API error:`, error);
          }
        }
        
        // Method 2: Manual tag creation (fallback if API not available)
        if (!apiSuccess) {
          // Clear existing tags first
          const existingTags = tagsInputWrapper.querySelectorAll('.tag, .badge, [class*="tag"], span[class*="tag"]');
          existingTags.forEach(tag => {
            // Only remove tag elements, not the input itself
            if (!tag.querySelector('input')) {
              tag.remove();
            }
          });
          
          // Add new tags by simulating user input
          for (const tag of tags) {
            // Focus the visible input
            visibleTagsInput.focus();
            visibleTagsInput.value = tag;
            
            // Trigger input event
            visibleTagsInput.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Trigger Enter key to add tag (most common pattern)
            const enterKeyDown = new KeyboardEvent('keydown', {
              bubbles: true,
              cancelable: true,
              keyCode: 13,
              which: 13,
              key: 'Enter',
              code: 'Enter'
            });
            visibleTagsInput.dispatchEvent(enterKeyDown);
            
            const enterKeyPress = new KeyboardEvent('keypress', {
              bubbles: true,
              cancelable: true,
              keyCode: 13,
              which: 13,
              key: 'Enter',
              code: 'Enter'
            });
            visibleTagsInput.dispatchEvent(enterKeyPress);
            
            const enterKeyUp = new KeyboardEvent('keyup', {
              bubbles: true,
              cancelable: true,
              keyCode: 13,
              which: 13,
              key: 'Enter',
              code: 'Enter'
            });
            visibleTagsInput.dispatchEvent(enterKeyUp);
            
            // Also try blur event (some implementations trigger on blur)
            visibleTagsInput.dispatchEvent(new Event('blur', { bubbles: true }));
            
            // Clear the input for next tag
            visibleTagsInput.value = '';
            
            // Small delay between tags
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          
          // Final blur
          visibleTagsInput.blur();
          
          // Trigger change on both inputs to ensure sync
          element.dispatchEvent(new Event('change', { bubbles: true }));
          visibleTagsInput.dispatchEvent(new Event('change', { bubbles: true }));
          
          console.log(`‚úÖ [${stepIndex}] Updated Bootstrap Tagsinput manually with ${tags.length} tag(s)`);
        }
        
        // Method 3: Direct DOM manipulation as last resort
        // Some implementations store tags in data attributes or update DOM directly
        // Wait a bit and check if tags were added
        await new Promise(resolve => setTimeout(resolve, 200));
        const addedTags = tagsInputWrapper.querySelectorAll('.tag, .badge, [class*="tag"]');
        if (addedTags.length === 0 && tags.length > 0) {
          console.log(`üîÑ [${stepIndex}] Tags not added via events, trying direct DOM manipulation`);
          
          // Try to create tag elements directly
          tags.forEach(tag => {
            const tagElement = document.createElement('span');
            tagElement.className = 'tag label label-info';
            tagElement.textContent = tag;
            
            // Try to find the input container and insert before it
            const inputContainer = tagsInputWrapper.querySelector('input[type="text"]')?.parentElement;
            if (inputContainer) {
              inputContainer.insertBefore(tagElement, visibleTagsInput);
            } else {
              tagsInputWrapper.insertBefore(tagElement, visibleTagsInput);
            }
          });
          
          // Update hidden input value (use targetInput which might be hiddenInput or element)
          if (targetInput) {
            targetInput.value = value;
            targetInput.dispatchEvent(new Event('change', { bubbles: true }));
          }
          
          console.log(`‚úÖ [${stepIndex}] Created tags via direct DOM manipulation`);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Error updating Bootstrap Tagsinput:`, error);
        // Continue anyway, the hidden input was already filled
      }
    }
    
    // Wait for DOM/framework to sync before validating (avoids "data supplied but validation fails")
    const delay = (validationDelay != null && validationDelay > 0) ? validationDelay : 100;
    await new Promise(resolve => setTimeout(resolve, delay));
    
    // Validate the fill
    const isValid = validateFieldFill(element, value);
    return { success: isValid };
  }

  // Fill textarea element (robust approach for tricky sites)
  async function fillTextareaElement(element, value, stepIndex, method, fillDelay = 100, validationDelay = 200) {
    console.log(`üîß [${stepIndex}] Filling TEXTAREA element with value: "${value}"`);
    
    // Robust approach for tricky sites
    // 1. Focus (fires onfocus)
    element.focus();
    
    // 2. Clear value explicitly
    element.value = '';
    
    // 3. Set real value
    element.value = value;
    
    // 4. Fire input & change (important for frameworks + validation)
    element.dispatchEvent(new Event('input', { bubbles: true }));
    element.dispatchEvent(new Event('change', { bubbles: true }));
    
    // 5. Blur (fires onblur)
    element.blur();
    
    // Wait for DOM/framework to sync before validating
    const delay = (validationDelay != null && validationDelay > 0) ? validationDelay : 100;
    await new Promise(resolve => setTimeout(resolve, delay));
    
    // Validate the fill
    const isValid = validateFieldFill(element, value);
    return { success: isValid };
  }

  // Generic fill for other elements (robust approach for tricky sites)
  async function fillGenericElement(element, value, stepIndex, method, fillDelay = 100, validationDelay = 200) {
    console.log(`üîß [${stepIndex}] Filling generic element (${element.tagName}) with value: "${value}"`);
    
    // Robust approach for tricky sites
    // 1. Focus (fires onfocus)
    element.focus();
    
    // 2. Clear value explicitly (if element has value property)
    if (element.value !== undefined) {
      element.value = '';
    } else if (element.textContent !== undefined) {
      element.textContent = '';
    }
    
    // 3. Set real value
    if (element.value !== undefined) {
      element.value = value;
    } else if (element.textContent !== undefined) {
      element.textContent = value;
    }
    
    // 4. Fire input & change (important for frameworks + validation)
    element.dispatchEvent(new Event('input', { bubbles: true }));
    element.dispatchEvent(new Event('change', { bubbles: true }));
    
    // 5. Blur (fires onblur)
    element.blur();
    
    // Wait for DOM/framework to sync before validating
    const delay = (validationDelay != null && validationDelay > 0) ? validationDelay : 100;
    await new Promise(resolve => setTimeout(resolve, delay));
    
    // Validate the fill
    const isValid = validateFieldFill(element, value);
    return { success: isValid };
  }

  // Fill TinyMCE body with a value (valueKey fill) so content displays in editor
  async function fillTinyMCEBodyWithValue(element, value, stepIndex) {
    console.log(`üîß [${stepIndex}] Filling TinyMCE body with value (so it displays in editor)`);
    const strValue = value != null ? String(value) : '';
    let injected = false;

    if (typeof tinymce !== 'undefined' && tinymce.editors && tinymce.editors.length > 0) {
      try {
        let editor = null;
        if (element) {
          for (let i = 0; i < tinymce.editors.length; i++) {
            const ed = tinymce.editors[i];
            if (ed.getBody && ed.getBody() === element) {
              editor = ed;
              break;
            }
          }
        }
        if (!editor) {
          const editorId = element.id || element.getAttribute('data-id') || element.closest?.('iframe')?.id;
          if (editorId) editor = tinymce.get(editorId);
        }
        if (!editor && tinymce.editors.length > 0) editor = tinymce.editors[0];
        if (editor && typeof editor.setContent === 'function') {
          editor.setContent(strValue);
          if (typeof editor.save === 'function') editor.save();
          if (typeof editor.fire === 'function') editor.fire('change');
          console.log(`‚úÖ [${stepIndex}] Set TinyMCE content via API`);
          injected = true;
        }
      } catch (e) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] TinyMCE API fill failed:`, e);
      }
    }

    if (!injected) {
      const escaped = strValue.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      element.innerHTML = '<p>' + escaped + '</p>';
      element.dispatchEvent(new Event('input', { bubbles: true }));
      element.dispatchEvent(new Event('change', { bubbles: true }));
      if (element.ownerDocument !== document) {
        const iframe = element.ownerDocument?.defaultView?.frameElement;
        if (iframe) {
          iframe.dispatchEvent(new Event('input', { bubbles: true }));
          iframe.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }
      console.log(`üîß [${stepIndex}] Set TinyMCE body via direct innerHTML fallback`);
    }

    await new Promise(resolve => setTimeout(resolve, 100));
    const isValid = validateFieldFill(element, strValue);
    return { success: isValid };
  }

  // Transpose servicesBox: one line comma-separated -> one item per line. Prefer service1Box..service5Box.
  function transposeServicesBoxValue(flatData, currentVal, stepIndex) {
    const serviceKeys = ['service1Box', 'service2Box', 'service3Box', 'service4Box', 'service5Box'];
    const fromBoxes = serviceKeys
      .map(k => (flatData && flatData[k] != null ? String(flatData[k]).trim() : ''))
      .filter(Boolean);
    if (fromBoxes.length > 0) {
      const result = fromBoxes.join('\n');
      console.log(`üìã [${stepIndex}] transpose (servicesBox): using service1Box..service5Box -> ${fromBoxes.length} line(s)`);
      return result;
    }
    const fromComma = (currentVal != null ? String(currentVal) : '')
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);
    const result = fromComma.length > 0 ? fromComma.join('\n') : (currentVal != null ? String(currentVal) : '');
    if (fromComma.length > 0) {
      console.log(`üìã [${stepIndex}] transpose (servicesBox): split by comma -> ${fromComma.length} line(s)`);
    }
    return result;
  }

  // Dispatch Enter key on element (for fillAndEnter: confirm/commit after fill)
  function dispatchEnterKeyOnElement(element, stepIndex) {
    if (!element || typeof element.dispatchEvent !== 'function') return;
    const tag = element.tagName && element.tagName.toUpperCase();
    const isField = tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
    const target = isField ? element : (element.querySelector && element.querySelector('input, textarea')) || element;
    try {
      target.focus();
      const opts = { bubbles: true, cancelable: true, keyCode: 13, which: 13, key: 'Enter', code: 'Enter' };
      target.dispatchEvent(new KeyboardEvent('keydown', opts));
      target.dispatchEvent(new KeyboardEvent('keypress', opts));
      target.dispatchEvent(new KeyboardEvent('keyup', opts));
      console.log(`‚Üµ [${stepIndex}] fillAndEnter: dispatched Enter key on element`);
    } catch (e) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndEnter: failed to dispatch Enter:`, e);
    }
  }

  // --- Phone Number Formatting Function ---
  function formatPhoneNumber(phoneValue, formatType) {
    if (!phoneValue || typeof phoneValue !== 'string') {
      return phoneValue || '';
    }
    
    // If format is 'none', return original value
    if (formatType === 'none') {
      return phoneValue;
    }
    
    // Remove all non-digit characters except +
    let cleaned = phoneValue.replace(/[^\d+]/g, '');
    
    // If empty after cleaning, return original
    if (!cleaned || cleaned.length === 0) {
      return phoneValue;
    }
    
    // Extract country code if present (starts with +)
    let countryCode = '';
    let number = cleaned;
    
    if (cleaned.startsWith('+')) {
      const digits = cleaned.substring(1);
      
      // Prefer NANP parsing (+1 followed by 10 digits)
      if (digits.length === 11 && digits.startsWith('1')) {
        countryCode = '+1';
        number = digits.substring(1);
      } else {
        // Try to extract country code (usually 1-3 digits after +)
        // Common country codes: 1 (US/Canada), 44 (UK), 61 (Australia), etc.
        const match = cleaned.match(/^\+(\d{1,3})(.*)$/);
        if (match) {
          countryCode = '+' + match[1];
          number = match[2];
        } else {
          // If no match, treat + as part of number
          number = digits;
        }
      }
    }
    
    // Remove leading zeros if needed for certain formats
    const hasLeadingZero = number.startsWith('0');
    const numberWithoutLeadingZero = hasLeadingZero ? number.substring(1) : number;
    
    // Apply formatting based on formatType
    switch (formatType) {
      case 'with-country-space':
        // +1 0123456789 (Country Code with Space)
        if (countryCode) {
          return `${countryCode} ${number}`;
        }
        return number;
        
      case 'with-country-dash':
        // +1-012-345-6789 (Country Code with Dashes)
        if (countryCode && number.length >= 10) {
          const formatted = number.match(/.{1,3}/g)?.join('-') || number;
          return `${countryCode}-${formatted}`;
        }
        return number;
        
      case 'with-dashes':
        // 012-234-56789 (With Dashes)
        if (number.length >= 10) {
          // Format: XXX-XXX-XXXXX (last group can be longer)
          if (number.length === 10) {
            return `${number.substring(0, 3)}-${number.substring(3, 6)}-${number.substring(6)}`;
          } else if (number.length === 11) {
            return `${number.substring(0, 3)}-${number.substring(3, 6)}-${number.substring(6)}`;
          } else {
            // For longer numbers, group in 3s
            return number.match(/.{1,3}/g)?.join('-') || number;
          }
        }
        return number;
        
      case 'with-spaces':
        // 012 234 56789 (With Spaces)
        if (number.length >= 10) {
          if (number.length === 10) {
            return `${number.substring(0, 3)} ${number.substring(3, 6)} ${number.substring(6)}`;
          } else {
            return number.match(/.{1,3}/g)?.join(' ') || number;
          }
        }
        return number;
        
      case 'with-parentheses':
        // (012) 234-56789 (With Parentheses)
        if (number.length >= 10) {
          const areaCode = number.substring(0, 3);
          const rest = number.substring(3);
          if (rest.length <= 8) {
            return `(${areaCode}) ${rest.substring(0, 3)}-${rest.substring(3)}`;
          } else {
            return `(${areaCode}) ${rest}`;
          }
        }
        return number;
        
      case 'plain':
        // 0123456789 (Plain Numbers)
        return number;
        
      case 'no-leading-zero':
        // 123456789 (No Leading Zero)
        return numberWithoutLeadingZero;
        
      case 'international':
        // +1 (012) 234-56789 (International Format)
        if (countryCode && number.length >= 10) {
          const areaCode = number.substring(0, 3);
          const rest = number.substring(3);
          if (rest.length <= 8) {
            return `${countryCode} (${areaCode}) ${rest.substring(0, 3)}-${rest.substring(3)}`;
          } else {
            return `${countryCode} (${areaCode}) ${rest}`;
          }
        } else if (number.length >= 10) {
          // Format without country code
          const areaCode = number.substring(0, 3);
          const rest = number.substring(3);
          if (rest.length <= 8) {
            return `(${areaCode}) ${rest.substring(0, 3)}-${rest.substring(3)}`;
          } else {
            return `(${areaCode}) ${rest}`;
          }
        }
        return number;
        
      case 'compact':
        // 01223456789 (Compact, No Separators)
        return number;
        
      default:
        // Default: return original value
        return phoneValue;
    }
  }
  
  // Check if valueKey is a phone-related field
  function isPhoneField(valueKey) {
    if (!valueKey || typeof valueKey !== 'string') {
      return false;
    }
    
    const phoneFields = [
      'contactTelephoneBox',
      'mobileNumberBox',
      'faxNumberBox',
      'telephone',
      'mobile',
      'fax',
      'phone',
      'contactPhone',
      'contactMobile',
      'contactFax'
    ];
    
    const lowerValueKey = valueKey.toLowerCase();
    return phoneFields.some(field => lowerValueKey.includes(field.toLowerCase()));
  }
  
  // Check if valueKey is a website-related field
  function isWebsiteField(valueKey) {
    if (!valueKey || typeof valueKey !== 'string') {
      return false;
    }
    
    const lowerValueKey = valueKey.toLowerCase();
    return lowerValueKey.includes('website');
  }
  
  // --- Link Formatting Function ---
  function formatLinkValue(linkValue, formatType) {
    if (!linkValue || typeof linkValue !== 'string') {
      return linkValue || '';
    }
    
    const trimmed = linkValue.trim();
    if (!trimmed) {
      return trimmed;
    }
    
    const normalizedFormat = String(formatType || '').toLowerCase().trim();
    
    if (!normalizedFormat || normalizedFormat === 'default') {
      return trimmed;
    }
    
    if (normalizedFormat === 'removehttps') {
      return trimmed.replace(/^https?:\/\//i, '');
    }
    
    if (normalizedFormat === 'addwww') {
      const hasScheme = /^https?:\/\//i.test(trimmed);
      if (hasScheme) {
        const match = trimmed.match(/^(https?:\/\/)(.*)$/i);
        if (!match) {
          return trimmed;
        }
        const scheme = match[1];
        const rest = match[2];
        if (rest.toLowerCase().startsWith('www.')) {
          return trimmed;
        }
        return `${scheme}www.${rest}`;
      }
      
      if (trimmed.toLowerCase().startsWith('www.')) {
        return trimmed;
      }
      
      return `www.${trimmed}`;
    }
    
    if (normalizedFormat === 'domainonly') {
      const hasScheme = /^https?:\/\//i.test(trimmed);
      const schemeMatch = trimmed.match(/^(https?:\/\/)/i);
      const scheme = schemeMatch ? schemeMatch[1] : 'https://';
      
      try {
        const url = new URL(hasScheme ? trimmed : `https://${trimmed}`);
        return hasScheme ? `${url.protocol}//${url.host}/` : `${url.host}/`;
      } catch (error) {
        const withoutScheme = trimmed.replace(/^https?:\/\//i, '');
        const hostOnly = withoutScheme.split('/')[0];
        return hasScheme ? `${scheme}${hostOnly}/` : `${hostOnly}/`;
      }
    }
    
    return trimmed;
  }
  
  // --- Hours Formatting Function (12-hour / 24-hour conversion) ---
  function convertBusinessHoursText(hoursText, formatType) {
    if (!hoursText || typeof hoursText !== 'string') {
      return hoursText || '';
    }

    if (formatType === '24Hrs') {
      // Convert 12-hour time tokens to 24-hour
      return hoursText.replace(/\b(\d{1,2}:\d{2})\s*([AP]M)\b/gi, (match) => {
        const converted = convertTo24Hour(match);
        return converted || match;
      });
    }

    if (formatType === '12Hrs') {
      // Convert 24-hour time tokens to 12-hour (skip tokens already with AM/PM)
      return hoursText.replace(/\b([01]?\d|2[0-3]):[0-5]\d\b(?!\s*(?:AM|PM)\b)/gi, (match) => {
        const converted = convertTo12Hour(match);
        return converted || match;
      });
    }

    return hoursText;
  }

  function formatHours(hoursValue, formatType, valueKey = null) {
    // Special handling for businessHoursBox with consolidated/detailed formats
    if (valueKey === 'businessHoursBox' && formatType) {
      const formatLower = formatType.toLowerCase().trim();
      
      // If format is "default", return null to indicate use raw value (handled by caller)
      if (formatLower === 'default') {
        return null;
      }
      
      // Normalize format string: remove spaces, handle variations like "detailed12Hrs" -> "detailed12hrs"
      const normalizedFormat = formatLower.replace(/\s+/g, '').replace(/hrs?/gi, 'hrs');
      
      // If a simple 12/24 format is requested and we have hoursValue text, convert it
      if (hoursValue && (normalizedFormat === '12hrs' || normalizedFormat === '24hrs')) {
        return convertBusinessHoursText(hoursValue, normalizedFormat === '12hrs' ? '12Hrs' : '24Hrs');
      }
      // Resolve data source: flatData has per-day keys (monAm, monPm, etc.) or parse businessHoursBox text
      const daysForCheck = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
      const hasPerDayKeys = flatData && daysForCheck.some(d => flatData[`${d}Am`] || flatData[`${d}Pm`]);
      const rawBox = (hoursValue && typeof hoursValue === 'string') ? hoursValue : (flatData && flatData.businessHoursBox);
      let dataToUse = flatData;
      if (!hasPerDayKeys && rawBox && typeof rawBox === 'string' && rawBox.trim()) {
        const parseFormat = normalizedFormat.includes('12') ? '12Hrs' : '24Hrs';
        dataToUse = parseBusinessHoursBoxToData(rawBox, parseFormat);
      }
      // businessHoursBox with plain "12Hrs" or "24Hrs" (no consolidated/detailed): use dataToUse
      if (normalizedFormat === '12hrs') {
        return formatBusinessHoursFromData(dataToUse, 'consolidated-12hrs');
      }
      if (normalizedFormat === '24hrs') {
        return formatBusinessHoursFromData(dataToUse, 'consolidated-24hrs');
      }
      
      // Handle consolidated formats (with better matching)
      if (normalizedFormat.includes('consolidated') && normalizedFormat.includes('12')) {
        return formatBusinessHoursFromData(dataToUse, 'consolidated-12hrs');
      } else if (normalizedFormat.includes('consolidated') && normalizedFormat.includes('24')) {
        return formatBusinessHoursFromData(dataToUse, 'consolidated-24hrs');
      } else if (normalizedFormat.includes('consolidated')) {
        // Default consolidated to 24hrs if no hour format specified
        return formatBusinessHoursFromData(dataToUse, 'consolidated-24hrs');
      }
      
      // Handle detailed formats (with better matching for variations like "detailed12Hrs")
      if (normalizedFormat.includes('detailed') && normalizedFormat.includes('12')) {
        return formatBusinessHoursFromData(dataToUse, 'detailed-12hrs');
      } else if (normalizedFormat.includes('detailed') && normalizedFormat.includes('24')) {
        return formatBusinessHoursFromData(dataToUse, 'detailed-24hrs');
      } else if (normalizedFormat.includes('detailed')) {
        // Default detailed to 24hrs if no hour format specified
        return formatBusinessHoursFromData(dataToUse, 'detailed-24hrs');
      }
      
      // Fallback: if formatType exists but doesn't match any pattern, default to detailed-24hrs
      return formatBusinessHoursFromData(dataToUse, 'detailed-24hrs');
    }
    
    // If businessHoursBox but no formatType, return null to use raw value
    if (valueKey === 'businessHoursBox' && !formatType) {
      return null;
    }
    
    // Regular single time value formatting
    if (!hoursValue || typeof hoursValue !== 'string') {
      return hoursValue || '';
    }
    
    // Trim the value
    const trimmed = hoursValue.trim();
    if (!trimmed) {
      return hoursValue;
    }
    
    // If format is not specified or invalid, return original
    if (!formatType || (formatType !== '12Hrs' && formatType !== '24Hrs')) {
      return hoursValue;
    }
    
    // Check if already in the desired format
    const is12Hour = /^\d{1,2}:\d{2}\s*(AM|PM|am|pm)$/i.test(trimmed);
    const is24Hour = /^\d{1,2}:\d{2}$/.test(trimmed) && !is12Hour;
    
    // If already in desired format, return as is
    if ((formatType === '12Hrs' && is12Hour) || (formatType === '24Hrs' && is24Hour)) {
      return hoursValue;
    }
    
    // Convert based on format type
    if (formatType === '24Hrs') {
      // Convert 12-hour to 24-hour
      return convertTo24Hour(trimmed);
    } else if (formatType === '12Hrs') {
      // Convert 24-hour to 12-hour
      return convertTo12Hour(trimmed);
    }
    
    return hoursValue;
  }
  
  // Format business hours from flatData with support for 12-hour and 24-hour formats
  function formatBusinessHoursFromData(data, format = 'consolidated-24hrs') {
    if (!data || typeof data !== 'object') {
      return '';
    }
    
    const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    
    // Extract and convert times
    const hours = {};
    days.forEach(day => {
      const amRaw = data[`${day}Am`] || '';
      const pmRaw = data[`${day}Pm`] || '';
      
      // Convert to 24-hour format first for processing
      const am24 = convertTo24Hour(amRaw);
      const pm24 = convertTo24Hour(pmRaw);
      
      if (am24 && pm24) {
        hours[day] = { 
          open24: am24, 
          close24: pm24,
          open12: convertTo12Hour(am24),
          close12: convertTo12Hour(pm24),
          closed: false 
        };
      } else {
        hours[day] = { closed: true };
      }
    });
    
    // Determine format type
    const is12Hour = format.includes('12hrs');
    const isConsolidated = format.includes('consolidated');
    const isDetailed = format.includes('detailed');
    
    if (isConsolidated) {
      // Consolidated format: Group similar days
      const groups = [];
      let currentGroup = null;
      
      days.forEach((day, index) => {
        const dayHours = hours[day];
        
        if (dayHours.closed) {
          if (currentGroup) {
            groups.push(currentGroup);
            currentGroup = null;
          }
        } else {
          const openTime = is12Hour ? dayHours.open12 : dayHours.open24;
          const closeTime = is12Hour ? dayHours.close12 : dayHours.close24;
          const timeKey = `${openTime}-${closeTime}`;
          
          if (!currentGroup || currentGroup.timeKey !== timeKey) {
            if (currentGroup) groups.push(currentGroup);
            currentGroup = {
              startDay: day,
              endDay: day,
              timeKey,
              openTime,
              closeTime
            };
          } else {
            currentGroup.endDay = day;
          }
        }
      });
      
      if (currentGroup) groups.push(currentGroup);
      
      // Handle closed days
      const allClosed = days.every(day => hours[day].closed);
      if (allClosed) {
        return 'Closed';
      }
      
      // Format groups
      const formattedGroups = groups.map(group => {
        const startName = dayNames[days.indexOf(group.startDay)];
        const endName = dayNames[days.indexOf(group.endDay)];
        const dayRange = group.startDay === group.endDay ? startName : `${startName}-${endName}`;
        return `${dayRange}: ${group.openTime} - ${group.closeTime}`;
      });
      
      // Check if there are closed days and group them
      const hasClosedDays = days.some(day => hours[day].closed);
      if (hasClosedDays) {
        const closedDays = days.filter(day => hours[day].closed);
        if (closedDays.length > 0) {
          // Group consecutive closed days
          let closedGroups = [];
          let currentClosedGroup = null;
          
          closedDays.forEach((day, idx) => {
            const prevDay = idx > 0 ? closedDays[idx - 1] : null;
            const dayIndex = days.indexOf(day);
            const prevDayIndex = prevDay ? days.indexOf(prevDay) : -1;
            
            // Check if consecutive
            if (prevDay && dayIndex === prevDayIndex + 1) {
              // Continue current group
              currentClosedGroup.endDay = day;
            } else {
              // Start new group
              if (currentClosedGroup) {
                closedGroups.push(currentClosedGroup);
              }
              currentClosedGroup = { startDay: day, endDay: day };
            }
          });
          
          if (currentClosedGroup) {
            closedGroups.push(currentClosedGroup);
          }
          
          // Format closed groups
          closedGroups.forEach(group => {
            const startName = dayNames[days.indexOf(group.startDay)];
            const endName = dayNames[days.indexOf(group.endDay)];
            const closedRange = group.startDay === group.endDay ? startName : `${startName}-${endName}`;
            formattedGroups.push(`${closedRange}: Closed`);
          });
        }
      }
      
      return formattedGroups.join(', ');
      
    } else if (isDetailed) {
      // Detailed format: Show each day separately
      return days.map((day, index) => {
        const dayHours = hours[day];
        const dayName = dayNames[index];
        
        if (dayHours.closed) {
          return `${dayName}:   Closed`;
        } else {
          const openTime = is12Hour ? dayHours.open12 : dayHours.open24;
          const closeTime = is12Hour ? dayHours.close12 : dayHours.close24;
          // Format with proper spacing
          const spacing = dayName.length === 3 ? '   ' : '  '; // Mon/Tue/Wed = 3 chars, others = 4+
          return `${dayName}:${spacing}${openTime} - ${closeTime}`;
        }
      }).join('\n');
    }
    
    // Default: consolidated 24-hour format
    return formatBusinessHoursFromData(data, 'consolidated-24hrs');
  }
  
  // Convert 24-hour format to 12-hour format
  function convertTo12Hour(time24h) {
    if (!time24h || typeof time24h !== 'string') {
      return time24h || '';
    }
    
    // Remove any whitespace
    const cleaned = time24h.trim();
    
    // Check if already in 12-hour format
    if (/^\d{1,2}:\d{2}\s*(AM|PM|am|pm)$/i.test(cleaned)) {
      return cleaned;
    }
    
    // Parse 24-hour format (HH:MM or H:MM)
    const timeMatch = cleaned.match(/^(\d{1,2}):(\d{2})$/);
    if (!timeMatch) {
      // If not in expected format, return original
      return time24h;
    }
    
    let hours = parseInt(timeMatch[1], 10);
    const minutes = timeMatch[2];
    
    // Validate hours and minutes
    if (hours < 0 || hours > 23 || parseInt(minutes, 10) > 59) {
      return time24h;
    }
    
    // Convert to 12-hour format
    const period = hours >= 12 ? 'PM' : 'AM';
    
    if (hours === 0) {
      hours = 12; // Midnight (00:xx) becomes 12:xx AM
    } else if (hours === 12) {
      hours = 12; // Noon (12:xx) stays 12:xx PM
    } else if (hours > 12) {
      hours = hours - 12; // Afternoon hours (13-23) become 1-11 PM
    }
    // Morning hours (1-11) stay as is with AM
    
    // Format hours (no leading zero for single digit hours in 12-hour format)
    const formattedHours = hours.toString();
    
    return `${formattedHours}:${minutes} ${period}`;
  }
  
  // Check if valueKey is a hours-related field
  function isHoursField(valueKey) {
    if (!valueKey || typeof valueKey !== 'string') {
      return false;
    }
    
    const hoursFields = [
      'monAm', 'monPm', 'monFull',
      'tueAm', 'tuePm', 'tueFull',
      'wedAm', 'wedPm', 'wedFull',
      'thuAm', 'thuPm', 'thuFull',
      'friAm', 'friPm', 'friFull',
      'satAm', 'satPm', 'satFull',
      'sunAm', 'sunPm', 'sunFull',
      'businessHoursBox',
      'hours',
      'businessHours'
    ];
    
    const lowerValueKey = valueKey.toLowerCase();
    return hoursFields.some(field => lowerValueKey === field.toLowerCase());
  }

  // Utility: Sanitize value by removing special characters
  function sanitizeValue(value) {
    if (!value || typeof value !== 'string') return value;
    
    // Remove special characters but keep:
    // - Letters (a-z, A-Z)
    // - Numbers (0-9)
    // - Spaces
    // - Basic punctuation: period (.), comma (,), hyphen (-), apostrophe (')
    const sanitized = value.replace(/[^a-zA-Z0-9\s.,'-]/g, '');
    
    // Clean up multiple spaces
    const cleaned = sanitized.replace(/\s+/g, ' ').trim();
    
    return cleaned;
  }

  // Utility: Combine space-separated valueKeys with space separator
  // Example: "firstname lastname" with values "Business" and "Manager" = "Business Manager"
  function combineSpaceSeparatedValueKeys(valueKey, flatData) {
    if (!valueKey || typeof valueKey !== 'string') return null;
    
    // Check if valueKey contains spaces (but not " + " which is handled separately)
    // Must have at least 2 parts when split by spaces
    if (!valueKey.includes(' ') || valueKey.includes(' + ')) {
      return null;
    }
    
    const keys = valueKey.trim().split(/\s+/).map(k => k.trim()).filter(k => k);
    
    // Must have at least 2 keys to combine
    if (keys.length < 2) {
      return null;
    }
    
    // Get values from flatData and combine with space separator
    const values = keys.map(k => {
      const val = flatData[k];
      if (val === undefined || val === null) {
        console.log(`üîç [combineSpaceSeparatedValueKeys] Key "${k}" not found in flatData`);
      }
      return val !== undefined && val !== null ? String(val).trim() : '';
    }).filter(v => v !== '');
    
    // If we have at least one value, combine them with space
    if (values.length > 0) {
      const combined = values.join(' ');
      console.log(`üîç [combineSpaceSeparatedValueKeys] Combined "${valueKey}" = "${combined}" from keys: ${keys.join(', ')}`);
      return combined;
    }
    
    console.log(`‚ö†Ô∏è [combineSpaceSeparatedValueKeys] No values found for keys: ${keys.join(', ')}`);
    return null;
  }

  // Utility: Combine valueKeys with plus sign (no spaces) without separator
  // Example: "TelephonePrefix+TelephoneLine" with values "123" and "4567" = "1234567"
  function combinePlusSeparatedValueKeys(valueKey, flatData) {
    if (!valueKey || typeof valueKey !== 'string') return null;
    
    // Check if valueKey contains "+" but not " + " (which is handled separately)
    // Must have at least 2 parts when split by "+"
    if (!valueKey.includes('+') || valueKey.includes(' + ')) {
      return null;
    }
    
    const keys = valueKey.trim().split('+').map(k => k.trim()).filter(k => k);
    
    // Must have at least 2 keys to combine
    if (keys.length < 2) {
      return null;
    }
    
    // Get values from flatData and combine without separator
    const values = keys.map(k => {
      const val = flatData[k];
      if (val === undefined || val === null) {
        console.log(`üîç [combinePlusSeparatedValueKeys] Key "${k}" not found in flatData`);
      }
      return val !== undefined && val !== null ? String(val).trim() : '';
    }).filter(v => v !== '');
    
    // If we have at least one value, combine them without separator
    if (values.length > 0) {
      const combined = values.join('');
      console.log(`üîç [combinePlusSeparatedValueKeys] Combined "${valueKey}" = "${combined}" from keys: ${keys.join(', ')}`);
      return combined;
    }
    
    console.log(`‚ö†Ô∏è [combinePlusSeparatedValueKeys] No values found for keys: ${keys.join(', ')}`);
    return null;
  }

  function parseLimitValue(limitValue) {
    if (limitValue === undefined || limitValue === null) return null;
    const parsed = typeof limitValue === 'number' ? limitValue : parseInt(String(limitValue).trim(), 10);
    if (Number.isNaN(parsed) || parsed <= 0) return null;
    return parsed;
  }

  function applyLimit(value, limitValue) {
    if (typeof value !== 'string') return value;
    if (value.length <= limitValue) return value;
    return value.slice(0, limitValue);
  }

  function applyLimitBySentence(value, limitValue) {
    if (typeof value !== 'string') return value;
    if (value.length <= limitValue) return value;
    const truncated = value.slice(0, limitValue);
    const sentenceEndRegex = /[.!?](?=\s|$)/g;
    let match = null;
    let lastIndex = -1;
    while ((match = sentenceEndRegex.exec(truncated)) !== null) {
      lastIndex = match.index;
    }
    if (lastIndex === -1) {
      return truncated;
    }
    let endIndex = lastIndex + 1;
    if (endIndex < limitValue && /\s/.test(value[endIndex])) {
      endIndex += 1;
    }
    return value.slice(0, endIndex);
  }

  /**
   * Evaluate logical expressions for a step
   * Supports joinOperator (OR, AND, NOT) with exactValue and exactValue2, plus booleanValue.
   * @param {Array} logicalExpressions - Array of expression objects
   *   Each: { operator, valueKey1, targetLabel1?, exactValue, exactValue2?, joinOperator?, booleanValue?, caseSensitive? }
   *   - operator: "valueIsExactly" | "isEmpty" | "greaterThan" | "lessThan"
   *   - joinOperator: "OR" | "AND" | "NOT" - combines exactValue and exactValue2 (valueIsExactly only)
   *     OR: skip when value matches exactValue OR exactValue2 (default)
   *     AND: skip when value matches BOTH (value equals exactValue and exactValue2 - use when same)
   *     NOT: skip when value matches NEITHER exactValue nor exactValue2
   *   - booleanValue: true/undefined ‚Üí skip when condition matches; false ‚Üí skip when condition does NOT match (inverted)
   *   - caseSensitive: true (default) | false - comparison mode for valueIsExactly
   * @example { operator:"valueIsExactly", valueKey1:"businessHoursStatus", exactValue:"Normal", exactValue2:"24Hrs", joinOperator:"OR", booleanValue:false }
   *   ‚Üí Proceed when businessHoursStatus is "Normal" OR "24Hrs"; skip otherwise
   */
  function evaluateLogicalExpressions(logicalExpressions, flatData, stepIndex, step = {}) {
    if (!logicalExpressions || !Array.isArray(logicalExpressions) || logicalExpressions.length === 0) {
      return { shouldSkip: false, reason: null, insertValue: null };
    }
    console.log(`üîç [${stepIndex}] Evaluating ${logicalExpressions.length} logical expression(s)...`);
    
    for (let i = 0; i < logicalExpressions.length; i++) {
      const expression = logicalExpressions[i];
      const { booleanValue, operator, valueKey1, targetLabel1, id, exactValue, countType, countValue, operation, insertedValue } = expression;
      
      if (!operator || !valueKey1) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Expression ${i + 1} is missing operator or valueKey1, skipping...`);
        continue;
      }
      
      // Get the value from flatData
      const value = flatData[valueKey1];
      const valueStr = value !== undefined && value !== null ? String(value).trim() : '';
      const isEmpty = value === undefined || value === null || valueStr === '';
      
      console.log(`   üìã Expression ${i + 1} (${id || 'no-id'}):`);
      console.log(`      ‚Ä¢ Operator: "${operator}"`);
      console.log(`      ‚Ä¢ ValueKey: "${valueKey1}"`);
      console.log(`      ‚Ä¢ Target Label: "${targetLabel1 || 'N/A'}"`);
      console.log(`      ‚Ä¢ Current Value: ${value === undefined ? 'undefined' : value === null ? 'null' : `"${valueStr}"`}`);
      console.log(`      ‚Ä¢ Is Empty: ${isEmpty}`);
      console.log(`      ‚Ä¢ Boolean Value: ${booleanValue}`);
      if (exactValue !== undefined && exactValue !== null) {
        console.log(`      ‚Ä¢ Exact Value: "${exactValue}"`);
      }
      
      // Evaluate based on operator
      let conditionMet = false;
      
      switch (operator.toLowerCase()) {
        case 'isempty':
          // Use booleanValue to control behavior:
          // booleanValue: true ‚Üí skip if empty (isEmpty behavior)
          // booleanValue: false ‚Üí skip if not empty (isNotEmpty behavior)
          if (booleanValue === true) {
            // Skip if empty (isEmpty behavior)
            conditionMet = isEmpty;
          } else if (booleanValue === false) {
            // Skip if not empty (isNotEmpty behavior) - invert the condition
            conditionMet = !isEmpty;
          } else {
            // Default to isEmpty behavior if booleanValue is not specified
            conditionMet = isEmpty;
          }
          break;
          
        case 'valueisexactly':
          // Compare valueKey value with exactValue (and optional exactValue2 with joinOperator)
          if (exactValue === undefined || exactValue === null) {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Expression ${i + 1} operator "valueIsExactly" requires exactValue, skipping...`);
            continue;
          }
          
          const exactValueStr = String(exactValue).trim();
          const hasExactValue2 = expression.hasOwnProperty('exactValue2') && expression.exactValue2 !== undefined && expression.exactValue2 !== null && String(expression.exactValue2).trim() !== '';
          const exactValueStr2 = hasExactValue2 ? String(expression.exactValue2).trim() : null;
          const joinOp = (expression.joinOperator || 'OR').toString().trim().toUpperCase();
          const caseSensitive = expression.caseSensitive !== false;
          const cmp = (a, b) => caseSensitive ? (a === b) : (String(a).toLowerCase() === String(b).toLowerCase());
          
          const match1 = cmp(valueStr, exactValueStr);
          const match2 = hasExactValue2 ? cmp(valueStr, exactValueStr2) : false;
          
          if (hasExactValue2) {
            console.log(`      ‚Ä¢ Comparison1: "${valueStr}" ${caseSensitive ? '===' : '~='} "${exactValueStr}" = ${match1}`);
            console.log(`      ‚Ä¢ Comparison2: "${valueStr}" ${caseSensitive ? '===' : '~='} "${exactValueStr2}" = ${match2}`);
            console.log(`      ‚Ä¢ Join Operator: "${joinOp}" | booleanValue: ${booleanValue} | caseSensitive: ${caseSensitive}`);
          } else {
            console.log(`      ‚Ä¢ Comparison: "${valueStr}" ${caseSensitive ? '===' : '~='} "${exactValueStr}" = ${match1} | booleanValue: ${booleanValue}`);
          }
          
          let valuesMatch = match1;
          if (hasExactValue2) {
            if (joinOp === 'AND') {
              valuesMatch = match1 && match2;
            } else if (joinOp === 'OR') {
              valuesMatch = match1 || match2;
            } else if (joinOp === 'NOT') {
              valuesMatch = !(match1 || match2);
            } else {
              // Default to OR if joinOperator is missing/invalid
              valuesMatch = match1 || match2;
            }
          }
          
          // Use booleanValue to control behavior (similar to isEmpty operator):
          // booleanValue: true (or undefined) ‚Üí skip if values match (valueIsExactly behavior)
          // booleanValue: false ‚Üí skip if values do NOT match (valueIsNotExactly behavior)
          if (booleanValue === false) {
            // Skip if values do NOT match (inverted behavior)
            conditionMet = !valuesMatch;
            console.log(`      ‚Ä¢ booleanValue=false: Inverted condition - will skip if values do NOT match`);
          } else {
            // Skip if values match (default behavior)
            conditionMet = valuesMatch;
            console.log(`      ‚Ä¢ booleanValue=true/undefined: Default condition - will skip if values match`);
          }
          
          console.log(`      ‚Ä¢ Final conditionMet: ${conditionMet}`);
          
          // If condition is met, skip the step
          if (conditionMet) {
            if (booleanValue === false) {
              const reason = `Expression ${i + 1}: ${targetLabel1 || valueKey1} (${valueKey1}) value "${valueStr}" does NOT exactly match "${exactValueStr}"${hasExactValue2 ? ` (${joinOp || 'OR'} "${exactValueStr2}")` : ''} - skipping step`;
              console.log(`‚è≠Ô∏è [${stepIndex}] ${reason}`);
              return { shouldSkip: true, reason: reason, insertValue: null };
            } else {
              const reason = `Expression ${i + 1}: ${targetLabel1 || valueKey1} (${valueKey1}) value "${valueStr}" exactly matches "${exactValueStr}"${hasExactValue2 ? ` (${joinOp || 'OR'} "${exactValueStr2}")` : ''} - skipping step`;
              console.log(`‚è≠Ô∏è [${stepIndex}] ${reason}`);
              return { shouldSkip: true, reason: reason, insertValue: null };
            }
          } else {
            if (booleanValue === false) {
              console.log(`‚úÖ [${stepIndex}] Expression ${i + 1}: Value "${valueStr}" exactly matches "${exactValueStr}"${hasExactValue2 ? ` (${joinOp || 'OR'} "${exactValueStr2}")` : ''} - proceeding with step`);
            } else {
              console.log(`‚úÖ [${stepIndex}] Expression ${i + 1}: Value "${valueStr}" does not exactly match "${exactValueStr}"${hasExactValue2 ? ` (${joinOp || 'OR'} "${exactValueStr2}")` : ''} - proceeding with step`);
            }
            // Don't skip, continue to next expression or proceed with step
            continue;
          }
          
        case 'greaterthan':
        case 'greater than':
          // Compare valueKey character count with countValue
          if (countValue === undefined || countValue === null) {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Expression ${i + 1} operator "greaterThan" requires countValue, skipping...`);
            continue;
          }
          
          const countTypeLower = (countType || 'Character').toLowerCase();
          let actualCount = 0;
          
          if (countTypeLower === 'character') {
            actualCount = valueStr.length;
          } else {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Expression ${i + 1} countType "${countType}" not supported, defaulting to Character count`);
            actualCount = valueStr.length;
          }
          
          const countValueNum = Number(countValue);
          conditionMet = actualCount > countValueNum;
          
          console.log(`      ‚Ä¢ Count Type: "${countType || 'Character'}"`);
          console.log(`      ‚Ä¢ Actual Count: ${actualCount}`);
          console.log(`      ‚Ä¢ Count Value: ${countValueNum}`);
          console.log(`      ‚Ä¢ Comparison: ${actualCount} > ${countValueNum} = ${conditionMet}`);
          
          // Handle operation based on condition
          if (conditionMet) {
            if (operation === 'Skip') {
              const reason = `Expression ${i + 1}: ${targetLabel1 || valueKey1} (${valueKey1}) character count ${actualCount} is greater than ${countValueNum} - skipping step`;
              console.log(`‚è≠Ô∏è [${stepIndex}] ${reason}`);
              return { shouldSkip: true, reason: reason, insertValue: null };
            } else if (operation === 'Insert Value') {
              if (insertedValue === undefined || insertedValue === null) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Expression ${i + 1} operation "Insert Value" requires insertedValue, skipping...`);
                continue;
              }
              const reason = `Expression ${i + 1}: ${targetLabel1 || valueKey1} (${valueKey1}) character count ${actualCount} is greater than ${countValueNum} - inserting value`;
              console.log(`üìù [${stepIndex}] ${reason}`);
              return { 
                shouldSkip: false, 
                reason: null, 
                insertValue: { 
                  valueKey: valueKey1, 
                  value: insertedValue, 
                  targetLabel: targetLabel1,
                  operator: 'greaterThan',
                  countValue: countValueNum,
                  countType: countType || 'Character'
                } 
              };
            }
          } else {
            console.log(`‚úÖ [${stepIndex}] Expression ${i + 1}: Character count ${actualCount} is not greater than ${countValueNum} - proceeding with step`);
            continue;
          }
          break;
          
        case 'lessthan':
        case 'less than':
          // Compare valueKey character count with countValue
          if (countValue === undefined || countValue === null) {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Expression ${i + 1} operator "lessThan" requires countValue, skipping...`);
            continue;
          }
          
          const countTypeLower2 = (countType || 'Character').toLowerCase();
          let actualCount2 = 0;
          
          if (countTypeLower2 === 'character') {
            actualCount2 = valueStr.length;
          } else {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Expression ${i + 1} countType "${countType}" not supported, defaulting to Character count`);
            actualCount2 = valueStr.length;
          }
          
          const countValueNum2 = Number(countValue);
          conditionMet = actualCount2 < countValueNum2;
          
          console.log(`      ‚Ä¢ Count Type: "${countType || 'Character'}"`);
          console.log(`      ‚Ä¢ Actual Count: ${actualCount2}`);
          console.log(`      ‚Ä¢ Count Value: ${countValueNum2}`);
          console.log(`      ‚Ä¢ Comparison: ${actualCount2} < ${countValueNum2} = ${conditionMet}`);
          
          // Handle operation based on condition
          if (conditionMet) {
            if (operation === 'Skip') {
              const reason = `Expression ${i + 1}: ${targetLabel1 || valueKey1} (${valueKey1}) character count ${actualCount2} is less than ${countValueNum2} - skipping step`;
              console.log(`‚è≠Ô∏è [${stepIndex}] ${reason}`);
              return { shouldSkip: true, reason: reason, insertValue: null };
            } else if (operation === 'Insert Value') {
              if (insertedValue === undefined || insertedValue === null) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Expression ${i + 1} operation "Insert Value" requires insertedValue, skipping...`);
                continue;
              }
              const reason = `Expression ${i + 1}: ${targetLabel1 || valueKey1} (${valueKey1}) character count ${actualCount2} is less than ${countValueNum2} - inserting value`;
              console.log(`üìù [${stepIndex}] ${reason}`);
              return { 
                shouldSkip: false, 
                reason: null, 
                insertValue: { 
                  valueKey: valueKey1, 
                  value: insertedValue, 
                  targetLabel: targetLabel1,
                  operator: 'lessThan',
                  countValue: countValueNum2,
                  countType: countType || 'Character'
                } 
              };
            }
          } else {
            console.log(`‚úÖ [${stepIndex}] Expression ${i + 1}: Character count ${actualCount2} is not less than ${countValueNum2} - proceeding with step`);
            continue;
          }
          break;
          
        // Add more operators as needed
        // case 'equals':
        //   conditionMet = valueStr === expression.value1;
        //   break;
        // case 'contains':
        //   conditionMet = valueStr.toLowerCase().includes((expression.value1 || '').toLowerCase());
        //   break;
        
        default:
          console.warn(`‚ö†Ô∏è [${stepIndex}] Unknown operator "${operator}" in expression ${i + 1}, skipping...`);
          continue;
      }
      
      // Check if booleanValue matches the condition
      // For isEmpty operator:
      // - booleanValue: true ‚Üí skip if conditionMet (empty)
      // - booleanValue: false ‚Üí skip if conditionMet (not empty)
      // For other operators, use the standard logic
      let shouldSkip = false;
      
      if (operator.toLowerCase() === 'isempty') {
        // For isEmpty, conditionMet already reflects the desired behavior based on booleanValue
        // If conditionMet is true, we should skip
        shouldSkip = conditionMet;
      } else {
        // For other operators, use the standard booleanValue logic
        shouldSkip = (booleanValue === true && conditionMet) || (booleanValue === false && !conditionMet);
      }
      
      if (shouldSkip) {
        const reason = `Expression ${i + 1}: ${targetLabel1 || valueKey1} (${valueKey1}) is ${isEmpty ? 'empty' : 'not empty'} - ${operator} condition met (booleanValue: ${booleanValue})`;
        console.log(`‚è≠Ô∏è [${stepIndex}] ${reason}`);
        return { shouldSkip: true, reason: reason, insertValue: null };
      } else {
        console.log(`‚úÖ [${stepIndex}] Expression ${i + 1} condition not met - continuing with step`);
      }
    }
    
    // All expressions evaluated, none triggered skip
    return { shouldSkip: false, reason: null, insertValue: null };
  }
  
  // Helper function to get requiredCategory from automationTasks/automationSteps based on user role
  async function getRequiredCategoryFromAutomation(stepIndex = '') {
    try {
      // Get user role from storage
      const userData = await new Promise((resolve) => {
        CHROME_API.storage.local.get(["user_roles"], (result) => {
          if (CHROME_API.lastError) {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Error getting user role:`, CHROME_API.lastError.message);
            resolve({});
          } else {
            resolve(result);
          }
        });
      });
      
      const userRole = userData.user_roles?.role || "user";
      const currentDomain = extractBaseDomain(window.location.hostname);
      
      // Fetch automation data - GET_AUTOMATION will return from automationTasks or automationSteps based on user role
      const automationResponse = await new Promise((resolve) => {
        CHROME_API.runtime.sendMessage({ type: "GET_AUTOMATION", domainName: currentDomain }, (response) => {
          if (CHROME_API.lastError) {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Error fetching automation:`, CHROME_API.lastError.message);
            resolve(null);
          } else {
            resolve(response);
          }
        });
      });
      
      if (automationResponse && automationResponse.success && automationResponse.automation && automationResponse.automation.controller) {
        const controller = automationResponse.automation.controller;
        
        // Check both controller.requiredCategory and controller.settings.requiredCategory
        const rawValue = controller.requiredCategory !== undefined 
          ? controller.requiredCategory 
          : (controller.settings?.requiredCategory !== undefined 
              ? controller.settings.requiredCategory 
              : undefined);
        
        console.log(`üîç [${stepIndex}] Automation controller.requiredCategory (raw):`, rawValue, `(type: ${typeof rawValue}), userRole: ${userRole}, sourceCollection: ${automationResponse.automation.sourceCollection || 'Unknown'}`);
        
        // Normalize the value (handle string "true"/"false", boolean, etc.)
        if (rawValue === true || rawValue === "true" || rawValue === 1 || rawValue === "1") {
          console.log(`‚úÖ [${stepIndex}] requiredCategory set to TRUE from automation controller (${automationResponse.automation.sourceCollection || 'Unknown'} collection)`);
          return true;
        } else if (rawValue === false || rawValue === "false" || rawValue === 0 || rawValue === "0" || rawValue === null || rawValue === undefined) {
          console.log(`‚úÖ [${stepIndex}] requiredCategory set to FALSE from automation controller (${automationResponse.automation.sourceCollection || 'Unknown'} collection)`);
          return false;
        } else {
          // Default: if not explicitly false, treat as true (backward compatibility)
          console.log(`‚ö†Ô∏è [${stepIndex}] requiredCategory value unclear (${rawValue}), defaulting to TRUE`);
          return true;
        }
      } else {
        // Fallback to window variable if automation fetch fails
        const fallbackValue = window.__AUTOMATION_REQUIRED_CATEGORY__ !== undefined 
          ? window.__AUTOMATION_REQUIRED_CATEGORY__ 
          : true; // Default to true for backward compatibility
        console.log(`‚ö†Ô∏è [${stepIndex}] Could not fetch automation, using window.__AUTOMATION_REQUIRED_CATEGORY__: ${fallbackValue}`);
        return fallbackValue;
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Error getting requiredCategory from automation:`, error);
      // Fallback to window variable
      const fallbackValue = window.__AUTOMATION_REQUIRED_CATEGORY__ !== undefined 
        ? window.__AUTOMATION_REQUIRED_CATEGORY__ 
        : true; // Default to true for backward compatibility
      console.log(`‚ö†Ô∏è [${stepIndex}] Using fallback window.__AUTOMATION_REQUIRED_CATEGORY__: ${fallbackValue}`);
      return fallbackValue;
    }
  }
  
  /**
   * BUSINESS HOURS AUTOMATION ENGINE
   * 
   * TypeScript-style interfaces (documented in JSDoc):
   * 
   * @typedef {Object} BusinessHourSegment
   * @property {string} start - Start time (e.g., "7:00 AM")
   * @property {string} end - End time (e.g., "10:00 AM")
   * 
   * @typedef {Object} NormalizedDay
   * @property {string} day - Day name (Monday, Tuesday, etc.)
   * @property {BusinessHourSegment[]} segments - Array of time segments
   * @property {boolean} isHidden - Whether day is hidden
   * 
   * @typedef {Object} SiteConfig
   * @property {boolean} acceptSplitHours - Site accepts split hours
   * @property {boolean} acceptHideSkipHours - Site accepts hide/skip hours
   * @property {boolean} acceptOverlapHours - Site accepts overlap hours
   * 
   * @typedef {Object} AutomationResult
   * @property {boolean} success - Whether processing succeeded
   * @property {NormalizedDay[]} normalizedDays - Normalized days array
   * @property {Object} processedData - Processed data for flatData update
   * @property {string} [error] - Error message if failed
   */

  /**
   * Normalize business hours data
   * Handles overlaps by splitting into two days
   * @param {Object} rawHoursData - Raw hours data from client
   * @param {string} status - businessHoursStatus: "Normal", "Split", "Hide", "Overlaps"
   * @returns {NormalizedDay[]} Normalized days array
   */
  function normalizeBusinessHours(rawHoursData, status) {
    const normalizedDays = [];
    const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Holiday'];
    const dayKeys = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun', 'holiday'];
    
    for (let i = 0; i < days.length; i++) {
      const day = days[i];
      const dayKey = dayKeys[i];
      const normalizedDay = {
        day: day,
        segments: [],
        isHidden: false
      };
      
      // Check if day is hidden
      if (status === 'Hide') {
        let hasAm = false;
        let hasPm = false;
        
        if (dayKey === 'holiday') {
          hasAm = (rawHoursData.holidayAm || rawHoursData.holidayOpen) && 
                  (rawHoursData.holidayAm || rawHoursData.holidayOpen).trim() !== '';
          hasPm = (rawHoursData.holidayPm || rawHoursData.holidayClose) && 
                  (rawHoursData.holidayPm || rawHoursData.holidayClose).trim() !== '';
        } else {
          const amKey = `${dayKey}Am`;
          const pmKey = `${dayKey}Pm`;
          hasAm = rawHoursData[amKey] && rawHoursData[amKey].trim() !== '';
          hasPm = rawHoursData[pmKey] && rawHoursData[pmKey].trim() !== '';
        }
        
        if (!hasAm && !hasPm) {
          normalizedDay.isHidden = true;
          normalizedDays.push(normalizedDay);
          continue;
        }
      }
      
      // Process hours for this day (handle Holiday differently)
      let amValue = '';
      let pmValue = '';
      
      if (dayKey === 'holiday') {
        // Holiday can use holidayAm/holidayPm or holidayOpen/holidayClose
        amValue = rawHoursData.holidayAm || rawHoursData.holidayOpen || '';
        pmValue = rawHoursData.holidayPm || rawHoursData.holidayClose || '';
      } else {
        amValue = rawHoursData[`${dayKey}Am`] || '';
        pmValue = rawHoursData[`${dayKey}Pm`] || '';
      }
      
      if (status === 'Normal') {
        // Normal: one continuous range
        if (amValue && pmValue) {
          normalizedDay.segments.push({
            start: amValue.trim(),
            end: pmValue.trim()
          });
        }
      } else if (status === 'Split') {
        // Split: multiple segments - need to detect segments
        // For now, treat AM/PM as separate segments if both exist
        if (amValue && pmValue) {
          // Check if this represents a split (e.g., 7AM-10AM, 12PM-6PM)
          // This is a simplified version - in production, you'd parse the actual segments
          normalizedDay.segments.push({
            start: amValue.trim(),
            end: pmValue.trim()
          });
        } else if (amValue) {
          normalizedDay.segments.push({
            start: amValue.trim(),
            end: amValue.trim() // Single time point
          });
        }
        
        const am2Value = dayKey === 'holiday'
          ? (rawHoursData.holidayAm2 || rawHoursData.holidayOpen2 || '')
          : (rawHoursData[`${dayKey}Am2`] || rawHoursData[`${dayKey}Open2`] || '');
        const pm2Value = dayKey === 'holiday'
          ? (rawHoursData.holidayPm2 || rawHoursData.holidayClose2 || '')
          : (rawHoursData[`${dayKey}Pm2`] || rawHoursData[`${dayKey}Close2`] || '');
        
        if (am2Value && pm2Value) {
          normalizedDay.segments.push({
            start: am2Value.trim(),
            end: pm2Value.trim()
          });
        }
      } else if (status === 'Overlaps') {
        // Overlaps: time range overlaps to next day
        // Example: Monday 8:00 PM - 5:00 AM (Tuesday)
        if (amValue && pmValue) {
          const startTime = pmValue.trim();
          const endTime = amValue.trim();
          
          // Check if this is an overlap (end time is earlier than start time in 24h format)
          const start24 = convertTo24Hour(startTime);
          const end24 = convertTo24Hour(endTime);
          
          // Parse times to compare
          const startHour = parseInt(start24.split(':')[0]);
          const endHour = parseInt(end24.split(':')[0]);
          
          if (endHour < startHour || (endHour === startHour && parseInt(end24.split(':')[1]) < parseInt(start24.split(':')[1]))) {
            // This is an overlap - split into two days
            // Day 1: start to 11:59 PM
            normalizedDay.segments.push({
              start: startTime,
              end: '11:59 PM'
            });
            
            // Day 2 (next day): 12:00 AM to end
            const nextDayIndex = (i + 1) % 7;
            const nextDay = days[nextDayIndex];
            const nextDayKey = dayKeys[nextDayIndex];
            
            // Find or create next day
            let nextNormalizedDay = normalizedDays.find(d => d.day === nextDay);
            if (!nextNormalizedDay) {
              nextNormalizedDay = {
                day: nextDay,
                segments: [],
                isHidden: false
              };
              normalizedDays.push(nextNormalizedDay);
            }
            
            nextNormalizedDay.segments.push({
              start: '12:00 AM',
              end: endTime
            });
          } else {
            // Not an overlap, treat as normal
            normalizedDay.segments.push({
              start: startTime,
              end: endTime
            });
          }
        }
      }
      
      if (!normalizedDay.isHidden || normalizedDay.segments.length > 0) {
        normalizedDays.push(normalizedDay);
      }
    }
    
    return normalizedDays;
  }

  /**
   * Consolidate segments into one continuous range
   * @param {BusinessHourSegment[]} segments - Array of segments
   * @returns {BusinessHourSegment|null} Consolidated segment or null
   */
  function consolidateSegments(segments) {
    if (!segments || segments.length === 0) {
      return null;
    }
    
    if (segments.length === 1) {
      return segments[0];
    }
    
    // Find earliest start and latest end
    let earliestStart = segments[0].start;
    let latestEnd = segments[0].end;
    
    for (const segment of segments) {
      const start24 = convertTo24Hour(segment.start);
      const end24 = convertTo24Hour(segment.end);
      const earliest24 = convertTo24Hour(earliestStart);
      const latest24 = convertTo24Hour(latestEnd);
      
      const startHour = parseInt(start24.split(':')[0]);
      const earliestHour = parseInt(earliest24.split(':')[0]);
      
      if (startHour < earliestHour || (startHour === earliestHour && parseInt(start24.split(':')[1]) < parseInt(earliest24.split(':')[1]))) {
        earliestStart = segment.start;
      }
      
      const endHour = parseInt(end24.split(':')[0]);
      const latestHour = parseInt(latest24.split(':')[0]);
      
      if (endHour > latestHour || (endHour === latestHour && parseInt(end24.split(':')[1]) > parseInt(latest24.split(':')[1]))) {
        latestEnd = segment.end;
      }
    }
    
    return {
      start: earliestStart,
      end: latestEnd
    };
  }

  /**
   * Apply automation rule to normalized days
   * @param {NormalizedDay[]} normalizedDays - Normalized days
   * @param {string} rule - Rule to apply: "CONSOLIDATE_SPLIT", "HIDE_AND_CONSOLIDATE", "SKIP_AND_CONSOLIDATE"
   * @returns {NormalizedDay[]} Processed days
   */
  function applyRule(normalizedDays, rule) {
    if (!rule || !normalizedDays) {
      return normalizedDays;
    }
    
    const processedDays = normalizedDays.map(day => ({ ...day, segments: [...day.segments] }));
    
    if (rule === 'CONSOLIDATE_SPLIT') {
      // Merge multiple segments into one continuous range
      for (const day of processedDays) {
        if (day.segments.length > 1) {
          const consolidated = consolidateSegments(day.segments);
          if (consolidated) {
            day.segments = [consolidated];
          }
        }
      }
    } else if (rule === 'HIDE_AND_CONSOLIDATE') {
      // Hide original entries, insert consolidated hours as fallback
      for (const day of processedDays) {
        if (day.segments.length > 1) {
          const consolidated = consolidateSegments(day.segments);
          if (consolidated) {
            day.isHidden = true;
            // Store consolidated as fallback (would be used in fallback logic)
            day.fallbackSegment = consolidated;
          }
        }
      }
    } else if (rule === 'SKIP_AND_CONSOLIDATE') {
      // Remove original entries, insert consolidated hours only
      for (const day of processedDays) {
        if (day.segments.length > 1) {
          const consolidated = consolidateSegments(day.segments);
          if (consolidated) {
            day.segments = [consolidated];
          }
        }
      }
    }
    
    return processedDays;
  }

  /**
   * Main function to process business hours with automation engine
   * @param {string} clientStatus - businessHoursStatus: "Normal", "Split", "Hide", "Overlaps"
   * @param {SiteConfig} siteConfig - Site configuration with checkboxes
   * @param {string} rule - Automation rule: "CONSOLIDATE_SPLIT", "HIDE_AND_CONSOLIDATE", "SKIP_AND_CONSOLIDATE"
   * @param {Object} rawHoursData - Raw hours data from flatData
   * @param {number} stepIndex - Step index for logging
   * @returns {AutomationResult} Processing result
   */
  function processBusinessHoursAutomation(clientStatus, siteConfig, rule, rawHoursData, stepIndex) {
    try {
      console.log(`üîß [${stepIndex}] Business Hours Automation Engine - Processing status: ${clientStatus}`);
      
      // Step 1: Normalize business hours (mandatory)
      let normalizedDays = normalizeBusinessHours(rawHoursData, clientStatus);
      console.log(`‚úÖ [${stepIndex}] Normalized ${normalizedDays.length} days`);
      
      // Step 2: Process based on status and site config
      let shouldApplyRule = false;
      
      if (clientStatus === 'Normal') {
        // Normal: Always pass through unchanged
        console.log(`‚úÖ [${stepIndex}] Status: Normal - Passing through unchanged`);
        return {
          success: true,
          normalizedDays: normalizedDays,
          processedData: {}
        };
      } else if (clientStatus === 'Split') {
        // Split: If site accepts split ‚Üí pass through, else apply rule
        if (siteConfig.acceptSplitHours) {
          if (rule === 'CONSOLIDATE_SPLIT') {
            console.log(`üîß [${stepIndex}] Status: Split - Site accepts split hours, but applying rule: ${rule}`);
            shouldApplyRule = true;
          } else {
            console.log(`‚úÖ [${stepIndex}] Status: Split - Site accepts split hours, passing through`);
            return {
              success: true,
              normalizedDays: normalizedDays,
              processedData: {}
            };
          }
        } else {
          console.log(`üîß [${stepIndex}] Status: Split - Site does NOT accept split, applying rule: ${rule}`);
          shouldApplyRule = true;
        }
      } else if (clientStatus === 'Hide') {
        // Hide: If site accepts hide ‚Üí pass through, else apply rule
        if (siteConfig.acceptHideSkipHours) {
          console.log(`‚úÖ [${stepIndex}] Status: Hide - Site accepts hide hours, passing through`);
          return {
            success: true,
            normalizedDays: normalizedDays,
            processedData: {}
          };
        } else {
          console.log(`üîß [${stepIndex}] Status: Hide - Site does NOT accept hide, applying rule: ${rule}`);
          shouldApplyRule = true;
        }
      } else if (clientStatus === 'Overlaps') {
        // Overlaps: Normalize first (already done), then check if site accepts
        if (siteConfig.acceptOverlapHours) {
          console.log(`‚úÖ [${stepIndex}] Status: Overlaps - Site accepts overlap hours, passing through normalized result`);
          return {
            success: true,
            normalizedDays: normalizedDays,
            processedData: {}
          };
        } else {
          console.log(`üîß [${stepIndex}] Status: Overlaps - Site does NOT accept overlap, applying rule: ${rule}`);
          shouldApplyRule = true;
        }
      }
      
      // Step 3: Apply rule if needed
      if (shouldApplyRule && rule) {
        normalizedDays = applyRule(normalizedDays, rule);
        console.log(`‚úÖ [${stepIndex}] Applied rule: ${rule}`);
      }
      
      // Step 4: Convert processed days back to flatData format
      const processedData = {};
      const dayKeys = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun', 'holiday'];
      const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Holiday'];
      
      for (const day of normalizedDays) {
        const dayIndex = dayNames.indexOf(day.day);
        if (dayIndex >= 0) {
          const dayKey = dayKeys[dayIndex];
          
          if (day.isHidden && rule === 'HIDE_AND_CONSOLIDATE' && day.fallbackSegment) {
            // Use fallback consolidated segment
            if (dayKey === 'holiday') {
              processedData.holidayAm = day.fallbackSegment.start;
              processedData.holidayPm = day.fallbackSegment.end;
            } else {
              processedData[`${dayKey}Am`] = day.fallbackSegment.start;
              processedData[`${dayKey}Pm`] = day.fallbackSegment.end;
            }
          } else if (!day.isHidden && day.segments.length > 0) {
            // Use first segment (or consolidated segment)
            const segment = day.segments[0];
            if (dayKey === 'holiday') {
              processedData.holidayAm = segment.start;
              processedData.holidayPm = segment.end;
            } else {
              processedData[`${dayKey}Am`] = segment.start;
              processedData[`${dayKey}Pm`] = segment.end;
            }
          } else if (day.isHidden) {
            // Clear hidden days
            if (dayKey === 'holiday') {
              processedData.holidayAm = '';
              processedData.holidayPm = '';
            } else {
              processedData[`${dayKey}Am`] = '';
              processedData[`${dayKey}Pm`] = '';
            }
          }
        }
      }
      
      console.log(`‚úÖ [${stepIndex}] Business hours automation completed successfully`);
      return {
        success: true,
        normalizedDays: normalizedDays,
        processedData: processedData
      };
      
    } catch (error) {
      console.error(`‚ùå [${stepIndex}] Business hours automation error:`, error);
      return {
        success: false,
        error: error.message,
        normalizedDays: [],
        processedData: {}
      };
    }
  }

  /**
   * ROBUST HOUR FIELD AUTO-DETECTION AND FILLING
   * Automatically detects all hour fields on the page and fills them according to business hours rules
   */

  /**
   * Detect all hour fields on the page using multiple strategies
   * @param {HTMLElement} contextElement - Optional context element to search within
   * @returns {Array<{element: HTMLElement, day: string, period: string, confidence: number}>} Detected fields
   */
  function detectHourFields(contextElement = null) {
    const detectedFields = [];
    const searchRoot = contextElement || document;
    
    // Day patterns (abbreviations and full names)
    const dayPatterns = {
      'mon': ['monday', 'mon', 'mo'],
      'tue': ['tuesday', 'tue', 'tu'],
      'wed': ['wednesday', 'wed', 'we'],
      'thu': ['thursday', 'thu', 'th'],
      'fri': ['friday', 'fri', 'fr'],
      'sat': ['saturday', 'sat', 'sa'],
      'sun': ['sunday', 'sun', 'su'],
      'holiday': ['holiday', 'holidays', 'hol']
    };
    
    // Period patterns
    const periodPatterns = {
      'am': ['open', 'opening', 'start', 'from', 'am', 'morning', 'begin'],
      'pm': ['close', 'closing', 'end', 'to', 'until', 'pm', 'evening', 'finish']
    };
    
    // Find all potential hour fields (SELECT, INPUT, elements with time-related attributes)
    // Also find toggle checkboxes for open/close status
    // Use more comprehensive selectors to catch all possible hour field patterns
    // IMPORTANT: Include _am and _pm patterns explicitly for dl#anw-hour1 structure
    // CRITICAL: Also include TD/TH elements with time-related IDs (they contain the actual inputs)
    const potentialFields = searchRoot.querySelectorAll(`
      select,
      input[type="text"],
      input[type="time"],
      input[type="number"],
      input[type="checkbox"][id*="open"],
      input[type="checkbox"][name*="open"],
      [role="combobox"],
      [data-hour],
      [data-time],
      [class*="hour"],
      [class*="time"],
      [class*="open"],
      [class*="close"],
      [class*="start"],
      [class*="end"],
      [id*="hour"],
      [id*="time"],
      [id*="open"],
      [id*="close"],
      [id*="start"],
      [id*="end"],
      [name*="hour"],
      [name*="time"],
      [name*="open"],
      [name*="close"],
      [name*="start"],
      [name*="end"],
      [name*="_am"],
      [name*="_pm"],
      [id*="_am"],
      [id*="_pm"],
      select[name*="_am"],
      select[name*="_pm"],
      dl#anw-hour1 select,
      #anw-hour1 select,
      dl[id*="hour"] select,
      td[id*="time"],
      td[id*="hour"],
      th[id*="time"],
      th[id*="hour"]
    `);
    
    console.log(`üîç [detectHourFields] Found ${potentialFields.length} potential fields to analyze`);
    
    // Pre-scan for Saturday fields (for debugging)
    const satFieldsPreScan = Array.from(potentialFields).filter(f => {
      const fText = `${f.id || ''} ${f.name || ''} ${f.className || ''}`.toLowerCase();
      return fText.includes('sat') || fText.includes('saturday');
    });
    if (satFieldsPreScan.length > 0) {
      console.log(`üîç [detectHourFields] Pre-scan found ${satFieldsPreScan.length} fields with Saturday indicators:`, 
        satFieldsPreScan.map(f => `id="${f.id}", name="${f.name}", tag="${f.tagName}"`));
    }
    
    // Filter and analyze each field
    let analyzedCount = 0;
    let saturdayCandidateCount = 0;
    
    potentialFields.forEach(field => {
      // Skip if not visible
      const style = window.getComputedStyle(field);
      if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
        return;
      }
      
      analyzedCount++;
      
      // CRITICAL FIX: Handle table elements (TD, TH, TR, TABLE) - they're containers, not input fields
      // Look inside them for actual form elements and use container's ID/name for day detection
      let actualField = field;
      let containerContext = null;
      
      if (['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD'].includes(field.tagName)) {
        // This is a container element - look inside for actual input/select
        const actualInput = field.querySelector('select, input[type="text"], input[type="time"], input[type="number"], input');
        if (actualInput) {
          // Store container context for day detection (container might have day info in ID/name)
          containerContext = {
            id: (field.id || '').toLowerCase(),
            name: (field.name || '').toLowerCase(),
            className: (field.className || '').toLowerCase()
          };
          actualField = actualInput; // Use actual input for filling
          console.log(`üîç [detectHourFields] Found container (${field.tagName}) with id="${field.id || ''}", extracted ${actualField.tagName} inside`);
        } else {
          console.log(`‚ö†Ô∏è [detectHourFields] Container (${field.tagName}) with id="${field.id || ''}" does not contain any input/select elements`);
          return; // Skip container elements that don't contain form inputs
        }
      }
      
      // Get field identifiers (use container context if available, otherwise use field itself)
      const id = containerContext ? containerContext.id : (actualField.id || '').toLowerCase();
      const name = containerContext ? containerContext.name : (actualField.name || '').toLowerCase();
      const className = containerContext ? containerContext.className : (actualField.className || '').toLowerCase();
      
      // Early check for Saturday indicators (for debugging)
      const fieldText = `${id} ${name} ${className}`.toLowerCase();
      if (fieldText.includes('sat') || fieldText.includes('saturday')) {
        saturdayCandidateCount++;
        console.log(`üîç [detectHourFields] Saturday candidate field ${saturdayCandidateCount}: id="${id}", name="${name}", tag="${actualField.tagName}"`);
      }
      
      // Skip non-SELECT elements that don't have hour-related attributes (for this specific format)
      // But keep all SELECT elements as they might be hour fields
      // CRITICAL: If we have containerContext with hour indicators, always accept SELECT elements
      if (actualField.tagName !== 'SELECT') {
        // For non-SELECT, require explicit hour indicators
        const hasHourIndicator = actualField.type === 'time' || 
                                 actualField.getAttribute('data-hour') || 
                                 actualField.getAttribute('data-time') ||
                                 (actualField.id && (actualField.id.includes('hour') || actualField.id.includes('time'))) ||
                                 (actualField.name && (actualField.name.includes('hour') || actualField.name.includes('time'))) ||
                                 (containerContext && (containerContext.id.includes('hour') || containerContext.id.includes('time') || 
                                                       containerContext.name.includes('hour') || containerContext.name.includes('time')));
        if (!hasHourIndicator) {
          console.log(`‚ö†Ô∏è [detectHourFields] Skipping ${actualField.tagName} element: no hour indicators (id="${actualField.id || ''}", name="${actualField.name || ''}")`);
          return;
        }
      } else if (containerContext) {
        // SELECT element inside container with hour indicators - always accept
        console.log(`‚úÖ [detectHourFields] Accepting SELECT element inside container with hour indicators (container id="${containerContext.id}")`);
      }
      const label = (actualField.closest('label')?.textContent || '').toLowerCase();
      const placeholder = (actualField.placeholder || '').toLowerCase();
      const ariaLabel = (actualField.getAttribute('aria-label') || '').toLowerCase();
      const dataHour = (actualField.getAttribute('data-hour') || '').toLowerCase();
      const dataTime = (actualField.getAttribute('data-time') || '').toLowerCase();
      
      // Combine all text for analysis
      const allText = `${id} ${name} ${className} ${label} ${placeholder} ${ariaLabel} ${dataHour} ${dataTime}`.toLowerCase();
      
      // Check if this looks like an hour field
      // IMPORTANT: Include _am and _pm patterns explicitly (for dl#anw-hour1 structure)
      // CRITICAL: If we have containerContext with hour indicators, treat as hour field
      const hasContainerHourIndicator = containerContext && (
        containerContext.id.includes('hour') || containerContext.id.includes('time') ||
        containerContext.name.includes('hour') || containerContext.name.includes('time') ||
        containerContext.className.includes('hour') || containerContext.className.includes('time')
      );
      
      const isHourField = 
        allText.includes('hour') ||
        allText.includes('time') ||
        allText.includes('open') ||
        allText.includes('close') ||
        allText.includes('start') ||
        allText.includes('end') ||
        name.includes('_am') || name.includes('_pm') ||
        id.includes('_am') || id.includes('_pm') ||
        actualField.type === 'time' ||
        actualField.getAttribute('data-hour') ||
        actualField.getAttribute('data-time') ||
        hasContainerHourIndicator || // Accept if container has hour indicators
        // If it's a SELECT in dl#anw-hour1 structure, assume it's an hour field
        (actualField.tagName === 'SELECT' && (actualField.closest('dl#anw-hour1') || actualField.closest('#anw-hour1') || actualField.closest('dl[id*="hour"]'))) ||
        // If it's a SELECT inside #hours-of-operation, assume it's an hour field
        (actualField.tagName === 'SELECT' && actualField.closest('#hours-of-operation'));
      
      if (!isHourField) {
        console.log(`‚ö†Ô∏è [detectHourFields] Field rejected by isHourField check: tagName=${actualField.tagName}, id="${id}", name="${name}", containerContext=${containerContext ? 'yes' : 'no'}`);
        return;
      }
      
      console.log(`‚úÖ [detectHourFields] Field passed isHourField check: tagName=${actualField.tagName}, id="${id}", name="${name}"`);
      
      // Try to match day
      let matchedDay = null;
      let dayConfidence = 0;
      
      // IMPORTANT: Process days in order, but prioritize weekday patterns over holiday
      // This ensures "sat" matches before "holiday" if both patterns exist
      const dayPriorityOrder = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun', 'holiday'];
      
      // Special handling for abbreviated day patterns in IDs (e.g., "mo-time", "tu-time", "we-time")
      // These are common in table-based hour structures
      const abbreviatedDayMap = {
        'mo': 'mon', 'tu': 'tue', 'we': 'wed', 'th': 'thu',
        'fr': 'fri', 'sa': 'sat', 'su': 'sun'
      };
      
      // Check for abbreviated patterns first (higher priority for IDs)
      if (id || name) {
        for (const [abbrev, dayKey] of Object.entries(abbreviatedDayMap)) {
          // Match patterns like "mo-time", "tu-time", "mo_time", etc.
          const abbrevPattern = new RegExp(`^${abbrev}[_-]|${abbrev}[_-]`, 'i');
          if (abbrevPattern.test(id) || abbrevPattern.test(name)) {
            matchedDay = dayKey;
            dayConfidence = 0.95; // Very high confidence for ID/name patterns
            break;
          }
        }
      }
      
      // If no abbreviated match, try full patterns
      if (!matchedDay) {
        for (const dayKey of dayPriorityOrder) {
          const patterns = dayPatterns[dayKey];
          for (const pattern of patterns) {
            // Use word boundary for better matching (avoids "saturday" matching "holiday")
            const wordBoundaryPattern = new RegExp(`\\b${pattern}\\b`, 'i');
            if (wordBoundaryPattern.test(allText)) {
              // Calculate confidence based on position and context
              let confidence = 0.5;
              
              // Higher confidence if in id or name
              if (wordBoundaryPattern.test(id) || wordBoundaryPattern.test(name)) {
                confidence = 0.9;
              }
              // Medium confidence if in class
              else if (wordBoundaryPattern.test(className)) {
                confidence = 0.7;
              }
              // Lower confidence if in label or other text
              else {
                confidence = 0.5;
              }
              
              // Only update if this match has higher confidence OR if we haven't matched yet
              // This ensures we get the best match, not just the first match
              if (confidence > dayConfidence || (matchedDay === null && confidence > 0)) {
                matchedDay = dayKey;
                dayConfidence = confidence;
              }
            }
          }
        }
      }
      
      // Log if field has Saturday indicators but didn't match
      if (!matchedDay && (allText.includes('sat') || allText.includes('saturday') || id.includes('sat') || name.includes('sat'))) {
        console.warn(`‚ö†Ô∏è [detectHourFields] Field with Saturday indicator but no match: id="${id}", name="${name}", allText="${allText.substring(0, 150)}"`);
      }
      
      // Special handling for hoursOfOperation structure - check parent form-group for day labels
      if (!matchedDay) {
        const formGroup = actualField.closest('.form-group, [class*="form-group"], .hoursOfOperation');
        if (formGroup) {
          const formGroupText = formGroup.textContent.toLowerCase();
          for (const [dayKey, patterns] of Object.entries(dayPatterns)) {
            for (const pattern of patterns) {
              if (formGroupText.includes(pattern)) {
                // Check if this field is likely related to this day (in same form-group)
                // Look for day label near the field
                const label = formGroup.querySelector('label');
                if (label && label.textContent.toLowerCase().includes(pattern)) {
                  matchedDay = dayKey;
                  dayConfidence = 0.6; // Medium confidence for form-group matching
                  break;
                }
              }
            }
            if (matchedDay) break;
          }
        }
      }
      
      // Additional check: Look for day in nearby sibling elements (for hoursOfOperation structure)
      if (!matchedDay && actualField.parentElement) {
        const siblings = Array.from(actualField.parentElement.children);
        for (const sibling of siblings) {
          if (sibling !== field && sibling.textContent) {
            const siblingText = sibling.textContent.toLowerCase();
            for (const [dayKey, patterns] of Object.entries(dayPatterns)) {
              for (const pattern of patterns) {
                // Check if sibling contains day pattern (e.g., "Sat", "Saturday")
                // Use word boundary to avoid false matches
                const wordBoundaryPattern = new RegExp(`\\b${pattern}\\b`, 'i');
                if (wordBoundaryPattern.test(siblingText)) {
                  matchedDay = dayKey;
                  dayConfidence = 0.55; // Lower confidence for sibling matching
                  console.log(`üîç [detectHourFields] Matched ${dayKey} from sibling text: "${siblingText.substring(0, 50)}"`);
                  break;
                }
              }
              if (matchedDay) break;
            }
          }
          if (matchedDay) break;
        }
      }
      
      // Also check parent and grandparent elements for day labels (for hoursOfOperation structure)
      if (!matchedDay) {
        let currentElement = actualField.parentElement;
        let depth = 0;
        while (currentElement && depth < 3) { // Check up to 3 levels up
          const elementText = currentElement.textContent?.toLowerCase() || '';
          for (const [dayKey, patterns] of Object.entries(dayPatterns)) {
            for (const pattern of patterns) {
              const wordBoundaryPattern = new RegExp(`\\b${pattern}\\b`, 'i');
              if (wordBoundaryPattern.test(elementText)) {
                // Make sure it's not just part of another word by checking context
                // Look for day label patterns like "Sat", "Saturday", or day abbreviations
                const labelElement = currentElement.querySelector('label, .label, [class*="label"]');
                if (labelElement && wordBoundaryPattern.test(labelElement.textContent?.toLowerCase() || '')) {
                  matchedDay = dayKey;
                  dayConfidence = 0.6; // Medium confidence for label matching
                  console.log(`üîç [detectHourFields] Matched ${dayKey} from parent label: "${labelElement.textContent?.substring(0, 50)}"`);
                  break;
                }
              }
            }
            if (matchedDay) break;
          }
          if (matchedDay) break;
          currentElement = currentElement.parentElement;
          depth++;
        }
      }
      
      // Final fallback: For hoursOfOperation structure, detect by position if field is in a form-group row
      if (!matchedDay) {
        const hoursOfOperationContainer = searchRoot.querySelector('.hoursOfOperation, [class*="hoursOfOperation"], [class*="hours-of-operation"]');
        if (hoursOfOperationContainer && hoursOfOperationContainer.contains(actualField)) {
          // Get all form-groups in hoursOfOperation
          const formGroups = Array.from(hoursOfOperationContainer.querySelectorAll('.form-group, [class*="form-group"]'));
          const fieldFormGroup = actualField.closest('.form-group, [class*="form-group"]');
          
          if (fieldFormGroup && formGroups.length > 0) {
            // Find the index of this form-group
            const formGroupIndex = formGroups.indexOf(fieldFormGroup);
            
            // Expected order: Mon, Tue, Wed, Thu, Fri, Sat, Sun (0-6)
            // But we need to account for possible headers or other elements
            // Look for day labels in form-groups to determine actual order
            const dayOrder = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
            let foundDayIndex = -1;
            
            // First, try to find day labels in form-groups
            for (let i = 0; i < formGroups.length; i++) {
              const fg = formGroups[i];
              const fgText = fg.textContent.toLowerCase();
              for (let j = 0; j < dayOrder.length; j++) {
                const dayPatternsForDay = dayPatterns[dayOrder[j]];
                for (const pattern of dayPatternsForDay) {
                  const wordBoundaryPattern = new RegExp(`\\b${pattern}\\b`, 'i');
                  if (wordBoundaryPattern.test(fgText)) {
                    if (i === formGroupIndex) {
                      foundDayIndex = j;
                      break;
                    }
                  }
                }
                if (foundDayIndex >= 0) break;
              }
              if (foundDayIndex >= 0) break;
            }
            
            // If we found a day match for this form-group, use it
            if (foundDayIndex >= 0 && foundDayIndex < dayOrder.length) {
              matchedDay = dayOrder[foundDayIndex];
              dayConfidence = 0.5; // Lower confidence for positional matching
              console.log(`üîç [detectHourFields] Matched ${matchedDay} by position in hoursOfOperation (form-group index: ${formGroupIndex})`);
            } else {
              // Fallback: Use direct positional matching if form-group index is valid
              // This assumes form-groups are in order: Mon(0), Tue(1), Wed(2), Thu(3), Fri(4), Sat(5), Sun(6)
              // Only use this if form-group index is within expected range
              if (formGroupIndex >= 0 && formGroupIndex < dayOrder.length) {
                matchedDay = dayOrder[formGroupIndex];
                dayConfidence = 0.4; // Lower confidence for pure positional matching
                console.log(`üîç [detectHourFields] Matched ${matchedDay} by direct position in hoursOfOperation (form-group index: ${formGroupIndex}, no label found)`);
              } else {
                console.warn(`‚ö†Ô∏è [detectHourFields] Form-group index ${formGroupIndex} out of range (expected 0-6 for Mon-Sun)`);
              }
            }
          }
        }
      }
      
      // Try to match period
      let matchedPeriod = null;
      let periodConfidence = 0;
      
      // Priority 1: Check for explicit _am or _pm in name/id (most reliable)
      if (name.includes('_am') || id.includes('_am')) {
        matchedPeriod = 'am';
        periodConfidence = 1.0; // Highest confidence
      } else if (name.includes('_pm') || id.includes('_pm')) {
        matchedPeriod = 'pm';
        periodConfidence = 1.0; // Highest confidence
      } else if (name.endsWith('am') || id.endsWith('am')) {
        matchedPeriod = 'am';
        periodConfidence = 0.95;
      } else if (name.endsWith('pm') || id.endsWith('pm')) {
        matchedPeriod = 'pm';
        periodConfidence = 0.95;
      } else {
        // Priority 2: Check for period patterns in all text
        for (const [periodKey, patterns] of Object.entries(periodPatterns)) {
          for (const pattern of patterns) {
            if (allText.includes(pattern)) {
              let confidence = 0.5;
              
              if (id.includes(pattern) || name.includes(pattern)) {
                confidence = 0.9;
              } else if (className.includes(pattern)) {
                confidence = 0.7;
              } else {
                confidence = 0.5;
              }
              
              if (confidence > periodConfidence) {
                matchedPeriod = periodKey;
                periodConfidence = confidence;
              }
            }
          }
        }
      }
      
      // Priority 3: Check for sel-hour2 class (indicates PM field in this format)
      if (!matchedPeriod && actualField.classList && actualField.classList.contains('sel-hour2')) {
        matchedPeriod = 'pm';
        periodConfidence = 0.8;
      }
      
      // Skip if this is a toggle checkbox (handled separately)
      if (actualField.type === 'checkbox' && (allText.includes('isopen') || allText.includes('open') && !allText.includes('time'))) {
        return;
      }
      
      // If we found at least a day, add to detected fields
      // SPECIAL CASE: If we have a container with hour indicators and a SELECT element, 
      // try to infer day from container even if not explicitly matched
      if (!matchedDay && containerContext && actualField.tagName === 'SELECT') {
        // Try abbreviated day patterns from container ID/name one more time
        const containerId = containerContext.id;
        const containerName = containerContext.name;
        const abbreviatedDayMap = {
          'mo': 'mon', 'tu': 'tue', 'we': 'wed', 'th': 'thu',
          'fr': 'fri', 'sa': 'sat', 'su': 'sun'
        };
        
        for (const [abbrev, dayKey] of Object.entries(abbreviatedDayMap)) {
          const abbrevPattern = new RegExp(`^${abbrev}[_-]|${abbrev}[_-]`, 'i');
          if (abbrevPattern.test(containerId) || abbrevPattern.test(containerName)) {
            matchedDay = dayKey;
            dayConfidence = 0.9; // High confidence for container-based match
            console.log(`‚úÖ [detectHourFields] Matched day ${dayKey} from container context: id="${containerId}", name="${containerName}"`);
            break;
          }
        }
      }
      
      if (matchedDay) {
        // If no period found, try to infer from position or context
        if (!matchedPeriod) {
          // Check if field is in a dd element with multiple selects (dl#anw-hour1 structure)
          const dd = actualField.closest('dd');
          if (dd) {
            const allSelects = Array.from(dd.querySelectorAll('select'));
            if (allSelects.length >= 2) {
              const selectIndex = allSelects.indexOf(actualField);
              // First select = AM, second select = PM
              matchedPeriod = selectIndex === 0 ? 'am' : 'pm';
              periodConfidence = 0.7; // Higher confidence for structured format
            }
          }
          
          // If still no period, try general position heuristic
          if (!matchedPeriod) {
            const parent = actualField.parentElement;
            const siblings = parent ? Array.from(parent.children) : [];
            const fieldIndex = siblings.indexOf(actualField);
            const totalFields = siblings.length;
            
            // Heuristic: if field is in first half, likely opening; second half, likely closing
            if (totalFields > 1) {
              matchedPeriod = fieldIndex < totalFields / 2 ? 'am' : 'pm';
              periodConfidence = 0.4; // Lower confidence for inferred
            } else {
              // Default to opening if uncertain
              matchedPeriod = 'am';
              periodConfidence = 0.3;
            }
          }
        }
        
        const overallConfidence = (dayConfidence + periodConfidence) / 2;
        
        // Log Saturday fields specifically for debugging
        if (matchedDay === 'sat') {
          const fieldId = id;
          const fieldName = name;
          console.log(`üîç [detectHourFields] Found Saturday field: id="${fieldId}", name="${fieldName}", period="${matchedPeriod}", confidence=${overallConfidence.toFixed(2)}`);
        }
        
        detectedFields.push({
          element: actualField, // Use actual input element, not container
          day: matchedDay,
          period: matchedPeriod,
          confidence: overallConfidence,
          identifiers: { id, name, className, label, placeholder }
        });
      } else {
        // Log fields that didn't match any day (for debugging Saturday issue)
        if (allText.includes('sat') || allText.includes('saturday') || id.includes('sat') || name.includes('sat')) {
          console.warn(`‚ö†Ô∏è [detectHourFields] Field with Saturday indicator but no day match: id="${id}", name="${name}", allText="${allText.substring(0, 100)}"`);
        }
      }
    });
    
    // Sort by confidence (highest first)
    detectedFields.sort((a, b) => b.confidence - a.confidence);
    
    // Remove duplicates (same element) but keep both AM and PM for same day
    const uniqueFields = [];
    const seenElements = new Set();
    const dayPeriodMap = new Map(); // Track day+period combinations
    
    for (const field of detectedFields) {
      const elementKey = `${field.element.tagName}_${field.element.id || field.element.name || ''}`;
      const dayPeriodKey = `${field.day}_${field.period}`;
      
      // Only skip if it's the exact same element, not just same day+period
      if (!seenElements.has(field.element)) {
        seenElements.add(field.element);
        
        // Check if we already have this day+period combination (avoid duplicates)
        if (!dayPeriodMap.has(dayPeriodKey)) {
          dayPeriodMap.set(dayPeriodKey, true);
          uniqueFields.push(field);
        } else {
          // If we have a duplicate day+period, keep the one with higher confidence
          const existingIndex = uniqueFields.findIndex(f => f.day === field.day && f.period === field.period);
          if (existingIndex >= 0 && field.confidence > uniqueFields[existingIndex].confidence) {
            uniqueFields[existingIndex] = field;
          }
        }
      }
    }
    
    // Log detected fields for debugging
    console.log(`üîç Detected ${uniqueFields.length} unique hour fields:`, 
      uniqueFields.map(f => `${f.day}${f.period} (conf: ${f.confidence.toFixed(2)})`).join(', '));
    
    // Check if Saturday fields are missing
    const hasSaturday = uniqueFields.some(f => f.day === 'sat');
    if (!hasSaturday) {
      console.warn(`‚ö†Ô∏è [detectHourFields] Saturday fields not detected! Expected satAm and satPm.`);
      console.warn(`‚ö†Ô∏è [detectHourFields] Detected days: ${[...new Set(uniqueFields.map(f => f.day))].join(', ')}`);
      
      // Try to find Saturday fields manually for debugging
      const allFields = searchRoot.querySelectorAll('select, input[type="text"], input[type="time"]');
      const satFields = Array.from(allFields).filter(f => {
        const fText = `${f.id || ''} ${f.name || ''} ${f.className || ''} ${f.closest('.form-group')?.textContent || ''}`.toLowerCase();
        return fText.includes('sat') || fText.includes('saturday');
      });
      
      if (satFields.length > 0) {
        console.warn(`‚ö†Ô∏è [detectHourFields] Found ${satFields.length} potential Saturday fields that weren't detected:`, 
          satFields.map(f => `id="${f.id}", name="${f.name}"`));
      }
    }
    
    return uniqueFields;
  }

  /**
   * Fill a single hour field with the provided value
   * @param {HTMLElement} field - Field element to fill
   * @param {string} hourValue - Hour value to fill (12h or 24h format)
   * @param {number} stepIndex - Step index for logging
   * @returns {boolean} Success status
   */
  async function fillHourField(field, hourValue, stepIndex, forceFill = false) {
    if (!field || !hourValue || hourValue.trim() === '') {
      if (!field) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] fillHourField: field is null/undefined`);
      } else if (!hourValue || hourValue.trim() === '') {
        console.warn(`‚ö†Ô∏è [${stepIndex}] fillHourField: hourValue is empty for field ${field.id || field.name}`);
      }
      return false;
    }
    
    // CRITICAL FIX: Handle container elements (TD, TH, etc.) by finding actual input inside
    if (['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD', 'DIV', 'SPAN'].includes(field.tagName)) {
      const actualInput = field.querySelector('select, input[type="text"], input[type="time"], input[type="number"]');
      if (actualInput) {
        console.log(`üîÑ [${stepIndex}] Found container element (${field.tagName}), using inner input: ${actualInput.tagName} ${actualInput.id || actualInput.name || ''}`);
        field = actualInput; // Replace with actual input element
      } else {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Container element (${field.tagName}) with id="${field.id || ''}" does not contain any input/select elements`);
        return false;
      }
    }
    
    // CRITICAL: Always attempt to remove readonly/disabled for INPUT elements (they often need this)
    // For SELECT elements, only do this if forceFill is true
    if (field.tagName === 'INPUT' && (field.readOnly || field.disabled)) {
      console.log(`üîÑ [${stepIndex}] INPUT field is readonly/disabled, removing attributes: ${field.id || field.name || 'unnamed'}`);
      try {
        field.readOnly = false;
        field.removeAttribute('readonly');
        if (field.disabled) {
          field.disabled = false;
          field.removeAttribute('disabled');
        }
        console.log(`‚úÖ [${stepIndex}] Removed readonly/disabled attributes from INPUT field`);
      } catch (e) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Could not remove readonly/disabled: ${e.message}`);
        // Continue anyway - some sites allow setting value even if readonly
      }
    } else if (field.readOnly || field.disabled) {
      // For SELECT and other elements, only remove if forceFill is true
      if (forceFill) {
        console.log(`üîÑ [${stepIndex}] Field is readonly/disabled, attempting to remove attributes: ${field.id || field.name}`);
        try {
          field.readOnly = false;
          field.removeAttribute('readonly');
          if (field.disabled) {
            field.disabled = false;
            field.removeAttribute('disabled');
          }
          // Trigger events to notify site handlers
          field.dispatchEvent(new Event('change', { bubbles: true }));
          field.dispatchEvent(new Event('input', { bubbles: true }));
          console.log(`‚úÖ [${stepIndex}] Removed readonly/disabled attributes from field`);
        } catch (e) {
          console.warn(`‚ö†Ô∏è [${stepIndex}] Could not remove readonly/disabled: ${e.message}`);
          // Still try to fill even if we can't remove readonly
        }
      } else {
        console.log(`‚ÑπÔ∏è [${stepIndex}] Skipping readonly/disabled field: ${field.id || field.name || 'unnamed'}`);
        return false;
      }
    }
    
    try {
      const hour24 = convertTo24Hour(String(hourValue).trim());
      
      // For time input fields, ensure readonly is removed if needed
      if (field.type === 'time' && field.readOnly) {
        field.readOnly = false;
      }
      
      if (field.tagName === 'SELECT') {
        const options = Array.from(field.options);
        let matchedOption = null;
        
        // Try multiple matching strategies
        // Strategy 1: Value match
        matchedOption = options.find(opt => {
          const optValue = String(opt.value).trim();
          return optValue === hour24 || optValue === hourValue.trim();
        });
        
        // Strategy 2: Text match
        if (!matchedOption) {
          matchedOption = options.find(opt => {
            const optText = opt.textContent.trim().toLowerCase();
            return optText === hour24.toLowerCase() || optText === hourValue.trim().toLowerCase();
          });
        }
        
        // Strategy 3: Normalized match
        if (!matchedOption) {
          const normalizeTime = (timeStr) => {
            return timeStr.toLowerCase()
              .replace(/\s+/g, '')
              .replace(/[ap]m/gi, '')
              .replace(/:/g, '')
              .replace(/^0+/, '');
          };
          
          const normalized24 = normalizeTime(hour24);
          matchedOption = options.find(opt => {
            const optText = normalizeTime(opt.textContent.trim());
            const optValue = normalizeTime(opt.value);
            return optText === normalized24 || optValue === normalized24;
          });
        }
        
        if (matchedOption) {
          field.value = matchedOption.value;
          field.dispatchEvent(new Event('change', { bubbles: true }));
          field.dispatchEvent(new Event('input', { bubbles: true }));
          field.style.border = '2px solid #4CAF50';
          console.log(`‚úÖ [${stepIndex}] Filled SELECT field ${field.id || field.name || 'unnamed'}: "${hourValue}" -> "${matchedOption.value}"`);
          return true;
        } else {
          console.warn(`‚ö†Ô∏è [${stepIndex}] No matching option found for SELECT field ${field.id || field.name || 'unnamed'}: value="${hourValue}", hour24="${hour24}", options count=${options.length}`);
          // Log first few option values for debugging
          if (options.length > 0) {
            const sampleOptions = options.slice(0, 5).map(opt => `"${opt.value}" (text: "${opt.textContent.trim()}")`).join(', ');
            console.warn(`‚ö†Ô∏è [${stepIndex}] Sample options: ${sampleOptions}${options.length > 5 ? '...' : ''}`);
          }
        }
      } else if (field.tagName === 'INPUT') {
        // CRITICAL: Remove readonly/disabled attributes before setting value
        if (field.readOnly) {
          field.readOnly = false;
          field.removeAttribute('readonly');
        }
        if (field.disabled) {
          field.disabled = false;
          field.removeAttribute('disabled');
        }
        
        // Determine the correct format based on input type
        let valueToSet = hour24;
        if (field.type === 'time') {
          // Time inputs need HH:MM format (already in hour24)
          valueToSet = hour24;
        } else {
          // For text inputs, try both 24-hour and 12-hour formats
          // Some sites might prefer one over the other
          valueToSet = hour24;
        }
        
        // Method 1: Direct value assignment
        field.value = valueToSet;
        field.setAttribute('value', valueToSet);
        
        // Method 2: Focus and clear first (some time pickers need this)
        field.focus();
        field.click(); // Click to activate time picker if present
        
        // Method 3: Clear existing value and set new one
        if (field.value !== valueToSet) {
          field.value = '';
          await delay(10); // Small delay
          field.value = valueToSet;
        }
        
        // Method 4: Use Object.defineProperty to bypass getters/setters if needed
        try {
          Object.defineProperty(field, 'value', {
            value: valueToSet,
            writable: true,
            configurable: true
          });
        } catch (e) {
          // Ignore if we can't override property
        }
        
        // Trigger multiple events to ensure the site's JavaScript picks it up
        const events = ['input', 'change', 'blur', 'keyup', 'keydown', 'focus'];
        events.forEach(eventType => {
          const event = new Event(eventType, { bubbles: true, cancelable: true });
          field.dispatchEvent(event);
        });
        
        // Also trigger native events (some sites listen to these)
        if (field.dispatchEvent) {
          const nativeInput = new Event('input', { bubbles: true, cancelable: true });
          nativeInput.target = field;
          field.dispatchEvent(nativeInput);
        }
        
        // Execute once, then verify (no retry on validation failure)
        await delay(50);
        const actualValue = field.value || field.getAttribute('value') || '';
        
        field.style.border = '2px solid #4CAF50';
        
        // Final verification
        const finalValue = field.value || field.getAttribute('value') || '';
        if (finalValue === valueToSet || finalValue === hour24 || finalValue.includes(hour24.split(':')[0])) {
          console.log(`‚úÖ [${stepIndex}] Filled INPUT field ${field.id || field.name || 'unnamed'}: "${hourValue}" -> "${valueToSet}" (verified: "${finalValue}")`);
          return true;
        } else {
          console.warn(`‚ö†Ô∏è [${stepIndex}] INPUT field value may not have persisted: expected "${valueToSet}", got "${finalValue}"`);
          // Still return true as we tried our best - the value might be there but not visible
          return true;
        }
      } else {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Unsupported field type: ${field.tagName} for field ${field.id || field.name || 'unnamed'}`);
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Error filling hour field ${field.id || field.name || 'unnamed'}:`, error);
      return false;
    }
    
    console.warn(`‚ö†Ô∏è [${stepIndex}] fillHourField failed for ${field.id || field.name || 'unnamed'}: tagName=${field.tagName}, value="${hourValue}"`);
    return false;
  }

  /**
   * Detect toggle checkboxes for open/close status (including slider-style toggles)
   * @param {HTMLElement} contextElement - Optional context element to search within
   * @returns {Array<{element: HTMLElement, day: string, formGroup: HTMLElement}>} Detected toggle checkboxes
   */
  function detectToggleCheckboxes(contextElement = null) {
    const detectedToggles = [];
    const searchRoot = contextElement || document;
    
    // Day patterns for toggle checkboxes
    const dayPatterns = {
      'mon': ['monday', 'mon', 'mo'],
      'tue': ['tuesday', 'tue', 'tu'],
      'wed': ['wednesday', 'wed', 'we'],
      'thu': ['thursday', 'thu', 'th'],
      'fri': ['friday', 'fri', 'fr'],
      'sat': ['saturday', 'sat', 'sa'],
      'sun': ['sunday', 'sun', 'su'],
      'holiday': ['holiday', 'holidays', 'hol']
    };
    
    // Strategy 1: Find checkboxes directly (including those inside slider switches)
    const checkboxSelectors = [
      'input[type="checkbox"][id*="open"]',
      'input[type="checkbox"][name*="open"]',
      'input[type="checkbox"][id*="isopen"]',
      'input[type="checkbox"][name*="isopen"]',
      'input[type="checkbox"][id*="IsOpen"]',
      'input[type="checkbox"][name*="IsOpen"]',
      // Slider-style toggles (inside .switch or .slider containers)
      '.switch input[type="checkbox"]',
      '.slider input[type="checkbox"]',
      'label.switch input[type="checkbox"]',
      '[class*="switch"] input[type="checkbox"]'
    ];
    
    const allCheckboxes = new Set();
    
    // Collect all potential toggle checkboxes
    checkboxSelectors.forEach(selector => {
      try {
        const checkboxes = searchRoot.querySelectorAll(selector);
        checkboxes.forEach(cb => allCheckboxes.add(cb));
      } catch (e) {
        // Invalid selector, skip
      }
    });
    
    // Strategy 2: Find by form-group structure (more reliable for slider-style toggles)
    const formGroups = searchRoot.querySelectorAll('.form-group, [class*="form-group"], [class*="hours"], dl, dt, dd');
    formGroups.forEach(formGroup => {
      // Look for checkboxes inside switch/slider containers within form-group
      const switchCheckboxes = formGroup.querySelectorAll(`
        .switch input[type="checkbox"],
        label.switch input[type="checkbox"],
        [class*="switch"] input[type="checkbox"],
        input[type="checkbox"][id*="open"],
        input[type="checkbox"][name*="open"],
        input[type="checkbox"][id*="IsOpen"],
        input[type="checkbox"][name*="IsOpen"],
        input[type="checkbox"]
      `);
      
      switchCheckboxes.forEach(checkbox => {
        allCheckboxes.add(checkbox);
      });
    });
    
    // Strategy 3: For hoursOfOperation structure, find checkboxes in form-groups
    const hoursOfOperationContainer = searchRoot.querySelector('.hoursOfOperation, [class*="hoursOfOperation"], [class*="hours-of-operation"]');
    if (hoursOfOperationContainer) {
      const opFormGroups = hoursOfOperationContainer.querySelectorAll('.form-group, [class*="form-group"]');
      opFormGroups.forEach(formGroup => {
        // Look for checkboxes with IsOpen pattern (e.g., IsOpenMonday, IsOpenTuesday)
        const isOpenCheckboxes = formGroup.querySelectorAll('input[type="checkbox"][id*="IsOpen"], input[type="checkbox"][name*="IsOpen"]');
        isOpenCheckboxes.forEach(cb => allCheckboxes.add(cb));
        
        // Also get all checkboxes in switch containers
        const switchCheckboxes = formGroup.querySelectorAll('.switch input[type="checkbox"], label.switch input[type="checkbox"]');
        switchCheckboxes.forEach(cb => allCheckboxes.add(cb));
      });
    }
    
    // Strategy 4: For dl#anw-hour1 structure, find checkboxes near day labels
    const hourContainer = searchRoot.querySelector('dl#anw-hour1, #anw-hour1, dl[id*="hour"]');
    if (hourContainer) {
      const dayLabels = hourContainer.querySelectorAll('dt label, label, dt');
      dayLabels.forEach(label => {
        const labelText = label.textContent.toLowerCase();
        // Check if label contains a day name
        const hasDayName = Object.values(dayPatterns).some(patterns => 
          patterns.some(pattern => labelText.includes(pattern))
        );
        
        if (hasDayName) {
          // Look for checkbox in same dt or nearby
          const dt = label.closest('dt') || label.parentElement;
          const nearbyCheckboxes = dt ? dt.querySelectorAll('input[type="checkbox"]') : [];
          nearbyCheckboxes.forEach(cb => allCheckboxes.add(cb));
          
          // Also check in parent dl
          const parentCheckboxes = hourContainer.querySelectorAll('input[type="checkbox"]');
          parentCheckboxes.forEach(cb => allCheckboxes.add(cb));
        }
      });
    }
    
    // Process all collected checkboxes
    allCheckboxes.forEach(checkbox => {
      // Skip if not visible
      const style = window.getComputedStyle(checkbox);
      if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
        return;
      }
      
      const id = (checkbox.id || '').toLowerCase();
      const name = (checkbox.name || '').toLowerCase();
      const className = (checkbox.className || '').toLowerCase();
      const label = (checkbox.closest('label')?.textContent || '').toLowerCase();
      const parentText = (checkbox.parentElement?.textContent || '').toLowerCase();
      const allText = `${id} ${name} ${className} ${label} ${parentText}`.toLowerCase();
      
      // Enhanced toggle checkbox detection - more patterns
      // IMPORTANT: Check for IsOpen pattern (e.g., IsOpenMonday, IsOpenTuesday) - highest priority
      const hasIsOpenPattern = id.includes('isopen') || name.includes('isopen') || 
                               id.match(/isopen(monday|tuesday|wednesday|thursday|friday|saturday|sunday|holiday)/i) ||
                               name.match(/isopen(monday|tuesday|wednesday|thursday|friday|saturday|sunday|holiday)/i);
      
      const isToggleCheckbox = hasIsOpenPattern ||
        ((allText.includes('open') || allText.includes('isopen') || allText.includes('closed') || 
         allText.includes('enable') || allText.includes('active') || allText.includes('status')) &&
        !allText.includes('time') &&
        !allText.includes('hour') &&
        !allText.includes('opening') && // Exclude "opening hours" fields
        !allText.includes('closing')); // Exclude "closing hours" fields
      
      if (!isToggleCheckbox) {
        return;
      }
      
      // Try to match day - enhanced matching with IsOpen pattern support
      let matchedDay = null;
      let dayConfidence = 0;
      
      // Priority 1: Match from IsOpen pattern (e.g., IsOpenMonday -> monday)
      if (hasIsOpenPattern) {
        const isOpenMatch = (id + ' ' + name).match(/isopen(monday|tuesday|wednesday|thursday|friday|saturday|sunday|holiday)/i);
        if (isOpenMatch) {
          const dayName = isOpenMatch[1].toLowerCase();
          // Map full day name to day key
          const dayNameMap = {
            'monday': 'mon', 'tuesday': 'tue', 'wednesday': 'wed', 'thursday': 'thu',
            'friday': 'fri', 'saturday': 'sat', 'sunday': 'sun', 'holiday': 'holiday'
          };
          matchedDay = dayNameMap[dayName] || null;
          if (matchedDay) {
            dayConfidence = 1.0; // Highest confidence for IsOpen pattern
          }
        }
      }
      
      // Priority 2: Match from day patterns in id/name/class
      if (!matchedDay) {
        for (const [dayKey, patterns] of Object.entries(dayPatterns)) {
          for (const pattern of patterns) {
            if (allText.includes(pattern)) {
              let confidence = 0.5;
              
              // Higher confidence if day is in id or name
              if (id.includes(pattern) || name.includes(pattern)) {
                confidence = 0.9;
              } else if (className.includes(pattern)) {
                confidence = 0.7;
              }
              
              if (confidence > dayConfidence) {
                matchedDay = dayKey;
                dayConfidence = confidence;
              }
            }
          }
        }
      }
      
      // Priority 3: If no day matched by text, try to infer from context (form-group, nearby labels, etc.)
      if (!matchedDay) {
        const formGroup = checkbox.closest('.form-group, [class*="form-group"], dl, dt, dd, .hoursOfOperation');
        if (formGroup) {
          // Look for day name in label text (e.g., "Mon", "Tue" in label) - important for hoursOfOperation
          const label = formGroup.querySelector('label');
          if (label) {
            const labelText = label.textContent.toLowerCase().trim();
            // Check for day abbreviations (Mon, Tue, etc.) or full names at start of label
            for (const [dayKey, patterns] of Object.entries(dayPatterns)) {
              for (const pattern of patterns) {
                // Match whole word or at start of label text (handles "Mon", "Tue", "Sat", etc.)
                if (labelText === pattern || 
                    labelText.startsWith(pattern + ' ') || 
                    labelText.startsWith(pattern + '\n') ||
                    labelText.match(new RegExp(`^${pattern}\\s`, 'i'))) {
                  matchedDay = dayKey;
                  dayConfidence = 0.8; // High confidence for label match
                  break;
                }
              }
              if (matchedDay) break;
            }
          }
          
          // If still no match, check form-group text content
          if (!matchedDay) {
            const groupText = formGroup.textContent.toLowerCase();
            for (const [dayKey, patterns] of Object.entries(dayPatterns)) {
              for (const pattern of patterns) {
                if (groupText.includes(pattern)) {
                  matchedDay = dayKey;
                  dayConfidence = 0.6;
                  break;
                }
              }
              if (matchedDay) break;
            }
          }
        }
      }
      
      if (matchedDay) {
        // Find the form-group parent for context (including hoursOfOperation)
        const formGroup = checkbox.closest('.form-group, [class*="form-group"], dl, dt, dd, .hoursOfOperation');
        
        detectedToggles.push({
          element: checkbox,
          day: matchedDay,
          formGroup: formGroup || null,
          confidence: dayConfidence
        });
        
        console.log(`üîç [detectToggleCheckboxes] Detected toggle for ${matchedDay}: ${checkbox.id || checkbox.name || 'unnamed'} (confidence: ${dayConfidence.toFixed(2)})`);
      }
    });
    
    // Remove duplicates (same checkbox element)
    const uniqueToggles = [];
    const seenCheckboxes = new Set();
    
    for (const toggle of detectedToggles) {
      if (!seenCheckboxes.has(toggle.element)) {
        seenCheckboxes.add(toggle.element);
        uniqueToggles.push(toggle);
      }
    }
    
    return uniqueToggles;
  }

  function findToggleForDay(day, detectedFields, contextElement, stepIndex) {
    const dayFullNames = {
      'mon': 'monday', 'tue': 'tuesday', 'wed': 'wednesday', 'thu': 'thursday',
      'fri': 'friday', 'sat': 'saturday', 'sun': 'sunday', 'holiday': 'holiday'
    };
    const dayPatterns = {
      'mon': ['monday', 'mon', 'mo'],
      'tue': ['tuesday', 'tue', 'tu'],
      'wed': ['wednesday', 'wed', 'we'],
      'thu': ['thursday', 'thu', 'th'],
      'fri': ['friday', 'fri', 'fr'],
      'sat': ['saturday', 'sat', 'sa'],
      'sun': ['sunday', 'sun', 'su'],
      'holiday': ['holiday', 'holidays', 'hol']
    };

    const searchRoot = contextElement || document;
    const dayFullName = dayFullNames[day];

    if (dayFullName) {
      const isOpenSelector = `input[type="checkbox"][id*="IsOpen${dayFullName}" i], input[type="checkbox"][name*="IsOpen${dayFullName}" i]`;
      const isOpenMatch = searchRoot.querySelector(isOpenSelector);
      if (isOpenMatch) {
        return {
          element: isOpenMatch,
          formGroup: isOpenMatch.closest('.form-group, [class*="form-group"], dl, dt, dd, .hoursOfOperation') ||
            isOpenMatch.closest('.hoursOfOperation') ||
            null
        };
      }
    }

    // Try to find toggle near fields for the same day
    for (const detectedField of detectedFields || []) {
      if (detectedField.day === day) {
        const formGroup = detectedField.element.closest('.form-group, [class*="form-group"], dl, dt, dd, .hoursOfOperation');
        if (formGroup) {
          const checkboxes = formGroup.querySelectorAll('input[type="checkbox"]');
          for (const cb of checkboxes) {
            const cbId = (cb.id || '').toLowerCase();
            const cbName = (cb.name || '').toLowerCase();
            const cbText = `${cbId} ${cbName} ${cb.className || ''}`.toLowerCase();
            const isToggle = (cbText.includes('open') || cbText.includes('closed') || cbText.includes('enable') ||
              cbText.includes('active') || cbText.includes('status')) &&
              !cbText.includes('time') && !cbText.includes('hour');
            if (isToggle) {
              return { element: cb, formGroup };
            }
          }
        }
      }
    }

    // Fallback: scan all checkboxes by day pattern
    const patterns = dayPatterns[day] || [];
    const allCheckboxes = searchRoot.querySelectorAll('input[type="checkbox"]');
    for (const cb of allCheckboxes) {
      const cbText = `${cb.id || ''} ${cb.name || ''} ${cb.className || ''}`.toLowerCase();
      const hasDayPattern = patterns.some(pattern => cbText.includes(pattern));
      const isToggle = (cbText.includes('open') || cbText.includes('closed') || cbText.includes('enable') ||
        cbText.includes('active') || cbText.includes('status')) &&
        !cbText.includes('time') && !cbText.includes('hour');
      if (hasDayPattern && isToggle) {
        return {
          element: cb,
          formGroup: cb.closest('.form-group, [class*="form-group"], dl, dt, dd, .hoursOfOperation') || null
        };
      }
    }

    console.log(`‚ÑπÔ∏è [${stepIndex}] No toggle found for ${day}`);
    return null;
  }

  /**
   * Update open/close status label (e.g., "openCloseText" label)
   * Supports multiple site formats and label patterns
   * @param {HTMLElement} formGroup - Form group container
   * @param {boolean} isOpen - Whether day is open
   * @param {number} stepIndex - Step index for logging
   */
  function updateOpenCloseLabel(formGroup, isOpen, stepIndex) {
    if (!formGroup) return;
    
    // Multiple patterns for open/close status labels
    const labelSelectors = [
      '.openCloseText',
      '[class*="openCloseText"]',
      '[class*="open-close"]',
      '[class*="status"]',
      'label[class*="status"]',
      '.status-label',
      '[data-status]'
    ];
    
    // Find status label
    let statusLabel = null;
    for (const selector of labelSelectors) {
      statusLabel = formGroup.querySelector(selector);
      if (statusLabel) break;
    }
    
    if (statusLabel) {
      const targetText = isOpen ? 'open' : 'closed';
      const targetClass = isOpen ? 'open' : 'closed';
      
      // Update text content
      statusLabel.textContent = targetText;
      
      // Update classes - remove opposite class, add target class
      statusLabel.classList.remove('open', 'closed', 'close');
      statusLabel.classList.add(targetClass);
      
      // Update data attributes if present
      if (statusLabel.hasAttribute('data-status')) {
        statusLabel.setAttribute('data-status', targetText);
      }
      
      console.log(`‚úÖ [${stepIndex}] Updated status label to "${targetText}"`);
    }
  }

  /**
   * Handle toggle checkbox - check/uncheck based on hours availability
   * Supports slider-style toggles (checkbox inside .switch container)
   * Robustly handles multiple site formats
   * @param {HTMLElement} checkbox - Checkbox element
   * @param {boolean} shouldBeChecked - Whether checkbox should be checked
   * @param {number} stepIndex - Step index for logging
   * @param {HTMLElement} formGroup - Optional form-group container for finding related fields
   * @returns {Promise<boolean>} Success status
   */
  async function handleToggleCheckbox(checkbox, shouldBeChecked, stepIndex, formGroup = null) {
    if (!checkbox || checkbox.type !== 'checkbox') {
      return false;
    }
    
    try {
      const isCurrentlyChecked = checkbox.checked;
      
      // Find form-group if not provided
      if (!formGroup) {
        formGroup = checkbox.closest('.form-group, [class*="form-group"], [class*="hours"]');
      }
      
      // Helper function to update time fields and labels
      const updateTimeFieldsAndLabels = () => {
        if (formGroup) {
          // Find and update time fields
          const timeFields = formGroup.querySelectorAll('input[type="time"]');
          
          if (!shouldBeChecked) {
            // Day is closed - set time fields to readonly and 00:00
            timeFields.forEach(timeField => {
              // Only update if not already in closed state
              if (!timeField.readOnly || timeField.value !== '00:00') {
                timeField.readOnly = true;
                timeField.value = '00:00';
                timeField.dispatchEvent(new Event('change', { bubbles: true }));
                timeField.dispatchEvent(new Event('input', { bubbles: true }));
              }
            });
            
            // Update status label to "closed"
            updateOpenCloseLabel(formGroup, false, stepIndex);
          } else {
            // Day is open - remove readonly from time fields
            timeFields.forEach(timeField => {
              if (timeField.readOnly) {
                timeField.readOnly = false;
                // Trigger change event to update UI state and enable fields
                timeField.dispatchEvent(new Event('change', { bubbles: true }));
                timeField.dispatchEvent(new Event('input', { bubbles: true }));
                timeField.dispatchEvent(new Event('focus', { bubbles: true }));
              }
            });
            
            // Update status label to "open"
            updateOpenCloseLabel(formGroup, true, stepIndex);
          }
        }
      };
      
      // For slider-style toggles, always use the switch container click method
      // This ensures proper slider animation and UI updates
      const switchContainer = checkbox.closest('.switch, label.switch, [class*="switch"]');
      
      if (shouldBeChecked !== isCurrentlyChecked) {
        // State needs to change - toggle it
        if (switchContainer) {
          // Slider-style toggle - click the switch container
          // This properly triggers the slider animation and checkbox state change
          console.log(`üîÑ [${stepIndex}] Toggling slider switch: ${shouldBeChecked ? 'ON' : 'OFF'}`);
          switchContainer.click();
          
          // Wait for slider animation and checkbox state update
          await new Promise(resolve => setTimeout(resolve, 200));
          
          // Double-check checkbox state matches desired state
          if (checkbox.checked !== shouldBeChecked) {
            // If state didn't change from click, set it directly
            checkbox.checked = shouldBeChecked;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            checkbox.dispatchEvent(new Event('input', { bubbles: true }));
          }
          
          // Update time fields and status label after toggle completes
          updateTimeFieldsAndLabels();
        } else {
          // Regular checkbox - set directly
          checkbox.checked = shouldBeChecked;
          checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          checkbox.dispatchEvent(new Event('click', { bubbles: true }));
          checkbox.dispatchEvent(new Event('input', { bubbles: true }));
          
          // Update time fields and status label immediately
          updateTimeFieldsAndLabels();
        }
        
        return true;
      } else {
        // Already in correct state, but ensure time fields and labels are in correct state
        // This is important for default closed states that need label updates
        updateTimeFieldsAndLabels();
        
        // For slider-style, if state is correct but we want to ensure UI is synced,
        // we can optionally trigger a click to ensure site handlers run
        // However, this might cause unwanted toggles, so we'll just update fields/labels
      }
      
      return true;
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Error handling toggle checkbox:`, error);
      return false;
    }
  }

  function isClosedHourValue(value) {
    if (value == null) return false;
    const normalized = String(value).trim().toLowerCase();
    if (!normalized) return false;
    return normalized === 'closed' ||
      normalized === 'close' ||
      normalized === 'closed all day' ||
      normalized === 'closed all-day' ||
      normalized === 'all day closed' ||
      normalized === 'all-day closed';
  }

  function isUsableHourValue(value) {
    if (value == null) return false;
    const trimmed = String(value).trim();
    if (!trimmed) return false;
    if (trimmed === '00:00') return false;
    return !isClosedHourValue(trimmed);
  }

  const closedDaysCache = new Map();

  function getClosedDaysFromHoursBox(rawBox) {
    if (!rawBox || typeof rawBox !== 'string') {
      return new Set();
    }

    if (closedDaysCache.has(rawBox)) {
      return closedDaysCache.get(rawBox);
    }

    const text = rawBox.replace(/\s+/g, ' ').trim();
    const dayRegex = /\b(mon|monday|tue|tues|tuesday|wed|wednesday|thu|thur|thurs|thursday|fri|friday|sat|saturday|sun|sunday|holiday|holidays)\b/gi;
    const matches = Array.from(text.matchAll(dayRegex));
    const closedDays = new Set();

    const labelToDay = (label) => {
      const lower = label.toLowerCase();
      if (lower.startsWith('mon')) return 'mon';
      if (lower.startsWith('tue')) return 'tue';
      if (lower.startsWith('wed')) return 'wed';
      if (lower.startsWith('thu')) return 'thu';
      if (lower.startsWith('fri')) return 'fri';
      if (lower.startsWith('sat')) return 'sat';
      if (lower.startsWith('sun')) return 'sun';
      if (lower.startsWith('hol')) return 'holiday';
      return null;
    };

    for (let i = 0; i < matches.length; i++) {
      const current = matches[i];
      const next = matches[i + 1];
      const startIndex = current.index ?? 0;
      const endIndex = next ? (next.index ?? text.length) : text.length;
      const segment = text.slice(startIndex, endIndex).toLowerCase();
      const dayKey = labelToDay(current[0]);
      if (dayKey && segment.includes('closed')) {
        closedDays.add(dayKey);
      }
    }

    closedDaysCache.set(rawBox, closedDays);
    return closedDays;
  }

  function normalizeTimeToFormat(timeValue, formatType) {
    if (!timeValue) return '';
    const trimmed = String(timeValue).trim();
    if (!trimmed) return '';

    const hasMeridiem = /(am|pm)$/i.test(trimmed) || /\s(am|pm)\b/i.test(trimmed);
    if (formatType === '24Hrs') {
      return hasMeridiem ? convertTo24Hour(trimmed) : trimmed;
    }
    if (formatType === '12Hrs') {
      if (hasMeridiem) {
        // Normalize spacing and casing for 12-hour input
        const normalized = trimmed.replace(/\s*(am|pm)\b/i, ' $1').toUpperCase();
        return normalized;
      }
      return convertTo12Hour(trimmed);
    }
    return trimmed;
  }

  function parseBusinessHoursBoxToData(rawBox, hoursFormat) {
    if (!rawBox || typeof rawBox !== 'string') {
      return {};
    }

    const text = rawBox.replace(/\s+/g, ' ').trim();
    const dayRegex = /\b(mon|monday|tue|tues|tuesday|wed|wednesday|thu|thur|thurs|thursday|fri|friday|sat|saturday|sun|sunday|holiday|holidays)\b/gi;
    const matches = Array.from(text.matchAll(dayRegex));
    if (matches.length === 0) {
      return {};
    }

    const labelToDay = (label) => {
      const lower = label.toLowerCase();
      if (lower.startsWith('mon')) return 'mon';
      if (lower.startsWith('tue')) return 'tue';
      if (lower.startsWith('wed')) return 'wed';
      if (lower.startsWith('thu')) return 'thu';
      if (lower.startsWith('fri')) return 'fri';
      if (lower.startsWith('sat')) return 'sat';
      if (lower.startsWith('sun')) return 'sun';
      if (lower.startsWith('hol')) return 'holiday';
      return null;
    };

    const result = {};

    for (let i = 0; i < matches.length; i++) {
      const current = matches[i];
      const next = matches[i + 1];
      const startIndex = current.index ?? 0;
      const endIndex = next ? (next.index ?? text.length) : text.length;
      const segment = text.slice(startIndex, endIndex).trim();
      const dayKey = labelToDay(current[0]);
      if (!dayKey) continue;

      const lowerSegment = segment.toLowerCase();
      if (lowerSegment.includes('closed')) {
        result[`${dayKey}Full`] = 'Closed';
        result[`${dayKey}Am`] = '';
        result[`${dayKey}Pm`] = '';
        continue;
      }

      const range12Regex = /(\d{1,2}:\d{2})\s*(AM|PM|am|pm)\s*[-‚Äì]\s*(\d{1,2}:\d{2})\s*(AM|PM|am|pm)/g;
      const range24Regex = /(\d{1,2}:\d{2})\s*[-‚Äì]\s*(\d{1,2}:\d{2})/g;

      const ranges = [];
      let match12 = null;
      while ((match12 = range12Regex.exec(segment)) !== null) {
        ranges.push({
          start: `${match12[1]} ${match12[2]}`.toUpperCase(),
          end: `${match12[3]} ${match12[4]}`.toUpperCase()
        });
      }

      if (ranges.length === 0) {
        let match24 = null;
        while ((match24 = range24Regex.exec(segment)) !== null) {
          ranges.push({ start: match24[1], end: match24[2] });
        }
      }

      if (ranges.length > 0) {
        const first = ranges[0];
        result[`${dayKey}Am`] = hoursFormat ? normalizeTimeToFormat(first.start, hoursFormat) : first.start;
        result[`${dayKey}Pm`] = hoursFormat ? normalizeTimeToFormat(first.end, hoursFormat) : first.end;

        if (ranges.length > 1) {
          const second = ranges[1];
          result[`${dayKey}Am2`] = hoursFormat ? normalizeTimeToFormat(second.start, hoursFormat) : second.start;
          result[`${dayKey}Pm2`] = hoursFormat ? normalizeTimeToFormat(second.end, hoursFormat) : second.end;
        }
      }
    }

    return result;
  }

  function applyClosedValueToField(field, stepIndex, day, period) {
    if (!field) return false;

    // If a container was passed, try to locate the actual input/select
    if (['TD', 'TH', 'TR', 'TABLE', 'TBODY', 'THEAD', 'DIV', 'SPAN'].includes(field.tagName)) {
      const actualInput = field.querySelector('select, input[type="text"], input[type="time"], input[type="number"]');
      if (actualInput) {
        field = actualInput;
      }
    }

    try {
      if (field.tagName === 'SELECT') {
        const options = Array.from(field.options);
        const closedOption = options.find(opt => {
          const value = String(opt.value || '').trim().toLowerCase();
          const text = String(opt.textContent || '').trim().toLowerCase();
          return value === 'closed' || text === 'closed';
        });
        if (closedOption) {
          field.value = closedOption.value;
          field.dispatchEvent(new Event('change', { bubbles: true }));
          field.dispatchEvent(new Event('input', { bubbles: true }));
          console.log(`‚úÖ [${stepIndex}] Marked ${day} ${period} as closed via SELECT option`);
          return true;
        }
      } else if (field.tagName === 'INPUT') {
        if (field.type === 'time') {
          field.value = '00:00';
        } else {
          field.value = 'Closed';
        }
        field.dispatchEvent(new Event('change', { bubbles: true }));
        field.dispatchEvent(new Event('input', { bubbles: true }));
        console.log(`‚úÖ [${stepIndex}] Marked ${day} ${period} as closed via INPUT value`);
        return true;
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Failed to mark ${day} ${period} as closed:`, error);
    }

    return false;
  }

  function isDayExplicitlyClosed(hoursData, day) {
    if (!hoursData || !day) return false;

    const dayKeyMap = {
      'mon': 'mon', 'tue': 'tue', 'wed': 'wed', 'thu': 'thu',
      'fri': 'fri', 'sat': 'sat', 'sun': 'sun', 'holiday': 'holiday'
    };
    const dayKey = dayKeyMap[day];
    if (!dayKey) return false;

    const amKey = dayKey === 'holiday' ? 'holidayAm' : `${dayKey}Am`;
    const pmKey = dayKey === 'holiday' ? 'holidayPm' : `${dayKey}Pm`;
    const fullKey = dayKey === 'holiday' ? 'holidayFull' : `${dayKey}Full`;

    if (isClosedHourValue(hoursData[amKey]) || isClosedHourValue(hoursData[pmKey]) || isClosedHourValue(hoursData[fullKey])) {
      return true;
    }

      const rawBox = hoursData.businessHoursBox || hoursData.hours || hoursData.businessHours;
    if (rawBox && typeof rawBox === 'string') {
      const closedDays = getClosedDaysFromHoursBox(rawBox);
      if (closedDays.has(day)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Get hours value for a specific day/period with intelligent fallback
   * Supports range formats like "Mon-Sun", "Mon-Fri", etc.
   * @param {Object} hoursData - Processed hours data
   * @param {string} day - Day key (mon, tue, etc.)
   * @param {string} period - Period (am or pm)
   * @param {number} stepIndex - Step index for logging
   * @returns {string|null} Hour value or null
   */
  function getHoursValueWithFallback(hoursData, day, period, stepIndex) {
    const dayKeyMap = {
      'mon': 'mon', 'tue': 'tue', 'wed': 'wed', 'thu': 'thu',
      'fri': 'fri', 'sat': 'sat', 'sun': 'sun', 'holiday': 'holiday'
    };
    
    const dayKey = dayKeyMap[day];
    if (!dayKey) return null;
    
    // Try direct lookup first
    let valueKey = null;
    let hourValue = null;
    
    if (day === 'holiday') {
      valueKey = period === 'am' ? 'holidayAm' : 'holidayPm';
      if (!hoursData[valueKey]) {
        valueKey = period === 'am' ? 'holidayOpen' : 'holidayClose';
      }
      hourValue = hoursData[valueKey];
    } else {
      valueKey = `${dayKey}${period === 'am' ? 'Am' : 'Pm'}`;
      hourValue = hoursData[valueKey];
    }
    
    const is24HourDay = Boolean(hoursData?.__24HourDays && hoursData.__24HourDays[day]);
    if (is24HourDay && hourValue != null && String(hourValue).trim() !== '') {
      return hourValue;
    }

    // If the day is explicitly closed, do not use direct value
    if (isDayExplicitlyClosed(hoursData, day)) {
      console.log(`‚ÑπÔ∏è [${stepIndex}] ${day} marked as Closed - skipping direct value`);
      return null;
    }

    // If found, return it
    if (isUsableHourValue(hourValue)) {
      return hourValue;
    }

    // If this day is explicitly closed, do not fallback from other days
    if (isDayExplicitlyClosed(hoursData, day)) {
      console.log(`‚ÑπÔ∏è [${stepIndex}] ${day} marked as Closed - skipping fallback`);
      return null;
    }
    
    // FALLBACK LOGIC: If this day doesn't have hours, try to find a pattern
    // Strategy 1: Check if all weekdays (Mon-Fri) have the same hours
    const weekdays = ['mon', 'tue', 'wed', 'thu', 'fri'];
    const weekends = ['sat', 'sun'];
    const allDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    
    // Check if we're in a weekday and other weekdays have hours
    if (weekdays.includes(day)) {
      for (const wd of weekdays) {
        if (wd === day) continue;
        const wdKey = `${wd}${period === 'am' ? 'Am' : 'Pm'}`;
        const wdValue = hoursData[wdKey];
        if (isUsableHourValue(wdValue)) {
          console.log(`üîÑ [${stepIndex}] Using fallback: ${day} ${period} <- ${wd} ${period} (${wdValue})`);
          return wdValue;
        }
      }
    }
    
    // Check if we're in a weekend and other weekend days have hours
    if (weekends.includes(day)) {
      for (const we of weekends) {
        if (we === day) continue;
        const weKey = `${we}${period === 'am' ? 'Am' : 'Pm'}`;
        const weValue = hoursData[weKey];
        if (isUsableHourValue(weValue)) {
          console.log(`üîÑ [${stepIndex}] Using fallback: ${day} ${period} <- ${we} ${period} (${weValue})`);
          return weValue;
        }
      }
    }
    
    // Strategy 2: Check if all days have the same hours (Mon-Sun pattern)
    for (const checkDay of allDays) {
      if (checkDay === day) continue;
      const checkKey = `${checkDay}${period === 'am' ? 'Am' : 'Pm'}`;
      const checkValue = hoursData[checkKey];
      if (isUsableHourValue(checkValue)) {
        console.log(`üîÑ [${stepIndex}] Using fallback: ${day} ${period} <- ${checkDay} ${period} (${checkValue})`);
        return checkValue;
      }
    }
    
    // Strategy 3: Check if there's a "default" pattern (first available day)
    // This handles cases where only Mon has hours but all days should use it
    const dayOrder = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    for (const checkDay of dayOrder) {
      const checkKey = `${checkDay}${period === 'am' ? 'Am' : 'Pm'}`;
      const checkValue = hoursData[checkKey];
      if (isUsableHourValue(checkValue)) {
        console.log(`üîÑ [${stepIndex}] Using fallback (first available): ${day} ${period} <- ${checkDay} ${period} (${checkValue})`);
        return checkValue;
      }
    }
    
    return null;
  }

  /**
   * Auto-detect and fill all hour fields on the page
   * @param {Object} hoursData - Processed hours data (from flatData with monAm, monPm, etc.)
   * @param {number} stepIndex - Step index for logging
   * @param {HTMLElement} contextElement - Optional context element to search within
   * @returns {Promise<Object>} Result with filled count and details
   */
  function isTradingHoursDayLabel(text) {
    if (!text) return false;
    const normalized = String(text).trim().toLowerCase();
    return normalized === 'mon' || normalized === 'tue' || normalized === 'wed' ||
      normalized === 'thu' || normalized === 'fri' || normalized === 'sat' ||
      normalized === 'sun' || normalized === 'monday' || normalized === 'tuesday' ||
      normalized === 'wednesday' || normalized === 'thursday' || normalized === 'friday' ||
      normalized === 'saturday' || normalized === 'sunday';
  }

  function isTradingHoursTimeText(text) {
    if (!text) return false;
    const normalized = String(text).trim();
    if (normalized === '--:--') return true;
    return /\d{1,2}:\d{2}/.test(normalized);
  }

  function findTradingHoursRoot(searchRoot) {
    if (!searchRoot) return null;
    const headerSpans = Array.from(searchRoot.querySelectorAll('span'));
    const header = headerSpans.find(span => {
      const text = (span.textContent || '').trim().toLowerCase();
      return text === 'trading hours';
    });
    if (!header) return null;
    let container = header.closest('div');
    while (container) {
      const buttons = Array.from(container.querySelectorAll('button'));
      const dayButtons = buttons.filter(btn => isTradingHoursDayLabel(btn.textContent));
      const hasTimeButtons = buttons.some(btn => isTradingHoursTimeText(btn.textContent));
      if (dayButtons.length >= 5 && hasTimeButtons) {
        return container;
      }
      container = container.parentElement;
    }
    return null;
  }

  function findTradingHoursRowFromDayButton(dayButton, root) {
    if (!dayButton) return null;
    let node = dayButton.closest('div');
    while (node && node !== root) {
      const rowButtons = Array.from(node.querySelectorAll('button'));
      const hasDay = rowButtons.some(btn => isTradingHoursDayLabel(btn.textContent));
      const hasTime = rowButtons.some(btn => isTradingHoursTimeText(btn.textContent));
      if (hasDay && hasTime) {
        return node;
      }
      node = node.parentElement;
    }
    return dayButton.parentElement;
  }

  function getTradingHoursDayRows(root) {
    if (!root) return [];
    const dayButtons = Array.from(root.querySelectorAll('button'))
      .filter(btn => isTradingHoursDayLabel(btn.textContent));
    const rowsByDay = [];
    dayButtons.forEach(button => {
      const dayText = (button.textContent || '').trim().toLowerCase();
      const dayKey = dayText.slice(0, 3);
      const row = findTradingHoursRowFromDayButton(button, root);
      if (row) {
        rowsByDay.push({ day: dayKey, row });
      }
    });
    return rowsByDay;
  }

  /**
   * Detect which hour structure is present on the page
   * @param {HTMLElement} contextElement - Context element to search within
   * @returns {string} Structure type: 'symfony-collection', 'anw-hour1', 'hoursOfOperation', or 'generic'
   */
  function detectHourStructure(contextElement = null) {
    const searchRoot = contextElement || document;
    
    // Check for Symfony collection structure (data-symfony-collection with day/open/close selects)
    const symfonyCollection = searchRoot.querySelector('[data-symfony-collection][data-symfony-collection-hoursofoperations]');
    if (symfonyCollection) {
      // Verify it has the expected structure: selects with [day], [open], [close] in name
      const hasDaySelect = symfonyCollection.querySelector('select[name*="[day]"]');
      const hasOpenSelect = symfonyCollection.querySelector('select[name*="[open]"]');
      const hasCloseSelect = symfonyCollection.querySelector('select[name*="[close]"]');
      if (hasDaySelect && hasOpenSelect && hasCloseSelect) {
        console.log('üèóÔ∏è [detectHourStructure] Detected Symfony collection structure');
        return 'symfony-collection';
      }
    }
    
    // Check for dl#anw-hour1 structure (no toggles, uses dt/dd with selects)
    const anwHourStructure = searchRoot.querySelector('dl#anw-hour1, #anw-hour1, dl[id*="hour"][id*="anw"]');
    if (anwHourStructure) {
      // Verify it has the expected structure: dt with labels, dd with selects
      const hasDtDdStructure = anwHourStructure.querySelector('dt label') && anwHourStructure.querySelector('dd select');
      if (hasDtDdStructure) {
        console.log('üèóÔ∏è [detectHourStructure] Detected dl#anw-hour1 structure');
        return 'anw-hour1';
      }
    }
    
    // Check for specific hoursPicker structure (#hourswrapper, #hoursPicker, #hours-of-operation with time-closed checkboxes)
    const hoursPickerStructure = searchRoot.querySelector('#hourswrapper, #hoursPicker, #hours-of-operation');
    if (hoursPickerStructure) {
      // Check inside the container for the actual structure
      const innerContainer = hoursPickerStructure.querySelector('#hourswrapper, #hoursPicker') || hoursPickerStructure;
      const hasTimeClosedCheckboxes = innerContainer.querySelector('.time-closed');
      const hasTimePickerInputs = innerContainer.querySelector('.ui-timepicker-input, input[id*="_s1"], input[id*="_e1"]');
      if (hasTimeClosedCheckboxes && hasTimePickerInputs) {
        console.log('üèóÔ∏è [detectHourStructure] Detected hoursPicker structure (#hourswrapper/#hoursPicker with time-closed checkboxes)');
        return 'hoursPicker';
      }
    }
    
    // Check for hoursOfOperation structure (with toggles, form-groups)
    // Also check for #hours-of-operation ID selector
    const hoursOfOperationStructure = searchRoot.querySelector('#hours-of-operation, .hoursOfOperation, [class*="hoursOfOperation"], [class*="hours-of-operation"]');
    if (hoursOfOperationStructure) {
      // Verify it has form-groups, IsOpen checkboxes, or hour fields
      const hasFormGroups = hoursOfOperationStructure.querySelector('.form-group, [class*="form-group"]');
      const hasIsOpenCheckboxes = hoursOfOperationStructure.querySelector('input[type="checkbox"][id*="IsOpen"], input[type="checkbox"][name*="IsOpen"]');
      const hasHourFields = hoursOfOperationStructure.querySelector('select, input[type="time"], input[type="text"][id*="hour"], input[type="text"][id*="time"]');
      if (hasFormGroups || hasIsOpenCheckboxes || hasHourFields) {
        console.log('üèóÔ∏è [detectHourStructure] Detected hoursOfOperation structure');
        return 'hoursOfOperation';
      }
    }
    
    // Check for opening-hours table structure (table with class "opening-hours" and inputs week[1-6,0], op[1-6,0], cl[1-6,0])
    const openingHoursTable = searchRoot.querySelector('table.opening-hours, table[class*="opening-hours"], .opening-hours table');
    if (openingHoursTable) {
      // Verify it has the expected structure: checkboxes with name="week[X]" and time inputs with name="op[X]" and "cl[X]"
      const hasWeekCheckboxes = openingHoursTable.querySelector('input[type="checkbox"][name^="week["]');
      const hasOpInputs = openingHoursTable.querySelector('input[type="time"][name^="op["], input[name^="op["]');
      const hasClInputs = openingHoursTable.querySelector('input[type="time"][name^="cl["], input[name^="cl["]');
      if (hasWeekCheckboxes && hasOpInputs && hasClInputs) {
        console.log('üèóÔ∏è [detectHourStructure] Detected opening-hours table structure');
        return 'opening-hours-table';
      }
    }

    // Check for oHcnt/ohline structure (German-style: .oHcnt > .ohline rows, select.ohtime.von1/bis1, select.status; name="mo[von1]", "mo[bis1]", "mo[status1]", etc.)
    const oHcntStructure = searchRoot.querySelector('.oHcnt, .container.ohline, [class*="oHcnt"], [class*="ohline"]');
    if (oHcntStructure) {
      const hasOhtimeSelects = oHcntStructure.querySelector('select.ohtime, select[class*="ohtime"], select[name*="von1"], select[name*="bis1"]');
      const hasStatusSelect = oHcntStructure.querySelector('select.status, select[class*="status"], select[name*="status1"]');
      const hasDayPrefix = oHcntStructure.querySelector('select[name="mo[von1]"], select[id="von1mo"], select[name="di[von1]"], select[id^="von1"]');
      if ((hasOhtimeSelects || hasDayPrefix) && (hasStatusSelect || hasDayPrefix)) {
        console.log('üèóÔ∏è [detectHourStructure] Detected oHcnt/ohline structure (von1/bis1/status per day)');
        return 'ohcnt-ohline';
      }
    }

    // Check for timetable structure (table.timetable with input#monday_start, input#monday_end, input#monday_closed, etc.)
    const timetableTable = searchRoot.querySelector('table.timetable, table[class*="timetable"]');
    if (timetableTable) {
      const hasMondayStart = searchRoot.querySelector('input#monday_start, input[id="monday_start"]');
      const hasStartEnd = searchRoot.querySelector('input[id$="_start"], input[id$="_end"]');
      if (hasMondayStart || (hasStartEnd && timetableTable.querySelector('input[id$="_start"]'))) {
        console.log('üèóÔ∏è [detectHourStructure] Detected timetable structure (card > table.timetable, {day}_start/_end/_closed)');
        return 'timetable';
      }
    }

    // Check for CompanyWorkingHoursForm structure (form with .form-subsection, .radio-label, .day-of-week, select[name="openingStart"], select[name="closingEnd"])
    const companyWorkingHoursForm = searchRoot.querySelector('form[data-form-name="CompanyWorkingHoursForm"]');
    const formSubsection = searchRoot.querySelector('.form-subsection');
    if ((companyWorkingHoursForm || formSubsection) && searchRoot.querySelector('.radio-label .day-of-week') && 
        searchRoot.querySelector('select[name="openingStart"]') && searchRoot.querySelector('select[name="closingEnd"]')) {
      console.log('üèóÔ∏è [detectHourStructure] Detected CompanyWorkingHoursForm structure (radio-label + openingStart/closingEnd selects)');
      return 'company-working-hours-form';
    }

    // Check for subscriber-openinghours2 / Angular opening hours (table with col-day, open-MONDAY switches, pencil -> modal with from/to selects)
    const subscriberOpeningHours = searchRoot.querySelector('subscriber-openinghours2, [formcontrolname="openinghours"]');
    const openingHoursDiv = searchRoot.querySelector('.openinghours');
    const openingHoursContainer = subscriberOpeningHours || openingHoursDiv;
    if (openingHoursContainer) {
      const table = openingHoursContainer.querySelector('table.hover, table');
      const hasColDay = table?.querySelector('td.col-day');
      const hasOpenSwitch = openingHoursContainer.querySelector('input[id^="open-"], input[id*="open-MONDAY"]');
      const hasTimeInterval = openingHoursContainer.querySelector('openinghour-timeinterval, .openinghour-timeinterval');
      if (table && (hasColDay || table.querySelector('td')) && (hasOpenSwitch || hasTimeInterval)) {
        console.log('üèóÔ∏è [detectHourStructure] Detected subscriber-openinghours2 structure (table + open switches + pencil modal)');
        return 'subscriber-openinghours2';
      }
    }

    const tradingHoursRoot = findTradingHoursRoot(searchRoot);
    if (tradingHoursRoot) {
      console.log('üèóÔ∏è [detectHourStructure] Detected trading hours button structure');
      return 'trading-hours';
    }
    
    // Default to generic structure
    console.log('üèóÔ∏è [detectHourStructure] Using generic structure (no specific structure detected)');
    return 'generic';
  }

  /**
   * Detect category/option list structure for findAndClick (checkbox list, button list, or generic).
   * Used when step has parentSelectors like .cat_checkbox_list so we prefer checkbox vs button/label.
   * @param {HTMLElement} parentEl - Container element (e.g. .cat_checkbox_list)
   * @returns {'checkbox-list'|'button-list'|'generic'}
   */
  function detectCategoryListStructure(parentEl) {
    if (!parentEl) return 'generic';
    const checkboxes = parentEl.querySelectorAll('input[type="checkbox"]');
    const buttons = parentEl.querySelectorAll('button, [role="button"], input[type="submit"], a.btn, .btn');
    const labels = parentEl.querySelectorAll('label');
    const checkboxCount = checkboxes.length;
    const buttonCount = buttons.length;
    const labelCount = labels.length;
    // Known checkbox-list patterns (e.g. category checkboxes with sibling text or inside labels)
    const looksLikeCheckboxList = parentEl.classList.contains('cat_checkbox_list') ||
      /checkbox.*list|category.*list|cat_/i.test(parentEl.className || '') ||
      (checkboxCount >= 3 && (checkboxCount >= buttonCount || buttonCount === 0));
    if (looksLikeCheckboxList) {
      console.log('üèóÔ∏è [detectCategoryListStructure] Detected checkbox-list (checkboxes: ' + checkboxCount + ')');
      return 'checkbox-list';
    }
    // Button-first: many buttons/clickables, few checkboxes (e.g. category as buttons or label+span)
    if (buttonCount >= 3 && buttonCount >= checkboxCount) {
      console.log('üèóÔ∏è [detectCategoryListStructure] Detected button-list (buttons: ' + buttonCount + ')');
      return 'button-list';
    }
    if (labelCount >= 3 && checkboxCount <= labelCount) {
      console.log('üèóÔ∏è [detectCategoryListStructure] Detected label/span style list (labels: ' + labelCount + ')');
      return 'button-list';
    }
    console.log('üèóÔ∏è [detectCategoryListStructure] Using generic');
    return 'generic';
  }

  function getHoursContextElement(element = null) {
    let contextElement = document.querySelector('#hours-of-operation');
    if (!contextElement) {
      contextElement = document.querySelector('.oHcnt, .container.ohline');
    }
    if (!contextElement) {
      const companyForm = document.querySelector('form[data-form-name="CompanyWorkingHoursForm"]');
      if (companyForm) contextElement = companyForm;
    }
    if (!contextElement) {
      const formWithSubsection = document.querySelector('.form-subsection')?.closest('form');
      if (formWithSubsection && formWithSubsection.querySelector('select[name="openingStart"]')) contextElement = formWithSubsection;
    }
    if (!contextElement) {
      const subscriberOh = document.querySelector('subscriber-openinghours2, [formcontrolname="openinghours"], .openinghours');
      if (subscriberOh) contextElement = subscriberOh;
    }
    if (!contextElement) {
      const timetableEl = document.querySelector('table.timetable, table[class*="timetable"]');
      if (timetableEl) contextElement = timetableEl.closest('.card, .card-block') || timetableEl;
    }
    if (!contextElement) {
      contextElement = element
        ? (element.closest('form') ||
           element.closest('.oHcnt, .ohline, [class*="hour"], [class*="time"], [id*="hour"], [id*="time"]') ||
           document.body)
        : document.body;
    }
    return contextElement || document.body;
  }

  function getHoursTextFor24HourDetection(primaryData, fallbackData) {
    const candidates = [
      primaryData?.businessHoursBox,
      primaryData?.businessHours,
      primaryData?.hours,
      fallbackData?.businessHoursBox,
      fallbackData?.businessHours,
      fallbackData?.hours
    ];
    const firstText = candidates.find(value => typeof value === 'string' && value.trim() !== '');
    return firstText || '';
  }

  function detect24HourOperation(hoursText, structureType, businessHoursStatus) {
    const result = {
      is24Hours: false,
      structureType,
      matchedPattern: null
    };

    if (!hoursText || typeof hoursText !== 'string') {
      return result;
    }

    const status = String(businessHoursStatus || '').trim().toLowerCase();
    if (status === 'split' || status === 'overlaps' || status === 'hide' || status === 'skip') {
      return result;
    }

    const isSupportedStructure = structureType === 'hoursOfOperation' ||
      structureType === 'hoursPicker' ||
      structureType === 'anw-hour1';
    if (!isSupportedStructure) {
      return result;
    }

    const normalized = hoursText.replace(/\s+/g, ' ').trim().toLowerCase();
    if (!normalized) {
      return result;
    }

    const hasMonToSunRange = /\bmon(?:day)?\s*[-‚Äì]\s*sun(?:day)?\b/.test(normalized);
    const hasMidnightRange = /\b00:00\s*-\s*00:00\b/.test(normalized);
    const has24Label = /\b24\s*hours?\b/.test(normalized);
    const has12To11_59 = /\b12:00\s*am\s*-\s*11:59\s*pm\b/.test(normalized);
    const has12To12 = /\b12:00\s*am\s*-\s*12:00\s*am\b/.test(normalized);

    if (structureType === 'anw-hour1') {
      if (has12To12) {
        result.is24Hours = true;
        result.matchedPattern = '12:00 AM - 12:00 AM';
      } else if (has24Label) {
        result.is24Hours = true;
        result.matchedPattern = '24 Hours label';
      } else if (hasMidnightRange && hasMonToSunRange) {
        result.is24Hours = true;
        result.matchedPattern = '00:00 - 00:00 (Mon-Sun)';
      }
      return result;
    }

    if (has12To11_59) {
      result.is24Hours = true;
      result.matchedPattern = '12:00 AM - 11:59 PM';
    } else if (has24Label) {
      result.is24Hours = true;
      result.matchedPattern = '24 Hours label';
    } else if (hasMidnightRange && hasMonToSunRange) {
      result.is24Hours = true;
      result.matchedPattern = '00:00 - 00:00 (Mon-Sun)';
    }

    return result;
  }

  function detect24HoursLabelSupport(contextElement = null) {
    const searchRoot = contextElement || document;
    const hasTimeInputs = searchRoot.querySelector('input[type="time"], input.ui-timepicker-input');
    if (hasTimeInputs) {
      return false;
    }

    const options = Array.from(searchRoot.querySelectorAll('select option'));
    if (options.length === 0) {
      return false;
    }

    return options.some(option => {
      const optionValue = String(option.value || '').toLowerCase();
      const optionText = String(option.textContent || '').toLowerCase();
      return /24\s*hours?/.test(optionValue) || /24\s*hours?/.test(optionText) || /24\s*hrs?/.test(optionValue) || /24\s*hrs?/.test(optionText);
    });
  }

  function apply24HourNormalization(hoursData, flatData, detection, structureType, contextElement, stepIndex) {
    if (!detection || !detection.is24Hours) {
      return null;
    }

    const supportsLabel = detect24HoursLabelSupport(contextElement);
    let openValue = '12:00 AM';
    let closeValue = structureType === 'anw-hour1' ? '12:00 AM' : '11:59 PM';
    let mode = 'range';

    if (supportsLabel) {
      openValue = '24 Hours';
      closeValue = '24 Hours';
      mode = 'label';
    }

    const allDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    allDays.forEach(day => {
      const amKey = `${day}Am`;
      const pmKey = `${day}Pm`;
      hoursData[amKey] = openValue;
      hoursData[pmKey] = closeValue;
      if (flatData) {
        flatData[amKey] = openValue;
        flatData[pmKey] = closeValue;
      }
    });

    const info = {
      is24Hours: true,
      mode,
      openValue,
      closeValue,
      structureType,
      supportsLabel
    };

    hoursData.__24Hours = info;
    hoursData.__24HourDays = { ...(hoursData.__24HourDays || {}), mon: true, tue: true, wed: true, thu: true, fri: true, sat: true, sun: true };
    if (flatData) {
      flatData.__24Hours = info;
      flatData.__24HourDays = { ...(flatData.__24HourDays || {}), mon: true, tue: true, wed: true, thu: true, fri: true, sat: true, sun: true };
    }

    console.log(`‚úÖ [${stepIndex}] 24-hour operation detected (${detection.matchedPattern || 'pattern'}) - using ${mode === 'label' ? '"24 Hours" label' : `${openValue} - ${closeValue}`}`);
    return info;
  }

  function appendBusinessHoursToDescription(flatData, hoursText, stepIndex) {
    if (!flatData || typeof flatData !== 'object') {
      return false;
    }
    if (!hoursText || typeof hoursText !== 'string' || hoursText.trim() === '') {
      return false;
    }

    const descriptionKey = 'longDescriptionBox';
    const currentDescription = String(flatData[descriptionKey] || '');
    if (currentDescription.toLowerCase().includes('business hours:')) {
      return false;
    }

    const trimmedHours = hoursText.trim();
    const separator = currentDescription.trim() ? '\n\n' : '';
    flatData[descriptionKey] = `${currentDescription}${separator}Business Hours:\n${trimmedHours}`.trim();
    console.log(`‚úÖ [${stepIndex}] Appended Business Hours to longDescriptionBox`);
    return true;
  }

  function normalizeMidnightPairsToFullDay(hoursData, flatData, structureType, businessHoursStatus, hoursFormat, stepIndex) {
    if (!hoursData || typeof hoursData !== 'object') {
      return 0;
    }

    const status = String(businessHoursStatus || '').trim().toLowerCase();
    if (status === 'split' || status === 'overlaps' || status === 'hide' || status === 'skip') {
      return 0;
    }

    const isSupportedStructure = structureType === 'hoursOfOperation' || structureType === 'hoursPicker';
    if (!isSupportedStructure) {
      return 0;
    }

    const openValue = hoursFormat === '24Hrs' ? '00:00' : '12:00 AM';
    const closeValue = hoursFormat === '24Hrs' ? '23:59' : '11:59 PM';

    const isMidnightValue = (value) => {
      if (value == null) return false;
      const normalized = String(value).trim();
      if (!normalized) return false;
      const converted = convertTo24Hour(normalized);
      return converted === '00:00';
    };

    const allDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    let adjustedCount = 0;
    const normalizedDays = {};

    allDays.forEach(day => {
      if (isDayExplicitlyClosed(hoursData, day)) {
        return;
      }
      const amKey = `${day}Am`;
      const pmKey = `${day}Pm`;
      const amValue = hoursData[amKey];
      const pmValue = hoursData[pmKey];
      if (isMidnightValue(amValue) && isMidnightValue(pmValue)) {
        hoursData[amKey] = openValue;
        hoursData[pmKey] = closeValue;
        if (flatData) {
          flatData[amKey] = openValue;
          flatData[pmKey] = closeValue;
        }
        adjustedCount++;
        normalizedDays[day] = true;
        console.log(`‚úÖ [${stepIndex}] Normalized ${day} midnight pair to full-day range (${openValue} - ${closeValue})`);
      }
    });

    if (adjustedCount > 0) {
      hoursData.__24HourDays = { ...(hoursData.__24HourDays || {}), ...normalizedDays };
      if (flatData) {
        flatData.__24HourDays = { ...(flatData.__24HourDays || {}), ...normalizedDays };
      }
    }

    return adjustedCount;
  }

  async function autoDetectAndFillHours(hoursData, stepIndex, contextElement = null) {
    console.log(`üîç [${stepIndex}] Starting auto-detection of hour fields...`);
    console.log(`üìä [${stepIndex}] Hours data keys:`, Object.keys(hoursData).filter(k => k.includes('Am') || k.includes('Pm') || k.includes('Open') || k.includes('Close')));
    
    // Detect which structure is present
    const structureType = detectHourStructure(contextElement);
    console.log(`üèóÔ∏è [${stepIndex}] Detected structure type: ${structureType}`);
    
    // Route to structure-specific handler
    switch (structureType) {
      case 'symfony-collection':
        return await handleSymfonyCollectionStructure(hoursData, stepIndex, contextElement);
      case 'anw-hour1':
        return await handleAnwHourStructure(hoursData, stepIndex, contextElement);
      case 'hoursPicker':
        return await handleHoursPickerStructure(hoursData, stepIndex, contextElement);
      case 'hoursOfOperation':
        return await handleHoursOfOperationStructure(hoursData, stepIndex, contextElement);
      case 'opening-hours-table':
        return await handleOpeningHoursTableStructure(hoursData, stepIndex, contextElement);
      case 'company-working-hours-form':
        return await handleCompanyWorkingHoursFormStructure(hoursData, stepIndex, contextElement);
      case 'subscriber-openinghours2':
        return await handleSubscriberOpeningHours2Structure(hoursData, stepIndex, contextElement);
      case 'trading-hours':
        return await handleTradingHoursStructure(hoursData, stepIndex, contextElement);
      default:
        return await handleGenericHourStructure(hoursData, stepIndex, contextElement);
    }
  }
  
  /**
   * Handle Symfony collection structure - supports split hours and multiple entries per day
   * Structure: Collection with day/open/close selects, supports adding multiple entries
   * Handles: Mon: 7AM-10AM, 12PM-5PM (split hours) and Mon: 8PM-10AM (overlaps)
   */
  async function handleSymfonyCollectionStructure(hoursData, stepIndex, contextElement = null) {
    console.log(`üèóÔ∏è [${stepIndex}] Processing Symfony collection structure (supports split hours)`);
    
    const searchRoot = contextElement || document;
    const collectionContainer = searchRoot.querySelector('[data-symfony-collection][data-symfony-collection-hoursofoperations]');
    
    if (!collectionContainer) {
      return { success: false, filledCount: 0, error: 'Symfony collection structure not found' };
    }
    
    // Day mapping: our format -> Symfony format
    const dayMap = {
      'mon': 'monday',
      'tue': 'tuesday',
      'wed': 'wednesday',
      'thu': 'thursday',
      'fri': 'friday',
      'sat': 'saturday',
      'sun': 'sunday'
    };
    
    // Get all existing entries
    const existingEntries = Array.from(collectionContainer.querySelectorAll('[data-symfony-collection-item], .clearfix.mxn1'));
    
    // Find the add button
    const addButton = collectionContainer.querySelector('[data-symfony-collection-add], [data-hours-add]');
    
    let filledCount = 0;
    const filledDetails = [];
    
    // Process each day
    const allDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    
    for (const day of allDays) {
      const amValue = getHoursValueWithFallback(hoursData, day, 'am', stepIndex);
      const pmValue = getHoursValueWithFallback(hoursData, day, 'pm', stepIndex);
      
      // Skip if no hours for this day
      if ((!amValue || amValue.trim() === '' || amValue === '00:00') && 
          (!pmValue || pmValue.trim() === '' || pmValue === '00:00')) {
        continue;
      }
      
      const symfonyDay = dayMap[day];
      if (!symfonyDay) continue;
      
      // Convert times to 24-hour format for Symfony (uses HH:MM format)
      const openTime = amValue ? convertTo24Hour(amValue.trim()) : null;
      const closeTime = pmValue ? convertTo24Hour(pmValue.trim()) : null;
      
      // Check if we need to handle split hours or overlaps
      // For now, we'll create one entry per day with the main hours
      // If there are split hours, we'll need to detect them from the data structure
      
      // Find an empty entry for this day, or create a new one
      // Note: This structure supports split hours (multiple entries per day),
      // but we'll fill one entry per day with the main hours (monAm to monPm)
      // Users can manually add more entries for split hours if needed
      let entry = await findOrCreateSymfonyEntry(collectionContainer, symfonyDay, addButton, stepIndex);
      
      if (entry) {
        // Fill the entry
        const daySelect = entry.querySelector('select[name*="[day]"]');
        const openSelect = entry.querySelector('select[name*="[open]"]');
        const closeSelect = entry.querySelector('select[name*="[close]"]');
        
        if (daySelect && openSelect && closeSelect) {
          // Check if entry already has times set (might be a split hours entry)
          const hasExistingTimes = (openSelect.value && openSelect.value !== '00:00') || 
                                   (closeSelect.value && closeSelect.value !== '00:00');
          
          // Only fill if entry is empty or if it's the first entry for this day
          if (!hasExistingTimes || daySelect.value === symfonyDay) {
            // Set day
            if (daySelect.value !== symfonyDay) {
              daySelect.value = symfonyDay;
              daySelect.dispatchEvent(new Event('change', { bubbles: true }));
              await new Promise(resolve => setTimeout(resolve, 100)); // Wait for day change to process
            }
            
            // Set open time (AM value)
            if (openTime) {
              const openSuccess = fillSymfonyTimeSelect(openSelect, openTime, stepIndex, 'open');
              if (openSuccess) filledCount++;
            }
            
            // Set close time (PM value)
            if (closeTime) {
              const closeSuccess = fillSymfonyTimeSelect(closeSelect, closeTime, stepIndex, 'close');
              if (closeSuccess) filledCount++;
            }
            
            if (openTime || closeTime) {
              filledDetails.push({
                day,
                period: 'full',
                openTime: openTime || 'N/A',
                closeTime: closeTime || 'N/A',
                element: 'Symfony collection entry'
              });
              console.log(`‚úÖ [${stepIndex}] Filled ${day} (${symfonyDay}): ${openTime || 'N/A'} - ${closeTime || 'N/A'}`);
            }
          } else {
            console.log(`‚ÑπÔ∏è [${stepIndex}] Entry for ${symfonyDay} already has times set, skipping (may be split hours entry)`);
          }
        }
      }
    }
    
    console.log(`‚úÖ [${stepIndex}] Symfony collection structure: ${filledCount} time field(s) filled`);
    return {
      success: filledCount > 0,
      filledCount,
      toggleCount: 0,
      detectedCount: filledCount,
      toggleDetectedCount: 0,
      filledDetails
    };
  }
  
  /**
   * Find an existing Symfony collection entry for a day, or create a new one
   * Prioritizes empty entries to avoid overwriting split hours entries
   * @returns {Promise<HTMLElement|null>} The entry element or null
   */
  async function findOrCreateSymfonyEntry(container, symfonyDay, addButton, stepIndex) {
    // Get all entries (try multiple selectors for robustness)
    const allEntries = Array.from(container.querySelectorAll('.clearfix.mxn1, [data-symfony-collection-item], div[class*="clearfix"]'));
    
    // Strategy 1: Find an empty entry (no day selected or day selected but times are 00:00)
    for (const entry of allEntries) {
      const daySelect = entry.querySelector('select[name*="[day]"]');
      const openSelect = entry.querySelector('select[name*="[open]"]');
      const closeSelect = entry.querySelector('select[name*="[close]"]');
      
      if (daySelect && openSelect && closeSelect) {
        const isDaySelected = daySelect.value && daySelect.value !== '';
        const isTimeEmpty = (!openSelect.value || openSelect.value === '00:00') && 
                           (!closeSelect.value || closeSelect.value === '00:00');
        
        // Prefer empty entries or entries matching our day that are empty
        if ((!isDaySelected || daySelect.value === symfonyDay) && isTimeEmpty) {
          console.log(`üîç [${stepIndex}] Found empty entry for ${symfonyDay}, reusing it`);
          return entry;
        }
      }
    }
    
    // Strategy 2: Find an entry with this day that has times set (might be first entry, we'll check if we should overwrite)
    // We'll skip this and create a new one to avoid overwriting split hours
    // But if no add button, use existing entry
    if (!addButton) {
      for (const entry of allEntries) {
        const daySelect = entry.querySelector('select[name*="[day]"]');
        if (daySelect && daySelect.value === symfonyDay) {
          console.log(`üîç [${stepIndex}] Found existing entry for ${symfonyDay} (no add button, reusing)`);
          return entry;
        }
      }
    }
    
    // Strategy 3: Create a new entry
    if (addButton) {
      console.log(`‚ûï [${stepIndex}] Creating new entry for ${symfonyDay}`);
      addButton.click();
      
      // Wait for the new entry to be added
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Find the newly added entry (should be the last one or one with prototype name)
      const allEntriesAfter = Array.from(container.querySelectorAll('.clearfix.mxn1, [data-symfony-collection-item], div[class*="clearfix"]'));
      
      // Find the entry that was just added (usually the last one, or one with __name__ in the name attribute)
      let newEntry = null;
      for (let i = allEntriesAfter.length - 1; i >= 0; i--) {
        const entry = allEntriesAfter[i];
        const daySelect = entry.querySelector('select[name*="[day]"]');
        const nameAttr = daySelect?.getAttribute('name') || '';
        
        // New entries often have __name__ or similar placeholder in their name
        if (nameAttr.includes('__') || !daySelect?.value || daySelect.value === '') {
          newEntry = entry;
          break;
        }
      }
      
      // Fallback: use the last entry if we couldn't identify the new one
      if (!newEntry && allEntriesAfter.length > 0) {
        newEntry = allEntriesAfter[allEntriesAfter.length - 1];
      }
      
      if (newEntry) {
        const daySelect = newEntry.querySelector('select[name*="[day]"]');
        if (daySelect) {
          // Set the day immediately
          daySelect.value = symfonyDay;
          daySelect.dispatchEvent(new Event('change', { bubbles: true }));
          await new Promise(resolve => setTimeout(resolve, 100)); // Wait for day change to process
        }
        return newEntry;
      }
    }
    
    return null;
  }
  
  /**
   * Fill a Symfony time select (open or close) with 24-hour format time
   */
  function fillSymfonyTimeSelect(selectElement, time24Hour, stepIndex, type) {
    if (!selectElement || selectElement.tagName !== 'SELECT') {
      return false;
    }
    
    try {
      // Symfony uses HH:MM format (e.g., "08:00", "17:00")
      // Ensure time is in correct format
      let targetTime = time24Hour;
      if (!targetTime.includes(':')) {
        // Convert "0800" to "08:00"
        if (targetTime.length === 4) {
          targetTime = `${targetTime.substring(0, 2)}:${targetTime.substring(2)}`;
        }
      }
      
      // Find matching option
      const options = Array.from(selectElement.options);
      let matchedOption = null;
      
      // Strategy 1: Exact value match
      matchedOption = options.find(opt => opt.value === targetTime);
      
      // Strategy 2: Normalized match (handle variations)
      if (!matchedOption) {
        const normalizeTime = (timeStr) => {
          return timeStr.replace(/:/g, '').padStart(4, '0');
        };
        
        const normalizedTarget = normalizeTime(targetTime);
        matchedOption = options.find(opt => {
          const optNormalized = normalizeTime(opt.value);
          return optNormalized === normalizedTarget;
        });
      }
      
      if (matchedOption) {
        selectElement.value = matchedOption.value;
        selectElement.dispatchEvent(new Event('change', { bubbles: true }));
        selectElement.dispatchEvent(new Event('input', { bubbles: true }));
        selectElement.style.border = '2px solid #4CAF50';
        return true;
      } else {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Could not find matching option for ${type} time "${targetTime}"`);
        return false;
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Error filling Symfony ${type} select:`, error);
      return false;
    }
  }
  
  /**
   * Convert time to CompanyWorkingHoursForm option format: "HH:MM AM/PM" (2-digit hour, e.g. "08:00 AM")
   */
  function toCompanyWorkingHoursOptionFormat(timeStr) {
    if (!timeStr || typeof timeStr !== 'string') return '';
    const cleaned = timeStr.trim();
    if (!cleaned) return '';
    // Already in 12h format - ensure 2-digit hour
    const m12 = cleaned.match(/^(\d{1,2}):(\d{2})\s*(AM|PM|am|pm)$/i);
    if (m12) {
      const h = parseInt(m12[1], 10);
      const mm = m12[2];
      const period = m12[3].toUpperCase();
      return `${String(h).padStart(2, '0')}:${mm} ${period === 'AM' ? 'AM' : 'PM'}`;
    }
    // 24h format - convert then pad
    const hour24 = convertTo24Hour(cleaned);
    if (!hour24) return cleaned;
    const hour12 = convertTo12Hour(hour24);
    const m = hour12.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
    if (m) {
      return `${String(parseInt(m[1], 10)).padStart(2, '0')}:${m[2]} ${m[3]}`;
    }
    return hour12 || cleaned;
  }

  /**
   * Handle CompanyWorkingHoursForm structure
   * Structure: form[data-form-name="CompanyWorkingHoursForm"] > .form-subsection > .radio-label
   * Each .radio-label: label.day-of-week (Monday..Sunday), select[name="openingStart"], select[name="closingEnd"]
   * Option values: "12:00 AM", "08:00 AM", "05:00 PM" (12-hour format)
   * Also handles "Open 24 hours" checkbox (name="hours_24_open") when hours indicate 24h operation
   */
  async function handleCompanyWorkingHoursFormStructure(hoursData, stepIndex, contextElement = null) {
    console.log(`üèóÔ∏è [${stepIndex}] Processing CompanyWorkingHoursForm structure`);
    const searchRoot = contextElement || document;
    const form = searchRoot.querySelector('form[data-form-name="CompanyWorkingHoursForm"]') || searchRoot.querySelector('form');
    const subsection = form ? form.querySelector('.form-subsection') : searchRoot.querySelector('.form-subsection');
    const container = subsection || form || searchRoot;
    if (!container) {
      return { success: false, filledCount: 0, error: 'CompanyWorkingHoursForm structure not found' };
    }
    const hoursTextFor24 = getHoursTextFor24HourDetection(hoursData, hoursData);
    const detection24 = detect24HourOperation(hoursTextFor24, 'company-working-hours-form', hoursData?.businessHoursStatus);
    const formEl = container.closest('form') || searchRoot.querySelector('form[data-form-name="CompanyWorkingHoursForm"]') || searchRoot.querySelector('form');
    const open24Checkbox = formEl?.querySelector('input[name="hours_24_open"], input[id*="hours_24_open"]');
    if (detection24?.is24Hours && open24Checkbox && open24Checkbox.type === 'checkbox') {
      open24Checkbox.checked = true;
      open24Checkbox.dispatchEvent(new Event('change', { bubbles: true }));
      open24Checkbox.dispatchEvent(new Event('click', { bubbles: true }));
      console.log(`‚úÖ [${stepIndex}] Checked "Open 24 hours" checkbox`);
      return { success: true, filledCount: 1, detectedCount: 1, filledDetails: [{ day: '24h', open: '24 hours', close: '24 hours' }] };
    }
    const radioLabels = Array.from(container.querySelectorAll('.radio-label'));
    if (!radioLabels.length) {
      return { success: false, filledCount: 0, error: 'CompanyWorkingHoursForm structure not found (no .radio-label)' };
    }
    const dayLabelToKey = { monday: 'mon', tuesday: 'tue', wednesday: 'wed', thursday: 'thu', friday: 'fri', saturday: 'sat', sunday: 'sun' };
    let filledCount = 0;
    const filledDetails = [];
    const fillSelect = async (sel, val) => {
      if (!sel || sel.tagName !== 'SELECT') return false;
      const opts = Array.from(sel.options);
      const match = opts.find(o => o.value === val || (o.value && o.value.toLowerCase() === val.toLowerCase()));
      if (match) {
        sel.value = match.value;
        sel.dispatchEvent(new Event('change', { bubbles: true }));
        sel.dispatchEvent(new Event('input', { bubbles: true }));
        return true;
      }
      return false;
    };
    const setDayCheckbox = (checkbox, checked) => {
      if (!checkbox || checkbox.type !== 'checkbox') return false;
      if (checkbox.checked !== checked) {
        checkbox.checked = checked;
        checkbox.dispatchEvent(new Event('change', { bubbles: true }));
        checkbox.dispatchEvent(new Event('click', { bubbles: true }));
        return true;
      }
      return false;
    };
    for (const label of radioLabels) {
      const dayLabel = label.querySelector('.day-of-week');
      if (!dayLabel) continue;
      const dayText = dayLabel.textContent.trim().toLowerCase();
      const dayKey = dayLabelToKey[dayText];
      if (!dayKey) continue;
      const dayCheckbox = label.querySelector('input[type="checkbox"]');
      const openSelect = label.querySelector('select[name="openingStart"]');
      const closeSelect = label.querySelector('select[name="closingEnd"]');
      if (!openSelect || !closeSelect) continue;
      const isClosed = isDayExplicitlyClosed(hoursData, dayKey);
      if (isClosed) {
        if (setDayCheckbox(dayCheckbox, false)) {
          filledCount++;
          filledDetails.push({ day: dayKey, open: 'closed', close: 'closed' });
          console.log(`‚úÖ [${stepIndex}] ${dayKey} marked Closed (checkbox unchecked)`);
        }
        await new Promise(r => setTimeout(r, 50));
        continue;
      }
      if (setDayCheckbox(dayCheckbox, true)) filledCount++;
      const amValue = getHoursValueWithFallback(hoursData, dayKey, 'am', stepIndex);
      const pmValue = getHoursValueWithFallback(hoursData, dayKey, 'pm', stepIndex);
      if (!isUsableHourValue(amValue) || !isUsableHourValue(pmValue)) {
        await new Promise(r => setTimeout(r, 50));
        continue;
      }
      const open12 = toCompanyWorkingHoursOptionFormat(amValue);
      const close12 = toCompanyWorkingHoursOptionFormat(pmValue);
      if (!open12 || !close12) {
        await new Promise(r => setTimeout(r, 50));
        continue;
      }
      const okOpen = await fillSelect(openSelect, open12);
      const okClose = await fillSelect(closeSelect, close12);
      if (okOpen || okClose) {
        filledCount += (okOpen ? 1 : 0) + (okClose ? 1 : 0);
        filledDetails.push({ day: dayKey, open: open12, close: close12 });
        console.log(`‚úÖ [${stepIndex}] Filled ${dayKey}: ${open12} - ${close12}`);
      }
      await new Promise(r => setTimeout(r, 50));
    }
    return { success: filledCount > 0, filledCount, detectedCount: filledCount, filledDetails };
  }

  /**
   * Find best-matching option for subscriber-openinghours2 time selects (options use "12:00 AM", "8:00", "08:15", "18:00" etc.)
   */
  function findSubscriberOpeningHoursOption(selectEl, timeStr) {
    if (!selectEl || selectEl.tagName !== 'SELECT' || !timeStr) return null;
    const opts = Array.from(selectEl.options);
    if (!opts.length) return null;
    const cleaned = String(timeStr).trim();
    if (!cleaned) return null;
    const candidates = [
      cleaned,
      toCompanyWorkingHoursOptionFormat(cleaned),
      convertTo24Hour(cleaned) || convertTo24Hour(toCompanyWorkingHoursOptionFormat(cleaned))
    ].filter(Boolean);
    const normalized = (s) => String(s || '').trim().toLowerCase().replace(/\s+/g, ' ');
    for (const opt of opts) {
      const v = opt.value;
      if (!v) continue;
      const vNorm = normalized(v);
      for (const c of candidates) {
        if (!c) continue;
        if (v === c || vNorm === normalized(c)) return opt;
        const c24 = convertTo24Hour(c);
        if (c24 && (v === c24 || vNorm === normalized(c24))) return opt;
        const c12 = toCompanyWorkingHoursOptionFormat(c) || convertTo12Hour(c);
        if (c12 && (v === c12 || vNorm === normalized(c12))) return opt;
      }
    }
    return null;
  }

  /**
   * Handle subscriber-openinghours2 / Angular opening hours structure
   * Flow: table with Mon-Sun rows, open switch per day; for open days click pencil -> modal with from/to selects -> Change
   * Structure: subscriber-openinghours2 or .openinghours > table.hover > tr with td.col-day, input#open-MONDAY, openinghour-timeinterval (pencil, from/to selects, Change)
   */
  async function handleSubscriberOpeningHours2Structure(hoursData, stepIndex, contextElement = null) {
    console.log(`üèóÔ∏è [${stepIndex}] Processing subscriber-openinghours2 structure`);
    const searchRoot = contextElement || document;
    const container = searchRoot.querySelector('subscriber-openinghours2, [formcontrolname="openinghours"]') ||
      searchRoot.querySelector('.openinghours');
    if (!container) {
      return { success: false, filledCount: 0, error: 'subscriber-openinghours2 structure not found' };
    }
    const table = container.querySelector('table.hover, table');
    if (!table) {
      return { success: false, filledCount: 0, error: 'subscriber-openinghours2 table not found' };
    }
    const rows = Array.from(table.querySelectorAll('tbody tr, tr')).filter(tr => tr.querySelector('td.col-day'));
    if (!rows.length) {
      return { success: false, filledCount: 0, error: 'subscriber-openinghours2 rows not found' };
    }
    const dayLabelToKey = {
      mon: 'mon', 'mon.': 'mon', monday: 'mon',
      tue: 'tue', 'tue.': 'tue', tuesday: 'tue',
      wed: 'wed', 'wed.': 'wed', wednesday: 'wed',
      thu: 'thu', 'thu.': 'thu', thursday: 'thu',
      fri: 'fri', 'fri.': 'fri', friday: 'fri',
      sat: 'sat', 'sat.': 'sat', saturday: 'sat',
      sun: 'sun', 'sun.': 'sun', sunday: 'sun'
    };
    const hoursTextFor24 = getHoursTextFor24HourDetection(hoursData, hoursData);
    const detection24 = (hoursTextFor24 && /24\s*hours?/i.test(hoursTextFor24))
      ? { is24Hours: true }
      : { is24Hours: false };
    const setSwitch = (el, checked) => {
      if (!el || el.type !== 'checkbox') return false;
      if (el.checked !== checked) {
        el.checked = checked;
        el.dispatchEvent(new Event('change', { bubbles: true }));
        el.dispatchEvent(new Event('click', { bubbles: true }));
        return true;
      }
      return false;
    };
    let filledCount = 0;
    const filledDetails = [];
    for (const row of rows) {
      const dayCell = row.querySelector('td.col-day');
      if (!dayCell) continue;
      const dayText = dayCell.textContent.trim().toLowerCase().replace(/\.$/, '');
      const dayKey = dayLabelToKey[dayText] || dayLabelToKey[dayText.slice(0, 3)];
      if (!dayKey) continue;
      const openSwitch = row.querySelector('input[id^="open-"], input[type="checkbox"]');
      const open24hSwitch = row.querySelector('input[id^="open24h-"]');
      const timeIntervalEl = row.querySelector('openinghour-timeinterval, .openinghour-timeinterval');
      const isClosed = isDayExplicitlyClosed(hoursData, dayKey);
      if (isClosed) {
        if (openSwitch && setSwitch(openSwitch, false)) {
          filledCount++;
          filledDetails.push({ day: dayKey, open: 'closed', close: 'closed' });
          console.log(`‚úÖ [${stepIndex}] ${dayKey} marked Closed (switch unchecked)`);
        }
        await new Promise(r => setTimeout(r, 80));
        continue;
      }
      if (openSwitch && setSwitch(openSwitch, true)) filledCount++;
      const is24hDay = detection24.is24Hours || (hoursData?.__24HourDays && hoursData.__24HourDays[dayKey]);
      if (is24hDay && open24hSwitch) {
        if (setSwitch(open24hSwitch, true)) {
          filledCount++;
          filledDetails.push({ day: dayKey, open: '24h', close: '24h' });
          console.log(`‚úÖ [${stepIndex}] ${dayKey} set to 24 hours`);
        }
        await new Promise(r => setTimeout(r, 80));
        continue;
      }
      if (open24hSwitch && setSwitch(open24hSwitch, false)) filledCount++;
      const amValue = getHoursValueWithFallback(hoursData, dayKey, 'am', stepIndex);
      const pmValue = getHoursValueWithFallback(hoursData, dayKey, 'pm', stepIndex);
      if (!isUsableHourValue(amValue) || !isUsableHourValue(pmValue) || !timeIntervalEl) {
        await new Promise(r => setTimeout(r, 50));
        continue;
      }
      const pencilBtn = timeIntervalEl.querySelector('button i.fi-pencil, button .fi-pencil');
      const pencilButton = pencilBtn ? pencilBtn.closest('button') : timeIntervalEl.querySelector('button');
      if (!pencilButton) {
        await new Promise(r => setTimeout(r, 50));
        continue;
      }
      pencilButton.click();
      await new Promise(r => setTimeout(r, 150));
      const editDiv = timeIntervalEl.querySelector('.openinghour-timeinterval-edit, [class*="timeinterval-edit"]');
      const fromSelect = editDiv?.querySelector('select[id="timeinterval-from"], select:first-of-type');
      const toSelect = editDiv?.querySelector('select[id="timeinterval-to"], select:last-of-type');
      const buttons = editDiv ? Array.from(editDiv.querySelectorAll('button')) : [];
      const changeButton = buttons.find(b => /change/i.test(b.textContent || '')) || editDiv?.querySelector('button.primary');
      if (!fromSelect || !toSelect || !changeButton) {
        const cancelBtn = buttons.find(b => /cancel/i.test(b.textContent || ''));
        if (cancelBtn) cancelBtn.click();
        await new Promise(r => setTimeout(r, 80));
        continue;
      }
      const fromOpt = findSubscriberOpeningHoursOption(fromSelect, amValue);
      const toOpt = findSubscriberOpeningHoursOption(toSelect, pmValue);
      if (fromOpt) {
        fromSelect.value = fromOpt.value;
        fromSelect.dispatchEvent(new Event('change', { bubbles: true }));
        filledCount++;
      }
      if (toOpt) {
        toSelect.value = toOpt.value;
        toSelect.dispatchEvent(new Event('change', { bubbles: true }));
        filledCount++;
      }
      if (fromOpt || toOpt) {
        filledDetails.push({ day: dayKey, open: amValue, close: pmValue });
        console.log(`‚úÖ [${stepIndex}] Filled ${dayKey}: ${amValue} - ${pmValue} (via pencil modal)`);
      }
      changeButton.click();
      await new Promise(r => setTimeout(r, 120));
    }
    return { success: filledCount > 0, filledCount, detectedCount: filledCount, filledDetails };
  }

  /**
   * Handle dl#anw-hour1 structure - no toggles, direct field filling
   * Structure: <dl id="anw-hour1"><dt><label>Day</label></dt><dd><select name="day_am">...</select><select name="day_pm">...</select></dd></dl>
   */
  async function handleAnwHourStructure(hoursData, stepIndex, contextElement = null) {
    console.log(`üèóÔ∏è [${stepIndex}] Processing dl#anw-hour1 structure (no toggles)`);
    
    const searchRoot = contextElement || document;
    const anwHourContainer = searchRoot.querySelector('dl#anw-hour1, #anw-hour1, dl[id*="hour"][id*="anw"]');
    
    if (!anwHourContainer) {
      return { success: false, filledCount: 0, error: 'anw-hour1 structure not found' };
    }
    
    // Get all dt/dd pairs
    const dtElements = Array.from(anwHourContainer.querySelectorAll('dt'));
    let filledCount = 0;
    const filledDetails = [];
    
    // Day mapping
    const dayMap = {
      'monday': 'mon', 'mon': 'mon',
      'tuesday': 'tue', 'tue': 'tue',
      'wednesday': 'wed', 'wed': 'wed',
      'thursday': 'thu', 'thu': 'thu',
      'friday': 'fri', 'fri': 'fri',
      'saturday': 'sat', 'sat': 'sat',
      'sunday': 'sun', 'sun': 'sun'
    };
    
    // Process each day in order
    for (const dt of dtElements) {
      const label = dt.querySelector('label');
      if (!label) continue;
      
      const labelText = label.textContent.trim().toLowerCase();
      let matchedDay = null;
      
      // Match day from label
      for (const [key, day] of Object.entries(dayMap)) {
        if (labelText.includes(key)) {
          matchedDay = day;
          break;
        }
      }
      
      if (!matchedDay) continue;
      
      // Get corresponding dd element
      const dd = dt.nextElementSibling;
      if (!dd || dd.tagName !== 'DD') continue;
      
      // Find AM and PM selects
      const selects = Array.from(dd.querySelectorAll('select'));
      if (selects.length < 2) continue;
      
      // First select is AM, second is PM (based on structure)
      const amSelect = selects[0];
      const pmSelect = selects[1];
      
      // Get hours for this day
      const amValue = getHoursValueWithFallback(hoursData, matchedDay, 'am', stepIndex);
      const pmValue = getHoursValueWithFallback(hoursData, matchedDay, 'pm', stepIndex);
      
      // If explicitly closed, try to mark selects as closed
      if (isDayExplicitlyClosed(hoursData, matchedDay)) {
        applyClosedValueToField(amSelect, stepIndex, matchedDay, 'am');
        applyClosedValueToField(pmSelect, stepIndex, matchedDay, 'pm');
        continue;
      }
      
      // Fill AM field
      if (isUsableHourValue(amValue)) {
        const success = fillAnwHourSelect(amSelect, amValue, stepIndex, matchedDay, 'am');
        if (success) {
          filledCount++;
          filledDetails.push({ day: matchedDay, period: 'am', value: amValue });
          console.log(`‚úÖ [${stepIndex}] Filled ${matchedDay} AM = "${amValue}"`);
        }
      }
      
      // Fill PM field
      if (isUsableHourValue(pmValue)) {
        const success = fillAnwHourSelect(pmSelect, pmValue, stepIndex, matchedDay, 'pm');
        if (success) {
          filledCount++;
          filledDetails.push({ day: matchedDay, period: 'pm', value: pmValue });
          console.log(`‚úÖ [${stepIndex}] Filled ${matchedDay} PM = "${pmValue}"`);
        }
      }
    }
    
    console.log(`‚úÖ [${stepIndex}] anw-hour1 structure: ${filledCount} field(s) filled`);
    return {
      success: filledCount > 0,
      filledCount,
      toggleCount: 0, // No toggles in this structure
      detectedCount: filledCount,
      toggleDetectedCount: 0,
      filledDetails
    };
  }
  
  /**
   * Fill a select field in anw-hour1 structure
   * Handles 4-digit time values (e.g., "0800", "1700")
   */
  function fillAnwHourSelect(selectElement, hourValue, stepIndex, day, period) {
    if (!selectElement || selectElement.tagName !== 'SELECT') {
      return false;
    }
    
    try {
      const isClosedValue = isClosedHourValue(hourValue);
      const normalizedHourValue = String(hourValue).trim();
      // Convert hour value to 4-digit format (e.g., "8:00 AM" -> "0800", "5:00 PM" -> "1700")
      const hour24 = convertTo24Hour(normalizedHourValue);
      const fourDigit = convertTo4Digit(hour24);
      
      // Try to find matching option
      const options = Array.from(selectElement.options);
      let matchedOption = null;

      const isClosedOption = (option) => {
        const optValue = String(option.value || '').trim().toLowerCase();
        const optText = String(option.textContent || '').trim().toLowerCase();
        return optValue === 'closed' || optText === 'closed';
      };

      const isNonTimeClosedValue = (value) => {
        const normalized = String(value || '').trim().toLowerCase();
        return normalized === '00' || normalized === '0000' || normalized === '00:00';
      };

      if (!isClosedValue && (hour24 === '00:00' || normalizedHourValue.toLowerCase().includes('12:00') && /am/i.test(normalizedHourValue))) {
        const midnightOption = options.find(opt => {
          const optValue = String(opt.value || '').trim();
          const optText = String(opt.textContent || '').trim().toLowerCase();
          return optValue === '2400' || optText.includes('12:00am') || optText.includes('12:00 am');
        });
        if (midnightOption) {
          matchedOption = midnightOption;
        }
      }
      
      // Strategy 1: Exact value match (4-digit format)
      if (!matchedOption) {
        matchedOption = options.find(opt => {
          const optValue = String(opt.value).trim();
          if (!isClosedValue && (isClosedOption(opt) || isNonTimeClosedValue(optValue))) {
            return false;
          }
          return optValue === fourDigit || optValue === hour24.replace(':', '');
        });
      }
      
      // Strategy 2: Text match (looks for time in option text)
      if (!matchedOption) {
        const hourText = hour24.toLowerCase();
        matchedOption = options.find(opt => {
          const optText = opt.textContent.trim().replace(/\u00A0/g, ' ').toLowerCase();
          if (!isClosedValue && isClosedOption(opt)) {
            return false;
          }
          return optText.includes(hourText) || optText.includes(fourDigit);
        });
      }
      
      // Strategy 3: Normalized match
      if (!matchedOption) {
        const normalizeTime = (timeStr) => {
          return timeStr.toLowerCase()
            .replace(/\s+/g, '')
            .replace(/[ap]m/gi, '')
            .replace(/:/g, '')
            .replace(/^0+/, '');
        };
        
        const normalizedValue = normalizeTime(fourDigit);
        matchedOption = options.find(opt => {
          const optValue = normalizeTime(opt.value);
          const optText = normalizeTime(opt.textContent);
          if (!isClosedValue && isClosedOption(opt)) {
            return false;
          }
          return optValue === normalizedValue || optText === normalizedValue;
        });
      }
      
      if (matchedOption) {
        selectElement.value = matchedOption.value;
        selectElement.dispatchEvent(new Event('change', { bubbles: true }));
        selectElement.dispatchEvent(new Event('input', { bubbles: true }));
        selectElement.style.border = '2px solid #4CAF50';
        return true;
      } else {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Could not find matching option for ${day} ${period} with value "${hourValue}" (4-digit: "${fourDigit}")`);
        return false;
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Error filling anw-hour1 select:`, error);
      return false;
    }
  }
  
  /**
   * Convert time to 4-digit format (e.g., "08:00" -> "0800", "17:00" -> "1700")
   */
  function convertTo4Digit(timeStr) {
    if (!timeStr) return '';
    const normalized = timeStr.replace(/:/g, '').replace(/\s/g, '');
    // If already 4 digits, return as is
    if (/^\d{4}$/.test(normalized)) {
      return normalized;
    }
    // If has colon, remove it
    if (normalized.includes(':')) {
      return normalized.replace(':', '');
    }
    // Pad to 4 digits if needed
    return normalized.padStart(4, '0');
  }
  
  /**
   * Handle hoursOfOperation structure - with toggles, form-groups
   * This is the existing logic, kept separate for structure isolation
   */
  /**
   * Handle hoursPicker structure (#hourswrapper, #hoursPicker with time-closed checkboxes)
   * Structure: Table-based with TD elements, time-closed/time-all-day checkboxes, visible and hidden inputs
   * Format: mo_s1 (AM start), mo_e1 (PM end), mo_s2/mo_e2 (split hours)
   */
  async function handleHoursPickerStructure(hoursData, stepIndex, contextElement = null) {
    console.log(`üèóÔ∏è [${stepIndex}] Processing hoursPicker structure (#hourswrapper/#hoursPicker)`);
    
    const searchRoot = contextElement || document;
    // Check multiple possible container selectors
    const hoursPickerContainer = searchRoot.querySelector('#hourswrapper, #hoursPicker, #hours-of-operation');
    
    if (!hoursPickerContainer) {
      return { success: false, filledCount: 0, error: 'hoursPicker structure not found' };
    }
    
    // Also check if we need to look inside #hours-of-operation for #hourswrapper
    let actualContainer = hoursPickerContainer;
    if (hoursPickerContainer.id === 'hours-of-operation') {
      const innerWrapper = hoursPickerContainer.querySelector('#hourswrapper, #hoursPicker');
      if (innerWrapper) {
        actualContainer = innerWrapper;
      }
    }
    
    // Day mapping: our format -> site format (abbreviations)
    const dayMap = {
      'mon': 'mo', 'tue': 'tu', 'wed': 'we', 'thu': 'th',
      'fri': 'fr', 'sat': 'sa', 'sun': 'su'
    };
    
    let filledCount = 0;
    const filledDetails = [];
    const allDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    
    // Process each day
    for (const day of allDays) {
      const dayAbbrev = dayMap[day];
      if (!dayAbbrev) continue;
      
      const amValue = getHoursValueWithFallback(hoursData, day, 'am', stepIndex);
      const pmValue = getHoursValueWithFallback(hoursData, day, 'pm', stepIndex);
      
      // Check if day should be closed or has hours
      const hasHours = isDayExplicitlyClosed(hoursData, day)
        ? false
        : (isUsableHourValue(amValue) || isUsableHourValue(pmValue));
      
      // Find the TD container for this day
      const dayTd = actualContainer.querySelector(`td#${dayAbbrev}-time`);
      if (!dayTd) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Day container not found for ${day} (${dayAbbrev}-time)`);
        continue;
      }
      
      // Handle checkboxes
      const closedCheckbox = dayTd.querySelector('.time-closed');
      const allDayCheckbox = dayTd.querySelector('.time-all-day');
      
      if (!hasHours) {
        // Day is closed - check the closed checkbox
        if (closedCheckbox && !closedCheckbox.checked) {
          closedCheckbox.click();
          closedCheckbox.checked = true;
          closedCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
          console.log(`‚úÖ [${stepIndex}] Marked ${day} as closed`);
        }
        if (allDayCheckbox && allDayCheckbox.checked) {
          allDayCheckbox.click();
          allDayCheckbox.checked = false;
          allDayCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        continue; // Skip filling time fields for closed days
      } else {
        // Day has hours - uncheck closed checkbox and ensure time inputs are visible
        if (closedCheckbox && closedCheckbox.checked) {
          closedCheckbox.click();
          closedCheckbox.checked = false;
          closedCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
          console.log(`‚úÖ [${stepIndex}] Unchecked closed checkbox for ${day}`);
        }
        if (allDayCheckbox && allDayCheckbox.checked) {
          allDayCheckbox.click();
          allDayCheckbox.checked = false;
          allDayCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        // Ensure the time input tbody is visible
        const timeTbody = actualContainer.querySelector(`tbody.${dayAbbrev}-time-open`);
        if (timeTbody && timeTbody.style.display === 'none') {
          timeTbody.style.display = 'table-row-group';
        }
      }
      
      // Convert times to 24-hour format
      const am24 = amValue ? convertTo24Hour(amValue.trim()) : null;
      const pm24 = pmValue ? convertTo24Hour(pmValue.trim()) : null;
      
      if (!am24 || !pm24) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Missing time values for ${day}: am="${amValue}", pm="${pmValue}"`);
        continue;
      }
      
      // Fill visible inputs (first period: s1/e1)
      const startInput1 = actualContainer.querySelector(`input#${dayAbbrev}_s1`);
      const endInput1 = actualContainer.querySelector(`input#${dayAbbrev}_e1`);
      
      if (startInput1 && endInput1) {
        // Fill visible inputs
        const startSuccess = await fillHoursPickerInput(startInput1, am24, stepIndex, `${day} start`);
        const endSuccess = await fillHoursPickerInput(endInput1, pm24, stepIndex, `${day} end`);
        
        if (startSuccess && endSuccess) {
          filledCount += 2;
          filledDetails.push({ day, period: 'am', value: am24, field: `${dayAbbrev}_s1` });
          filledDetails.push({ day, period: 'pm', value: pm24, field: `${dayAbbrev}_e1` });
          console.log(`‚úÖ [${stepIndex}] Filled ${day} hours: ${am24} - ${pm24}`);
        }
        
        // Fill hidden inputs
        const hiddenStart1 = document.querySelector(`input#id_${dayAbbrev}_s1`);
        const hiddenEnd1 = document.querySelector(`input#id_${dayAbbrev}_e1`);
        
        if (hiddenStart1) {
          hiddenStart1.value = am24;
          hiddenStart1.setAttribute('value', am24);
          hiddenStart1.dispatchEvent(new Event('change', { bubbles: true }));
        }
        if (hiddenEnd1) {
          hiddenEnd1.value = pm24;
          hiddenEnd1.setAttribute('value', pm24);
          hiddenEnd1.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }

      // Handle split hours (s2/e2) if provided
      const splitStartValue = hoursData[`${day}Am2`] || hoursData[`${day}AmSlot2`] || hoursData[`${day}Open2`];
      const splitEndValue = hoursData[`${day}Pm2`] || hoursData[`${day}PmSlot2`] || hoursData[`${day}Close2`];
      const splitStart24 = splitStartValue ? convertTo24Hour(String(splitStartValue).trim()) : null;
      const splitEnd24 = splitEndValue ? convertTo24Hour(String(splitEndValue).trim()) : null;

      if (splitStart24 && splitEnd24) {
        const startInput2 = actualContainer.querySelector(`input#${dayAbbrev}_s2`);
        const endInput2 = actualContainer.querySelector(`input#${dayAbbrev}_e2`);

        if (startInput2 && endInput2) {
          const start2Success = await fillHoursPickerInput(startInput2, splitStart24, stepIndex, `${day} split start`);
          const end2Success = await fillHoursPickerInput(endInput2, splitEnd24, stepIndex, `${day} split end`);

          if (start2Success && end2Success) {
            filledCount += 2;
            filledDetails.push({ day, period: 'am2', value: splitStart24, field: `${dayAbbrev}_s2` });
            filledDetails.push({ day, period: 'pm2', value: splitEnd24, field: `${dayAbbrev}_e2` });
            console.log(`‚úÖ [${stepIndex}] Filled ${day} split hours: ${splitStart24} - ${splitEnd24}`);
          }

          const hiddenStart2 = document.querySelector(`input#id_${dayAbbrev}_s2`);
          const hiddenEnd2 = document.querySelector(`input#id_${dayAbbrev}_e2`);
          if (hiddenStart2) {
            hiddenStart2.value = splitStart24;
            hiddenStart2.setAttribute('value', splitStart24);
            hiddenStart2.dispatchEvent(new Event('change', { bubbles: true }));
          }
          if (hiddenEnd2) {
            hiddenEnd2.value = splitEnd24;
            hiddenEnd2.setAttribute('value', splitEnd24);
            hiddenEnd2.dispatchEvent(new Event('change', { bubbles: true }));
          }
        }
      }
    }
    
    console.log(`‚úÖ [${stepIndex}] hoursPicker structure: ${filledCount} field(s) filled`);
    return {
      success: filledCount > 0,
      filledCount,
      toggleCount: 0,
      detectedCount: filledCount,
      filledDetails
    };
  }
  
  /**
   * Helper function to fill hoursPicker input fields (handles time picker library)
   */
  async function fillHoursPickerInput(input, timeValue, stepIndex, fieldLabel) {
    if (!input || !timeValue) {
      return false;
    }
    
    try {
      // Remove readonly/disabled
      if (input.readOnly) {
        input.readOnly = false;
        input.removeAttribute('readonly');
      }
      if (input.disabled) {
        input.disabled = false;
        input.removeAttribute('disabled');
      }
      
      // Focus the input first
      input.focus();
      input.click();
      
      // Set the value
      input.value = timeValue;
      input.setAttribute('value', timeValue);
      
      // Trigger events for time picker library
      const events = ['input', 'change', 'blur', 'keyup', 'keydown', 'focus'];
      events.forEach(eventType => {
        input.dispatchEvent(new Event(eventType, { bubbles: true, cancelable: true }));
      });
      
      // If jQuery UI timepicker is present, trigger its events
      if (window.jQuery && input.id) {
        const $input = window.jQuery(input);
        if ($input.timepicker) {
          $input.timepicker('setTime', timeValue);
        }
        // Also trigger timepicker change event
        $input.trigger('changeTime');
        $input.trigger('timepicker-change');
      }
      
      // Execute once, then verify (no retry on validation failure)
      await delay(50);
      const actualValue = input.value || input.getAttribute('value') || '';
      
      if (actualValue === timeValue || actualValue.includes(timeValue.split(':')[0])) {
        input.style.border = '2px solid #4CAF50';
        console.log(`‚úÖ [${stepIndex}] Filled ${fieldLabel}: "${timeValue}" (verified: "${actualValue}")`);
        return true;
      } else {
        console.warn(`‚ö†Ô∏è [${stepIndex}] ${fieldLabel} value did not persist: expected "${timeValue}", got "${actualValue}"`);
        return false;
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Error filling ${fieldLabel}:`, error);
      return false;
    }
  }

  async function handleHoursOfOperationStructure(hoursData, stepIndex, contextElement = null) {
    console.log(`üèóÔ∏è [${stepIndex}] Processing hoursOfOperation structure (with toggles)`);
    
    // Step 1: Detect toggle checkboxes first
    const detectedToggles = detectToggleCheckboxes(contextElement);
    console.log(`‚úÖ [${stepIndex}] Detected ${detectedToggles.length} toggle checkbox(es)`);
    
    // Step 2: Detect all hour fields
    const detectedFields = detectHourFields(contextElement);
    console.log(`‚úÖ [${stepIndex}] Detected ${detectedFields.length} potential hour field(s)`);
    
    if (detectedFields.length === 0 && detectedToggles.length === 0) {
      return { success: false, filledCount: 0, error: 'No hour fields or toggle checkboxes detected' };
    }
    
    // Map day/period to valueKey format (including Holiday)
    const dayKeyMap = {
      'mon': 'mon', 'tue': 'tue', 'wed': 'wed', 'thu': 'thu',
      'fri': 'fri', 'sat': 'sat', 'sun': 'sun', 'holiday': 'holiday'
    };
    
    let filledCount = 0;
    let toggleCount = 0;
    const filledDetails = [];
    
    // Step 3: Handle toggle checkboxes based on hours availability (with fallback)
    for (const toggle of detectedToggles) {
      const { element: checkbox, day } = toggle;
      const dayKey = dayKeyMap[day];
      
      // Check if hours exist for this day (with fallback)
      let hasHours = false;
      if (day === 'holiday') {
        // Check for holiday hours
        const holidayAm = hoursData.holidayAm || hoursData.holidayOpen;
        const holidayPm = hoursData.holidayPm || hoursData.holidayClose;
        hasHours = isUsableHourValue(holidayAm) || isUsableHourValue(holidayPm);
      } else {
        // Check for regular day hours (with fallback)
        const amValue = getHoursValueWithFallback(hoursData, day, 'am', stepIndex);
        const pmValue = getHoursValueWithFallback(hoursData, day, 'pm', stepIndex);
        hasHours = isUsableHourValue(amValue) || isUsableHourValue(pmValue);
      }
      
      if (isDayExplicitlyClosed(hoursData, day)) {
        hasHours = false;
        console.log(`‚ÑπÔ∏è [${stepIndex}] ${day} explicitly closed - forcing toggle OFF`);
      }
      
      // Set checkbox state based on hours availability
      // For slider-style toggles, this will click the switch and update readonly state
      const success = await handleToggleCheckbox(checkbox, hasHours, stepIndex, toggle.formGroup);
      if (success) {
        toggleCount++;
        console.log(`‚úÖ [${stepIndex}] ${hasHours ? 'Checked' : 'Unchecked'} toggle for ${day} (has hours: ${hasHours})`);
      }
    }
    
    // Small delay after all toggles to ensure site handlers have processed
    await new Promise(resolve => setTimeout(resolve, 100));
    console.log(`‚è≥ [${stepIndex}] Toggle processing completed, proceeding to fill hour fields`);
    
    // Step 4: Fill each detected hour field (with fallback support)
    // First, ensure all toggles are on for days that have hours (robust fallback)
    // IMPORTANT: Check hours data directly, not just detected fields, to catch days with readonly fields
    const daysWithHours = new Set();
    
    // Method 1: Check from detected fields
    for (const detectedField of detectedFields) {
      const { day, period } = detectedField;
      if (day === 'holiday') continue;
      
      const hourValue = getHoursValueWithFallback(hoursData, day, period, stepIndex);
      if (isUsableHourValue(hourValue)) {
        daysWithHours.add(day);
      }
    }
    
    // Method 2: Also check hours data directly for all days (catches days with readonly fields that weren't detected)
    const allDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    for (const day of allDays) {
      // Check if this day has hours in the data
      const amValue = getHoursValueWithFallback(hoursData, day, 'am', stepIndex);
      const pmValue = getHoursValueWithFallback(hoursData, day, 'pm', stepIndex);
      const hasHours = isDayExplicitlyClosed(hoursData, day)
        ? false
        : (isUsableHourValue(amValue) || isUsableHourValue(pmValue));
      
      if (hasHours) {
        daysWithHours.add(day);
        console.log(`üîç [${stepIndex}] Day ${day} has hours data: am="${amValue}", pm="${pmValue}"`);
      }
    }
    
    console.log(`üîç [${stepIndex}] Days with hours (from data check): ${Array.from(daysWithHours).join(', ')}`);
    
    // IMPORTANT: Process days in order (Mon-Sun) for proper top-to-bottom sequence
    // Convert Set to ordered array to ensure consistent processing order
    const orderedDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    const daysWithHoursOrdered = orderedDays.filter(day => daysWithHours.has(day));
    console.log(`üîç [${stepIndex}] Processing toggles in order: ${daysWithHoursOrdered.join(', ')}`);
    
    // First, ensure toggles are OFF for explicitly closed days
    const closedDaysOrdered = orderedDays.filter(day => isDayExplicitlyClosed(hoursData, day));
    if (closedDaysOrdered.length > 0) {
      console.log(`üîç [${stepIndex}] Forcing toggles OFF for closed days: ${closedDaysOrdered.join(', ')}`);
      for (const day of closedDaysOrdered) {
        const detectedToggle = detectedToggles.find(t => t.day === day) || null;
        const toggle = detectedToggle || findToggleForDay(day, detectedFields, contextElement, stepIndex);
        if (toggle && toggle.element) {
          await handleToggleCheckbox(toggle.element, false, stepIndex, toggle.formGroup);
          toggleCount++;
          console.log(`‚úÖ [${stepIndex}] Forced toggle OFF for ${day} (explicitly closed)`);
        }
      }
    }
    
    // For each day with hours, ensure toggle is on (even if not detected initially)
    // Process in order (Mon-Sun) to match visual layout
    for (const day of daysWithHoursOrdered) {
      if (isDayExplicitlyClosed(hoursData, day)) {
        continue;
      }
      // Check if toggle was already handled
      const wasHandled = detectedToggles.some(t => t.day === day);
      
      if (!wasHandled) {
        const foundToggle = findToggleForDay(day, detectedFields, contextElement, stepIndex);
        if (foundToggle && foundToggle.element) {
          const currentChecked = foundToggle.element.checked;
          console.log(`üîç [${stepIndex}] Toggle for ${day} found: ${foundToggle.element.id || foundToggle.element.name}, currently checked: ${currentChecked}`);
          
          if (!currentChecked) {
            console.log(`üîÑ [${stepIndex}] Found and turning ON toggle for ${day} (was not detected initially or was off)`);
            const success = await handleToggleCheckbox(foundToggle.element, true, stepIndex, foundToggle.formGroup);
            if (success) {
              toggleCount++;
              await new Promise(resolve => setTimeout(resolve, 200)); // Wait longer for site handlers
            } else {
              console.warn(`‚ö†Ô∏è [${stepIndex}] Failed to turn ON toggle for ${day}`);
            }
          } else {
            console.log(`‚ÑπÔ∏è [${stepIndex}] Toggle for ${day} is already ON`);
          }
        } else {
          console.warn(`‚ö†Ô∏è [${stepIndex}] Could not find toggle for ${day} using any strategy (day has hours: ${daysWithHours.has(day)})`);
        }
      }
    }
    
    // Step 5: Fill each detected hour field (with fallback support)
    // IMPORTANT: Sort fields by day order (Mon-Sun) to match visual layout
    const dayOrder = { 'mon': 0, 'tue': 1, 'wed': 2, 'thu': 3, 'fri': 4, 'sat': 5, 'sun': 6, 'holiday': 7 };
    const sortedFields = [...detectedFields].sort((a, b) => {
      const orderA = dayOrder[a.day] !== undefined ? dayOrder[a.day] : 999;
      const orderB = dayOrder[b.day] !== undefined ? dayOrder[b.day] : 999;
      if (orderA !== orderB) return orderA - orderB;
      // If same day, AM comes before PM
      return a.period === 'am' ? -1 : 1;
    });
    
    console.log(`üîç [${stepIndex}] Processing fields in order: ${sortedFields.map(f => `${f.day}${f.period}`).join(', ')}`);
    
    for (const detectedField of sortedFields) {
      const { element, day, period } = detectedField;
      
      // Skip if field is readonly (day is closed) - but only if it's truly closed
      // We'll check this after trying to get hours with fallback
      
      let valueKey = null;
      let hourValue = null;
      
      if (day === 'holiday') {
        // Handle Holiday hours
        valueKey = period === 'am' ? 'holidayAm' : 'holidayPm';
        // Also try alternative keys
        if (!hoursData[valueKey]) {
          valueKey = period === 'am' ? 'holidayOpen' : 'holidayClose';
        }
        hourValue = hoursData[valueKey];
      } else {
        // Handle regular day hours WITH FALLBACK
        hourValue = getHoursValueWithFallback(hoursData, day, period, stepIndex);
        if (hourValue) {
          const dayKey = dayKeyMap[day];
          valueKey = `${dayKey}${period === 'am' ? 'Am' : 'Pm'}`;
        }
      }
      
      // Skip if field is readonly AND no hours available (day is truly closed)
      if (element.readOnly && element.value === '00:00' && !hourValue) {
        console.log(`‚ÑπÔ∏è [${stepIndex}] Skipping ${day} ${period} - field is readonly and no hours available`);
        continue;
      }
      
      // If we have hours (direct or fallback), fill the field
      if (isUsableHourValue(hourValue)) {
        // Log field state for debugging (especially for Saturday)
        if (day === 'sat') {
          console.log(`üîç [${stepIndex}] Saturday ${period} field state: readonly=${element.readOnly}, disabled=${element.disabled}, value="${element.value}", hasHours="${hourValue}"`);
        }
        
        // If field is readonly, we need to open the day first (toggle should have handled this, but double-check)
        if (element.readOnly || (element.disabled && !element.value)) {
          console.log(`‚ö†Ô∏è [${stepIndex}] Field ${day} ${period} is readonly/disabled but has hours - attempting to open day`);
          // Try to find and toggle the checkbox for this day using multiple strategies
          let toggleCheckbox = null;
          let toggleFormGroup = null;
          
          // Strategy 1: Look in same container as field (including hoursOfOperation)
          const formGroup = element.closest('.form-group, [class*="form-group"], dl, dt, dd, .hoursOfOperation');
          if (formGroup) {
            // Priority: Look for IsOpen pattern first
            const dayFullNames = {
              'mon': 'monday', 'tue': 'tuesday', 'wed': 'wednesday', 'thu': 'thursday',
              'fri': 'friday', 'sat': 'saturday', 'sun': 'sunday', 'holiday': 'holiday'
            };
            const dayFullName = dayFullNames[day];
            
            if (dayFullName) {
              toggleCheckbox = formGroup.querySelector(
                `input[type="checkbox"][id*="IsOpen${dayFullName}" i], input[type="checkbox"][name*="IsOpen${dayFullName}" i]`
              );
            }
            
            // Fallback: Any checkbox in form-group
            if (!toggleCheckbox) {
              toggleCheckbox = formGroup.querySelector('input[type="checkbox"]');
            }
            toggleFormGroup = formGroup;
          }
          
          // Strategy 2: Look for toggle by IsOpen pattern in hoursOfOperation
          if (!toggleCheckbox) {
            const dayFullNames = {
              'mon': 'monday', 'tue': 'tuesday', 'wed': 'wednesday', 'thu': 'thursday',
              'fri': 'friday', 'sat': 'saturday', 'sun': 'sunday', 'holiday': 'holiday'
            };
            const dayFullName = dayFullNames[day];
            
            if (dayFullName) {
              const hoursOfOperationContainer = (contextElement || document).querySelector('.hoursOfOperation, [class*="hoursOfOperation"]');
              if (hoursOfOperationContainer) {
                toggleCheckbox = hoursOfOperationContainer.querySelector(
                  `input[type="checkbox"][id*="IsOpen${dayFullName}" i], input[type="checkbox"][name*="IsOpen${dayFullName}" i]`
                );
                if (toggleCheckbox) {
                  toggleFormGroup = toggleCheckbox.closest('.form-group, [class*="form-group"]') || hoursOfOperationContainer;
                }
              }
            }
          }
          
          // Strategy 3: Look for toggle by day pattern
          if (!toggleCheckbox) {
            const dayPatternsForDay = toggleDayPatterns[day] || [];
            const searchRootForToggle = contextElement || document;
            const allCheckboxes = searchRootForToggle.querySelectorAll('input[type="checkbox"]');
            for (const cb of allCheckboxes) {
              const cbText = `${cb.id || ''} ${cb.name || ''} ${cb.className || ''}`.toLowerCase();
              const hasDayPattern = dayPatternsForDay.some(pattern => cbText.includes(pattern));
              const isToggle = (cbText.includes('open') || cbText.includes('closed') || cbText.includes('enable') ||
                              cbText.includes('isopen')) &&
                              !cbText.includes('time') && !cbText.includes('hour');
              
              if (hasDayPattern && isToggle) {
                toggleCheckbox = cb;
                toggleFormGroup = cb.closest('.form-group, [class*="form-group"], dl, dt, dd, .hoursOfOperation');
                break;
              }
            }
          }
          
          if (toggleCheckbox && !toggleCheckbox.checked) {
            console.log(`üîÑ [${stepIndex}] Opening ${day} by toggling checkbox`);
            await handleToggleCheckbox(toggleCheckbox, true, stepIndex, toggleFormGroup);
            await new Promise(resolve => setTimeout(resolve, 200)); // Wait longer for site handlers
          }
        }
        
        // Try filling - use forceFill=true if field was readonly/disabled (toggle should have handled it)
        const wasReadonly = element.readOnly || element.disabled;
        const success = await fillHourField(element, hourValue, stepIndex, wasReadonly);
        if (success) {
          filledCount++;
          filledDetails.push({
            valueKey: valueKey || `${day}${period}`,
            day,
            period,
            element: element.tagName + (element.id ? `#${element.id}` : '') + (element.name ? `[name="${element.name}"]` : ''),
            usedFallback: !hoursData[valueKey] // Mark if fallback was used
          });
          console.log(`‚úÖ [${stepIndex}] Auto-filled ${valueKey || `${day} ${period}`} (${day} ${period}) = "${hourValue}"`);
        } else {
          // If fill failed and field is readonly, try one more time with direct manipulation
          if (wasReadonly && element.tagName === 'SELECT') {
            console.log(`üîÑ [${stepIndex}] Retrying fill for ${day} ${period} using direct option selection...`);
            try {
              const hour24 = convertTo24Hour(String(hourValue).trim());
              const options = Array.from(element.options);
              
              // Try multiple matching strategies
              let matchedOption = options.find(opt => {
                const optText = opt.textContent.trim().replace(/\u00A0/g, ' ').toLowerCase();
                const optValue = (opt.value || '').trim().toLowerCase();
                return optText.includes(hour24.toLowerCase()) || 
                       optValue === hour24.toLowerCase() ||
                       optText.includes(hourValue.toLowerCase()) ||
                       optValue === hourValue.toLowerCase();
              });
              
              if (matchedOption) {
                element.value = matchedOption.value;
                element.dispatchEvent(new Event('change', { bubbles: true }));
                element.dispatchEvent(new Event('input', { bubbles: true }));
                filledCount++;
                filledDetails.push({
                  valueKey: valueKey || `${day}${period}`,
                  day,
                  period,
                  element: element.tagName + (element.id ? `#${element.id}` : '') + (element.name ? `[name="${element.name}"]` : ''),
                  usedFallback: !hoursData[valueKey]
                });
                console.log(`‚úÖ [${stepIndex}] Successfully filled ${day} ${period} using direct option selection`);
              } else {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Could not find matching option for ${day} ${period} with value "${hourValue}" (24h: "${hour24}")`);
              }
            } catch (e) {
              console.warn(`‚ö†Ô∏è [${stepIndex}] Error in retry fill for ${day} ${period}: ${e.message}`);
            }
          }
        }
      } else {
        console.log(`‚ÑπÔ∏è [${stepIndex}] Skipping ${valueKey || `${day} ${period}`} - no value available (even with fallback)`);
      }
    }
    
    const totalProcessed = filledCount + toggleCount;
    console.log(`‚úÖ [${stepIndex}] hoursOfOperation structure: ${filledCount} hour field(s) filled, ${toggleCount} toggle(s) processed`);
    
    return {
      success: totalProcessed > 0,
      filledCount,
      toggleCount,
      detectedCount: detectedFields.length,
      toggleDetectedCount: detectedToggles.length,
      filledDetails
    };
  }
  
  /**
   * Handle opening-hours table structure
   * Structure: table.opening-hours with checkboxes week[1-6,0] and time inputs op[1-6,0], cl[1-6,0]
   * Mapping: week[1]=Monday, week[2]=Tuesday, ..., week[6]=Saturday, week[0]=Sunday
   * Checkbox unchecked = closed, checked = open
   */
  async function handleOpeningHoursTableStructure(hoursData, stepIndex, contextElement = null) {
    console.log(`üèóÔ∏è [${stepIndex}] Processing opening-hours table structure`);
    
    const searchRoot = contextElement || document;
    const openingHoursTable = searchRoot.querySelector('table.opening-hours, table[class*="opening-hours"], .opening-hours table');
    
    if (!openingHoursTable) {
      return { success: false, filledCount: 0, error: 'Opening hours table structure not found' };
    }
    
    // Day mapping: our format -> table format
    // week[1]=Monday, week[2]=Tuesday, week[3]=Wednesday, week[4]=Thursday, week[5]=Friday, week[6]=Saturday, week[0]=Sunday
    const dayMap = {
      'mon': { weekIndex: 1, dayName: 'Monday' },
      'tue': { weekIndex: 2, dayName: 'Tuesday' },
      'wed': { weekIndex: 3, dayName: 'Wednesday' },
      'thu': { weekIndex: 4, dayName: 'Thursday' },
      'fri': { weekIndex: 5, dayName: 'Friday' },
      'sat': { weekIndex: 6, dayName: 'Saturday' },
      'sun': { weekIndex: 0, dayName: 'Sunday' }
    };
    
    let filledCount = 0;
    const filledDetails = [];
    const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    
    // Process each day
    for (const day of days) {
      const dayInfo = dayMap[day];
      if (!dayInfo) continue;
      
      const weekIndex = dayInfo.weekIndex;
      const amKey = `${day}Am`;
      const pmKey = `${day}Pm`;
      const amValue = hoursData[amKey];
      const pmValue = hoursData[pmKey];
      
      // Check if day has hours
      const hasHours = isDayExplicitlyClosed(hoursData, day)
        ? false
        : (isUsableHourValue(amValue) || isUsableHourValue(pmValue));
      
      // Find the checkbox for this day
      const weekCheckbox = openingHoursTable.querySelector(`input[type="checkbox"][name="week[${weekIndex}]"]`);
      
      if (!weekCheckbox) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Checkbox not found for ${day} (week[${weekIndex}])`);
        continue;
      }
      
      // Set checkbox state: checked = open, unchecked = closed
      if (hasHours) {
        // Day has hours - check the checkbox
        if (!weekCheckbox.checked) {
          weekCheckbox.checked = true;
          weekCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
          weekCheckbox.dispatchEvent(new Event('click', { bubbles: true }));
          console.log(`‚úÖ [${stepIndex}] Checked ${day} checkbox (day is open)`);
        }
        
        // Convert times to 24-hour format
        const am24 = amValue ? convertTo24Hour(String(amValue).trim()) : null;
        const pm24 = pmValue ? convertTo24Hour(String(pmValue).trim()) : null;
        
        // Fill opening time (op[X])
        if (am24) {
          const opInput = openingHoursTable.querySelector(`input[type="time"][name="op[${weekIndex}]"], input[name="op[${weekIndex}]"]`);
          if (opInput) {
            opInput.focus();
            opInput.value = am24;
            opInput.dispatchEvent(new Event('input', { bubbles: true }));
            opInput.dispatchEvent(new Event('change', { bubbles: true }));
            opInput.blur();
            filledCount++;
            filledDetails.push({ day, period: 'am', value: am24 });
            console.log(`‚úÖ [${stepIndex}] Filled ${day} opening time (op[${weekIndex}]): ${am24}`);
          } else {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Opening time input not found for ${day} (op[${weekIndex}])`);
          }
        }
        
        // Fill closing time (cl[X])
        if (pm24) {
          const clInput = openingHoursTable.querySelector(`input[type="time"][name="cl[${weekIndex}]"], input[name="cl[${weekIndex}]"]`);
          if (clInput) {
            clInput.focus();
            clInput.value = pm24;
            clInput.dispatchEvent(new Event('input', { bubbles: true }));
            clInput.dispatchEvent(new Event('change', { bubbles: true }));
            clInput.blur();
            filledCount++;
            filledDetails.push({ day, period: 'pm', value: pm24 });
            console.log(`‚úÖ [${stepIndex}] Filled ${day} closing time (cl[${weekIndex}]): ${pm24}`);
          } else {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Closing time input not found for ${day} (cl[${weekIndex}])`);
          }
        }
      } else {
        // Day has no hours - uncheck the checkbox (closed)
        if (weekCheckbox.checked) {
          weekCheckbox.checked = false;
          weekCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
          weekCheckbox.dispatchEvent(new Event('click', { bubbles: true }));
          console.log(`‚úÖ [${stepIndex}] Unchecked ${day} checkbox (day is closed)`);
        }
      }
    }
    
    console.log(`‚úÖ [${stepIndex}] Opening hours table structure: ${filledCount} field(s) filled`);
    return {
      success: filledCount > 0,
      filledCount,
      toggleCount: 0, // Checkboxes are handled but not counted as toggles
      detectedCount: filledCount,
      toggleDetectedCount: 0,
      filledDetails
    };
  }
  
  function normalizeTradingHoursTime(text) {
    return String(text || '')
      .toLowerCase()
      .replace(/\s+/g, '')
      .replace(/[ap]m/gi, '')
      .replace(/:/g, '')
      .replace(/^0+/, '');
  }

  function collectTradingHoursOptionCandidates(triggerButton) {
    const containerSelectors = [
      'ul[role="listbox"]',
      'div[role="listbox"]',
      '[class*="dropdown"]',
      '[class*="menu"]',
      '[class*="listbox"]',
      '[class*="popover"]'
    ];
    const containers = [];
    containerSelectors.forEach(selector => {
      document.querySelectorAll(selector).forEach(container => {
        if (container.offsetParent !== null && !containers.includes(container)) {
          containers.push(container);
        }
      });
    });
    const optionSelectors = ['[role="option"]', 'li', 'button', '[class*="option"]'];
    let candidates = [];
    const pushCandidate = (node) => {
      if (!node || node.offsetParent === null) return;
      const text = (node.textContent || '').trim();
      if (!text) return;
      if (!candidates.includes(node)) candidates.push(node);
    };
    containers.forEach(container => {
      optionSelectors.forEach(selector => {
        container.querySelectorAll(selector).forEach(pushCandidate);
      });
    });
    if (candidates.length === 0) {
      optionSelectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(pushCandidate);
      });
    }
    if (triggerButton && candidates.length > 1) {
      const triggerRect = triggerButton.getBoundingClientRect();
      candidates.sort((a, b) => {
        const aRect = a.getBoundingClientRect();
        const bRect = b.getBoundingClientRect();
        const aDist = Math.abs(aRect.top - triggerRect.bottom) + Math.abs(aRect.left - triggerRect.left);
        const bDist = Math.abs(bRect.top - triggerRect.bottom) + Math.abs(bRect.left - triggerRect.left);
        return aDist - bDist;
      });
    }
    return candidates;
  }

  function findTradingHoursOptionElement(triggerButton, targetValue) {
    const rawValue = String(targetValue || '').trim();
    const lowerValue = rawValue.toLowerCase();
    const isClosedTarget = lowerValue === 'closed' || lowerValue === 'close';
    const hour24 = convertTo24Hour(rawValue);
    const hour12 = convertTo12Hour(hour24);
    const candidates = [rawValue, hour24, hour12].filter(Boolean);
    const normalizedTargets = candidates.map(normalizeTradingHoursTime).filter(Boolean);
    const optionCandidates = collectTradingHoursOptionCandidates(triggerButton);
    const matchByTime = (optionText) => {
      const normalizedOption = normalizeTradingHoursTime(optionText);
      if (!normalizedOption) return false;
      if (normalizedTargets.includes(normalizedOption)) return true;
      return normalizedTargets.some(target => normalizedOption.includes(target) || target.includes(normalizedOption));
    };
    for (const option of optionCandidates) {
      const optionText = (option.textContent || option.innerText || '').trim();
      if (!optionText) continue;
      if (isClosedTarget) {
        if (optionText.toLowerCase().includes('closed')) return option;
      } else if (matchByTime(optionText)) {
        return option;
      }
    }
    return null;
  }

  async function selectTradingHoursOption(triggerButton, targetValue, stepIndex, label) {
    if (!triggerButton || !targetValue) return false;
    try {
      triggerButton.scrollIntoView({ block: 'center' });
      triggerButton.click();
      await delay(200);
      const optionEl = findTradingHoursOptionElement(triggerButton, targetValue);
      if (!optionEl) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Trading hours: no option match for ${label} "${targetValue}"`);
        return false;
      }
      optionEl.click();
      await delay(120);
      return true;
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Trading hours: error selecting ${label}:`, error);
      return false;
    }
  }

  function getTradingHoursTimeButtons(row) {
    if (!row) return [];
    return Array.from(row.querySelectorAll('button'))
      .filter(btn => isTradingHoursTimeText(btn.textContent));
  }

  function getTradingHoursStatusButton(row) {
    if (!row) return null;
    return Array.from(row.querySelectorAll('button'))
      .find(btn => {
        const text = (btn.textContent || '').trim().toLowerCase();
        return text.includes('closed') || text.includes('open');
      }) || null;
  }

  async function handleTradingHoursStructure(hoursData, stepIndex, contextElement = null) {
    console.log(`üèóÔ∏è [${stepIndex}] Processing trading hours button structure`);
    const searchRoot = contextElement || document;
    const root = findTradingHoursRoot(searchRoot);
    if (!root) {
      return { success: false, filledCount: 0, error: 'Trading hours structure not found' };
    }
    const dayRows = getTradingHoursDayRows(root);
    if (dayRows.length === 0) {
      return { success: false, filledCount: 0, error: 'Trading hours day rows not found' };
    }
    let filledCount = 0;
    const filledDetails = [];
    for (const { day, row } of dayRows) {
      const amValue = getHoursValueWithFallback(hoursData, day, 'am', stepIndex);
      const pmValue = getHoursValueWithFallback(hoursData, day, 'pm', stepIndex);
      const isClosed = isDayExplicitlyClosed(hoursData, day);
      if (isClosed) {
        const statusButton = getTradingHoursStatusButton(row);
        if (statusButton) {
          await selectTradingHoursOption(statusButton, 'Closed', stepIndex, `${day} status`);
        }
        continue;
      }
      const timeButtons = getTradingHoursTimeButtons(row);
      if (timeButtons.length < 2) {
        console.warn(`‚ö†Ô∏è [${stepIndex}] Trading hours: missing time buttons for ${day}`);
        continue;
      }
      if (isUsableHourValue(amValue)) {
        const openSuccess = await selectTradingHoursOption(timeButtons[0], amValue, stepIndex, `${day} open`);
        if (openSuccess) {
          filledCount++;
          filledDetails.push({ day, period: 'am', value: amValue });
        }
      }
      if (isUsableHourValue(pmValue)) {
        const closeSuccess = await selectTradingHoursOption(timeButtons[1], pmValue, stepIndex, `${day} close`);
        if (closeSuccess) {
          filledCount++;
          filledDetails.push({ day, period: 'pm', value: pmValue });
        }
      }
    }
    console.log(`‚úÖ [${stepIndex}] Trading hours structure: ${filledCount} field(s) filled`);
    return {
      success: filledCount > 0,
      filledCount,
      toggleCount: 0,
      detectedCount: filledCount,
      toggleDetectedCount: 0,
      filledDetails
    };
  }

  /**
   * Handle generic hour structure - fallback for unknown structures
   * Uses the original auto-detection logic as fallback
   */
  async function handleGenericHourStructure(hoursData, stepIndex, contextElement = null) {
    console.log(`üèóÔ∏è [${stepIndex}] Processing generic structure (fallback)`);
    
    // Use the original detection logic as fallback
    const detectedToggles = detectToggleCheckboxes(contextElement);
    const detectedFields = detectHourFields(contextElement);
    
    if (detectedFields.length === 0 && detectedToggles.length === 0) {
      return { success: false, filledCount: 0, error: 'No hour fields or toggle checkboxes detected' };
    }
    
    // Use simplified filling logic for generic structure
    const dayKeyMap = {
      'mon': 'mon', 'tue': 'tue', 'wed': 'wed', 'thu': 'thu',
      'fri': 'fri', 'sat': 'sat', 'sun': 'sun', 'holiday': 'holiday'
    };
    
    let filledCount = 0;
    let toggleCount = 0;
    const filledDetails = [];
    
    // Handle toggles
    for (const toggle of detectedToggles) {
      const { element: checkbox, day } = toggle;
      const amValue = getHoursValueWithFallback(hoursData, day, 'am', stepIndex);
      const pmValue = getHoursValueWithFallback(hoursData, day, 'pm', stepIndex);
      const hasHours = isUsableHourValue(amValue) || isUsableHourValue(pmValue);
      
      const success = await handleToggleCheckbox(checkbox, hasHours, stepIndex, toggle.formGroup);
      if (success) {
        toggleCount++;
      }
    }
    
    // Fill fields
    for (const detectedField of detectedFields) {
      const { element, day, period } = detectedField;
      const hourValue = getHoursValueWithFallback(hoursData, day, period, stepIndex);
      
      if (isUsableHourValue(hourValue)) {
        // Execute once, then validate; only retry on execution error (main loop)
        const success = await fillHourField(element, hourValue, stepIndex, false);
        if (success) {
          filledCount++;
          filledDetails.push({ day, period, value: hourValue });
        } else {
          console.warn(`‚ö†Ô∏è [${stepIndex}] Failed to fill ${day} ${period} field: id="${element.id || ''}", name="${element.name || ''}", value="${hourValue}", readonly=${element.readOnly}, disabled=${element.disabled}`);
        }
      } else if (isDayExplicitlyClosed(hoursData, day)) {
        applyClosedValueToField(element, stepIndex, day, period);
      }
    }
    
    console.log(`‚úÖ [${stepIndex}] Generic structure: ${filledCount} field(s) filled, ${toggleCount} toggle(s) processed`);
    return {
      success: filledCount > 0 || toggleCount > 0,
      filledCount,
      toggleCount,
      detectedCount: detectedFields.length,
      toggleDetectedCount: detectedToggles.length,
      filledDetails
    };
  }

  function getStepExecutionDecision(step) {
    const action = step?.action;
    if (typeof action === 'string' && action.toLowerCase() === 'separator') {
      return { shouldExecute: false, reason: 'separator action' };
    }
    
    if (step && Object.prototype.hasOwnProperty.call(step, 'enabled')) {
      const enabledValue = step.enabled;
      if (enabledValue === false) {
        return { shouldExecute: false, reason: 'enabled=false' };
      }
      if (typeof enabledValue === 'string' && enabledValue.toLowerCase() === 'false') {
        return { shouldExecute: false, reason: 'enabled=false' };
      }
    }
    
    return { shouldExecute: true };
  }

  function isStepIncludedInPopup(step) {
    if (!step) return false;
    const action = typeof step.action === 'string' ? step.action.toLowerCase() : '';
    if (action === 'separator') return false;
    if (step.enabled === false) return false;
    if (typeof step.enabled === 'string' && step.enabled.toLowerCase() === 'false') return false;
    if (step.skip === true) return false;
    if (typeof step.skip === 'string' && step.skip.toLowerCase() === 'true') return false;
    return true;
  }

  function getVisibleStepIndices(steps) {
    if (!Array.isArray(steps)) return [];
    const visible = [];
    for (let i = 0; i < steps.length; i++) {
      if (isStepIncludedInPopup(steps[i])) {
        visible.push(i);
      }
    }
    return visible;
  }

  function getVisibleTotalSteps(steps) {
    return getVisibleStepIndices(steps).length;
  }

  function getVisibleStepNumberFromIndex(index, steps) {
    const visibleIndices = getVisibleStepIndices(steps);
    if (visibleIndices.length === 0) return index + 1;
    const visiblePos = visibleIndices.indexOf(index);
    if (visiblePos >= 0) return visiblePos + 1;
    for (let i = 0; i < visibleIndices.length; i++) {
      if (visibleIndices[i] > index) return i + 1;
    }
    return visibleIndices.length;
  }

  function getActualIndexFromVisibleNumber(visibleNumber, steps) {
    const visibleIndices = getVisibleStepIndices(steps);
    if (!visibleNumber || visibleNumber < 1) return 0;
    const candidate = visibleIndices[visibleNumber - 1];
    if (candidate !== undefined) return candidate;
    return Math.max(0, visibleNumber - 1);
  }

  function getNextVisibleIndex(currentIndex, steps) {
    const visibleIndices = getVisibleStepIndices(steps);
    for (let i = 0; i < visibleIndices.length; i++) {
      if (visibleIndices[i] > currentIndex) return visibleIndices[i];
    }
    return currentIndex;
  }

  async function getMainCategoryFromCitations(stepIndex) {
    try {
      const { CampaignData = {} } = await chrome.storage.local.get(["CampaignData"]);
      const nestedCampaign = Object.values(CampaignData)[0];
      const currentDomain = extractBaseDomain(window.location.hostname);

      let citations = null;
      if (nestedCampaign?.campaignData?.citations && Array.isArray(nestedCampaign.campaignData.citations)) {
        citations = nestedCampaign.campaignData.citations;
      } else if (nestedCampaign?.citations && Array.isArray(nestedCampaign.citations)) {
        citations = nestedCampaign.citations;
      } else if (CampaignData.citations && Array.isArray(CampaignData.citations)) {
        citations = CampaignData.citations;
      } else if (Array.isArray(CampaignData)) {
        for (const campaign of CampaignData) {
          if (campaign.citations && Array.isArray(campaign.citations)) {
            citations = campaign.citations;
            break;
          } else if (campaign.campaignData?.citations && Array.isArray(campaign.campaignData.citations)) {
            citations = campaign.campaignData.citations;
            break;
          }
        }
      }

      if (Array.isArray(citations)) {
        const citationSites = citations.map(c => c.site).filter(Boolean);
        let matchingCitation = citations.find(citation => {
          if (!citation.site) return false;
          const citationSite = extractBaseDomain(citation.site);
          return citationSite === currentDomain.toLowerCase();
        });
        if (!matchingCitation) {
          matchingCitation = citations.find(citation => {
            if (!citation.site) return false;
            return citation.site.toLowerCase() === currentDomain.toLowerCase() ||
                   citation.site.toLowerCase() === `www.${currentDomain}`.toLowerCase();
          });
        }
        if (matchingCitation) {
          const mainCategory = matchingCitation.mainCategory || matchingCitation.maincategory || '';
          console.log(`‚úÖ [${stepIndex}] Main category from citation: "${mainCategory}"`);
          return mainCategory;
        }
        console.warn(`‚ö†Ô∏è [${stepIndex}] No citation found for domain: ${currentDomain}`);
        console.warn(`   ‚Ä¢ Available sites: ${citationSites.join(', ')}`);
        return '';
      }

      if (citations && typeof citations === 'object' && !Array.isArray(citations)) {
        const citationBySite = citations[currentDomain] || citations[`www.${currentDomain}`];
        if (citationBySite) {
          const mainCategory = citationBySite.mainCategory || citationBySite.maincategory || '';
          console.log(`‚úÖ [${stepIndex}] Main category from object citations[${currentDomain}]: "${mainCategory}"`);
          return mainCategory;
        }
      }

      console.warn(`‚ö†Ô∏è [${stepIndex}] Citations not found or invalid for domain: ${currentDomain}`);
      return '';
    } catch (error) {
      console.warn(`‚ö†Ô∏è [${stepIndex}] Error getting mainCategory from citations: ${error.message || error}`);
      return '';
    }
  }

  function getPreviousVisibleIndex(currentIndex, steps) {
    const visibleIndices = getVisibleStepIndices(steps);
    for (let i = visibleIndices.length - 1; i >= 0; i--) {
      if (visibleIndices[i] < currentIndex) return visibleIndices[i];
    }
    return currentIndex;
  }
  
  // REFACTORED: Centralized step execution function with enhanced visual feedback
  async function executeStep(step, stepIndex, totalSteps) {
      const { action, selector, valueKey, value, fillType, waitTimeout, link, linkFormat, mode, alternative, limitvalue, required, config, phoneFormat, hoursFormat, sanitization, canSkip, fallbackType, directValue, waitToClosePopup, delay: stepDelay, fillAndSelect, fillAndEnter, transpose, findAndClick, waitPopupContainer, waitPopupTimeout, waitPopupState, parentSelector, parentSelectors, logicalExpressions, categoryListStructure: stepCategoryListStructure } = step;
      
      const executionDecision = getStepExecutionDecision(step);
      if (!executionDecision.shouldExecute) {
        console.log(`‚è≠Ô∏è [${stepIndex}] Step skipped: ${executionDecision.reason || 'disabled'}`);
        return { success: true, skipped: true, reason: executionDecision.reason || 'disabled' };
      }
      
      // Step controller delay: wait BEFORE executing this step (e.g. step.delay: 1000 = wait 1s then click)
      if (stepDelay != null && stepDelay > 0) {
        const delayMs = typeof stepDelay === 'number' ? stepDelay : parseInt(stepDelay, 10);
        if (!isNaN(delayMs) && delayMs > 0) {
          console.log(`‚è≥ [${stepIndex}] Step delay: waiting ${delayMs}ms before executing (${action || 'unknown action'})...`);
          await delay(delayMs);
          if (AUTOMATION_STATE.isAborted() || !automationRunning) {
            console.log(`üõë [${stepIndex}] Automation aborted during step delay - stopping execution`);
            return { success: false, error: 'Automation aborted', aborted: true };
          }
        }
      }
      
      // NextButtonSave signal: if previous step was NextButtonSave, wait for this step's target (textbox/button) to be available before proceeding
      if (window.__NEXT_BUTTON_SAVE_PENDING__ && selector && (action === 'click' || action === 'fill' || action === 'fillAndSelect' || action === 'fillAndEnter')) {
        const waitForElementMs = 10000; // 10 seconds
        const pollIntervalMs = 300;
        const startWait = Date.now();
        let elFound = null;
        while (Date.now() - startWait < waitForElementMs) {
          if (AUTOMATION_STATE.isAborted() || !automationRunning) {
            window.__NEXT_BUTTON_SAVE_PENDING__ = false;
            return { success: false, error: 'Automation aborted', aborted: true };
          }
          try {
            elFound = document.querySelector(selector);
            if (elFound && elFound.offsetParent !== null) {
              console.log(`‚úÖ [${stepIndex}] NextButtonSave: target element available after ${Date.now() - startWait}ms`);
              window.__NEXT_BUTTON_SAVE_PENDING__ = false;
              break;
            }
          } catch (e) {}
          elFound = null;
          await new Promise(function(r) { setTimeout(r, pollIntervalMs); });
        }
        if (!elFound || elFound.offsetParent === null) {
          window.__NEXT_BUTTON_SAVE_PENDING__ = false;
          if (canSkip === true) {
            console.log(`‚è≠Ô∏è [${stepIndex}] NextButtonSave: target not available after ${waitForElementMs}ms, skipping step (canSkip: true)`);
            return { success: true, skipped: true, reason: 'Element not available after NextButtonSave (canSkip)' };
          }
          console.error(`‚ùå [${stepIndex}] NextButtonSave: target not available after ${waitForElementMs}ms - pausing. Selector: ${selector}`);
          return { success: false, error: 'Element not available after NextButtonSave (textbox/button not found). Selector: ' + (selector || '') };
        }
      }
      
      // Trim valueKey to handle any trailing/leading whitespace
      const trimmedValueKey = valueKey ? String(valueKey).trim() : valueKey;
      
      // ROBUST CATEGORY FIELD DETECTION: Check if valueKey indicates this is a category field
      // If valueKey is mainCategoryBox/mainCategory, treat it as category selection regardless of selector
      const isCategoryField = trimmedValueKey && (
        trimmedValueKey === 'mainCategoryBox' ||
        trimmedValueKey === 'mainCategory' ||
        trimmedValueKey.toLowerCase() === 'maincategorybox' ||
        trimmedValueKey.toLowerCase() === 'maincategory' ||
        trimmedValueKey.toLowerCase().includes('category')
      );
      
      // Debug: Log if valueKey had whitespace that was trimmed
      if (valueKey && trimmedValueKey !== valueKey) {
        console.log(`üîç [${stepIndex}] valueKey had whitespace - trimmed "${valueKey}" to "${trimmedValueKey}"`);
      }
      
      // Evaluate logical expressions before executing the step
      if (logicalExpressions && Array.isArray(logicalExpressions) && logicalExpressions.length > 0) {
        const expressionResult = evaluateLogicalExpressions(logicalExpressions, flatData, stepIndex, step);
        if (expressionResult.shouldSkip) {
          console.log(`‚è≠Ô∏è [${stepIndex}] Step skipped due to logical expression: ${expressionResult.reason}`);
          return { success: true, skipped: true, reason: expressionResult.reason };
        }
        
        // Handle Insert Value operation
        if (expressionResult.insertValue) {
          const { valueKey: insertValueKey, value: insertValue, targetLabel: insertTargetLabel, operator: insertOperator, countValue: insertCountValue, countType: insertCountType } = expressionResult.insertValue;
          
          // IMPORTANT: Insert into the step's valueKey field, not valueKey1 from the logical expression
          // The logical expression evaluates valueKey1 to check the condition, but we insert into the step's valueKey
          const targetValueKey = trimmedValueKey || insertValueKey; // Use step's valueKey, fallback to valueKey1 if not available
          console.log(`üìù [${stepIndex}] Inserting value "${insertValue}" into step's valueKey field "${targetValueKey}" (logical expression evaluated valueKey1: "${insertValueKey}")`);
          
          // Find the field by the step's valueKey - try to find it using the step's selector first
          let targetField = null;
          
          // First, try to find it using the selector from the current step
          if (selector && trimmedValueKey) {
            targetField = document.querySelector(selector);
            if (targetField) {
              console.log(`‚úÖ [${stepIndex}] Found field using current step selector: ${selector} (for valueKey: ${targetValueKey})`);
            }
          }
          
          // If not found, try to find it by searching for fields with data attributes or name attributes using step's valueKey
          if (!targetField && targetValueKey) {
            // Try common patterns to find the field
            const possibleSelectors = [
              `[name="${targetValueKey}"]`,
              `[data-value-key="${targetValueKey}"]`,
              `[id="${targetValueKey}"]`,
              `input[name*="${targetValueKey}"]`,
              `textarea[name*="${targetValueKey}"]`,
              `[name*="${targetValueKey}"]`
            ];
            
            for (const sel of possibleSelectors) {
              try {
                targetField = document.querySelector(sel);
                if (targetField) {
                  console.log(`‚úÖ [${stepIndex}] Found field using selector: ${sel} (for valueKey: ${targetValueKey})`);
                  break;
                }
              } catch (e) {
                // Continue to next selector
              }
            }
          }
          
          // If still not found, search through all input/textarea elements for a match using step's valueKey
          if (!targetField && targetValueKey) {
            const allFields = document.querySelectorAll('input, textarea, [contenteditable="true"]');
            for (const field of allFields) {
              const fieldName = field.getAttribute('name') || field.getAttribute('id') || '';
              const fieldLabel = field.closest('label')?.textContent || '';
              
              // Check if field name or label matches the step's valueKey or targetLabel
              if (fieldName.toLowerCase().includes(targetValueKey.toLowerCase()) || 
                  (insertTargetLabel && fieldLabel.toLowerCase().includes(insertTargetLabel.toLowerCase()))) {
                targetField = field;
                console.log(`‚úÖ [${stepIndex}] Found field by searching: name="${fieldName}", label="${fieldLabel}" (for valueKey: ${targetValueKey})`);
                break;
              }
            }
          }
          
          if (targetField) {
            // Helper function to get current value from field
            const getCurrentValue = () => {
              if (targetField.tagName === 'INPUT' || targetField.tagName === 'TEXTAREA') {
                return targetField.value || '';
              } else if (targetField.isContentEditable || targetField.contentEditable === 'true') {
                return targetField.textContent || '';
              }
              return '';
            };
            
            // Helper function to set value in field
            const setFieldValue = (newValue) => {
              if (targetField.tagName === 'INPUT' || targetField.tagName === 'TEXTAREA') {
                targetField.value = newValue;
                targetField.dispatchEvent(new Event('input', { bubbles: true }));
                targetField.dispatchEvent(new Event('change', { bubbles: true }));
              } else if (targetField.isContentEditable || targetField.contentEditable === 'true') {
                targetField.textContent = newValue;
                targetField.dispatchEvent(new Event('input', { bubbles: true }));
              }
              
              // Update flatData with the new value using step's valueKey
              if (flatData && targetValueKey) {
                flatData[targetValueKey] = newValue;
              }
            };
            
            // Helper function to get character count
            const getCharacterCount = (value) => {
              return String(value || '').length;
            };
            
            // Check if we need to loop until condition is met
            if (insertOperator && insertCountValue !== undefined && insertCountValue !== null) {
              const countValueNum = Number(insertCountValue);
              let insertCount = 0;
              const maxIterations = 1000; // Safety limit to prevent infinite loops
              
              console.log(`üîÑ [${stepIndex}] Dynamic insert: Will repeat until condition is met (operator: ${insertOperator}, countValue: ${countValueNum})`);
              
              while (insertCount < maxIterations) {
                const currentValue = getCurrentValue();
                const currentCount = getCharacterCount(currentValue);
                let conditionMet = false;
                
                // Check condition based on operator
                if (insertOperator.toLowerCase() === 'lessthan' || insertOperator.toLowerCase() === 'less than') {
                  conditionMet = currentCount < countValueNum;
                  if (!conditionMet) {
                    console.log(`‚úÖ [${stepIndex}] Condition met: Character count ${currentCount} is now >= ${countValueNum}. Stopping insert.`);
                    break;
                  }
                } else if (insertOperator.toLowerCase() === 'greaterthan' || insertOperator.toLowerCase() === 'greater than') {
                  conditionMet = currentCount > countValueNum;
                  if (!conditionMet) {
                    console.log(`‚úÖ [${stepIndex}] Condition met: Character count ${currentCount} is now <= ${countValueNum}. Stopping insert.`);
                    break;
                  }
                } else {
                  // Unknown operator, insert once and break
                  console.warn(`‚ö†Ô∏è [${stepIndex}] Unknown operator "${insertOperator}" for dynamic insert. Inserting once.`);
                  const newValue = currentValue + insertValue;
                  setFieldValue(newValue);
                  console.log(`‚úÖ [${stepIndex}] Inserted value "${insertValue}" into field "${targetValueKey}". New value: "${newValue}"`);
                  break;
                }
                
                // Condition still met, insert value
                const newValue = currentValue + insertValue;
                setFieldValue(newValue);
                insertCount++;
                
                const newCount = getCharacterCount(newValue);
                console.log(`üìù [${stepIndex}] Insert ${insertCount}: Added "${insertValue}". Current count: ${currentCount} ‚Üí ${newCount} (target: ${countValueNum})`);
                
                // Small delay to allow DOM updates
                await new Promise(resolve => setTimeout(resolve, 10));
              }
              
              if (insertCount >= maxIterations) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Reached maximum iterations (${maxIterations}) for dynamic insert. Stopping to prevent infinite loop.`);
              } else {
                const finalValue = getCurrentValue();
                const finalCount = getCharacterCount(finalValue);
                console.log(`‚úÖ [${stepIndex}] Dynamic insert completed after ${insertCount} insertion(s). Final count: ${finalCount}`);
              }
            } else {
              // No operator/countValue specified, insert once (legacy behavior)
              const currentValue = getCurrentValue();
              const newValue = currentValue + insertValue;
              setFieldValue(newValue);
              console.log(`‚úÖ [${stepIndex}] Inserted value "${insertValue}" into field "${targetValueKey}". New value: "${newValue}"`);
            }
          } else {
            console.warn(`‚ö†Ô∏è [${stepIndex}] Could not find field for step's valueKey "${targetValueKey}" to insert value. The field may not be on the page yet or may use a different selector.`);
          }
        }
      }
      
      try {
        // Update progress indicator
        updateProgressIndicator(stepIndex, totalSteps, action, selector);
        
        // Handle actions that don't need selectors (or handle selectors differently)
        const actionsWithoutSelector = ['tickPaymentMethod', 'tickSubcategory', 'consolidateData', 'injectToFroala', 'initClearCheckbox', 'waitForPopup'];
        let el = null;
        
        if (!actionsWithoutSelector.includes(action) && selector) {
          // Handle parentSelectors (array) - NEW: supports multiple parent layers
          // Also supports backward compatibility with parentSelector (string)
          const parentSelectorsArray = parentSelectors && Array.isArray(parentSelectors) && parentSelectors.length > 0
            ? parentSelectors
            : (parentSelector ? [parentSelector] : null);
          
          if (parentSelectorsArray && parentSelectorsArray.length > 0) {
            console.log(`üîç [${stepIndex}] parentSelectors provided (${parentSelectorsArray.length} parent(s)): [${parentSelectorsArray.map((p, i) => `${i}:"${p}"`).join(', ')}] - searching for "${selector}" within each parent`);
            
            let foundElement = null;
            let foundParentIndex = -1;
            let foundParentSelector = null;
            
            // Iterate through each parent selector in the array (0 to max)
            for (let i = 0; i < parentSelectorsArray.length; i++) {
              const currentParentSelector = parentSelectorsArray[i];
              
              if (!currentParentSelector || typeof currentParentSelector !== 'string') {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Invalid parent selector at index ${i}, skipping...`);
                continue;
              }
              
              console.log(`üîç [${stepIndex}] Trying parent ${i + 1}/${parentSelectorsArray.length}: "${currentParentSelector}"`);
              
              try {
                // Wait for parent element to appear
                const parentEl = await waitFor(currentParentSelector, waitTimeout || 5000);
                
                if (!parentEl) {
                  console.warn(`‚ö†Ô∏è [${stepIndex}] Parent element ${i + 1} not found: "${currentParentSelector}" - trying next parent...`);
                  continue; // Try next parent in array
                }
                
                console.log(`‚úÖ [${stepIndex}] Parent element ${i + 1} found: "${currentParentSelector}"`);
                
                // Find selector within the current parent element
                const findInParent = () => {
                  return findElementInParent(selector, parentEl);
                };
                
                // Try to find immediately
                foundElement = findInParent();
                
                // If not found, wait with polling
                if (!foundElement) {
                  const startTime = performance.now();
                  const timeout = waitTimeout || 5000;
                  
                  while (performance.now() - startTime < timeout) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    foundElement = findInParent();
                    if (foundElement) {
                      break;
                    }
                  }
                }
                
                if (foundElement) {
                  foundParentIndex = i;
                  foundParentSelector = currentParentSelector;
                  console.log(`‚úÖ [${stepIndex}] Element found within parent ${i + 1}/${parentSelectorsArray.length}: "${currentParentSelector}" -> "${selector}"`);
                  break; // Success! Exit the loop
                } else {
                  console.log(`‚ö†Ô∏è [${stepIndex}] Element not found within parent ${i + 1}: "${currentParentSelector}" - trying next parent...`);
                  // Continue to next parent
                }
              } catch (error) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Error processing parent ${i + 1} "${currentParentSelector}": ${error.message} - trying next parent...`);
                continue; // Try next parent on error
              }
            }
            
            // Check if we found the element in any parent
            if (foundElement) {
              el = foundElement;
              console.log(`üéØ [${stepIndex}] Successfully found element using parent ${foundParentIndex + 1}/${parentSelectorsArray.length}: "${foundParentSelector}"`);
            } else {
              // Element not found in any parent
              console.warn(`‚ö†Ô∏è [${stepIndex}] Element not found in any of the ${parentSelectorsArray.length} parent(s): ${selector}`);
              if (canSkip === true) {
                console.log(`‚è≠Ô∏è [${stepIndex}] Skipping step (canSkip: true) - Element not found in any parent: ${selector}`);
                return { success: true, skipped: true };
              }
              return { success: false, error: `Element not found in any parent (tried ${parentSelectorsArray.length} parent(s)): ${selector}` };
            }
          } else {
            // Normal element finding without parentSelector/parentSelectors
            el = await waitFor(selector, waitTimeout || 5000);
          }
          
          // If element not found and it's a name field, try alternative selectors
          if (!el && selector.includes('name=') && trimmedValueKey && trimmedValueKey.includes('contactFirstNameBox')) {
            console.log(`üîÑ [${stepIndex}] Trying alternative selectors for name field...`);
            const alternatives = [
              '[name="name"]',
              '[name="firstName"]', 
              '[name="first_name"]',
              '[name="fname"]',
              'input[placeholder*="first" i]',
              'input[placeholder*="name" i]'
            ];
            
            for (const altSelector of alternatives) {
              console.log(`üîÑ [${stepIndex}] Trying alternative: ${altSelector}`);
              el = await waitFor(altSelector, 2000);
              if (el) {
                console.log(`‚úÖ [${stepIndex}] Found element with alternative selector: ${altSelector}`);
                break;
              }
            }
          }
          
          if (!el) {
            // If canSkip is true, skip the step gracefully when element is not found
            if (canSkip === true) {
              console.log(`‚è≠Ô∏è [${stepIndex}] Skipping step (canSkip: true) - Element not found: ${selector}`);
              return { success: true, skipped: true };
            }
            return { success: false, error: `Element not found: ${selector}` };
          }
        }

        // Execute the specific action
        switch (action) {
          case 'fill':
            if (el) {
              // Highlight element before filling
              highlightElement(el, stepIndex, 'Filling', '');
              
              // Special case: If valueKey is "toDeleteValue", clear the field and return
              if (trimmedValueKey === 'toDeleteValue') {
                console.log(`üóëÔ∏è [${stepIndex}] Special valueKey "toDeleteValue" detected - clearing field instead of filling`);
                
                try {
                  // Clear the field based on element type
                  if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                    el.value = '';
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                    el.dispatchEvent(new Event('blur', { bubbles: true }));
                  } else if (el.isContentEditable || el.contentEditable === 'true') {
                    el.textContent = '';
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                  } else if (el.tagName === 'SELECT') {
                    // For SELECT, set to first option or empty value
                    if (el.options.length > 0) {
                      el.selectedIndex = 0;
                    }
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                  }
                  
                  // Update flatData if valueKey exists in flatData
                  if (flatData && trimmedValueKey) {
                    flatData[trimmedValueKey] = '';
                    console.log(`üìù [${stepIndex}] Updated flatData["${trimmedValueKey}"] to empty string`);
                  }
                  
                  console.log(`‚úÖ [${stepIndex}] Successfully cleared field: ${selector}`);
                  highlightElement(el, stepIndex, 'Cleared', '');
                  return { success: true };
                } catch (error) {
                  console.error(`‚ùå [${stepIndex}] Error clearing field:`, error);
                  return { success: false, error: error.message };
                }
              }
              
              // Determine value source based on fillType
              let val = null;
              
              // Check fillType to determine which source to use
              if (fillType === 'valueKey') {
                // fillType = "valueKey": Use valueKey from flatData
                if (trimmedValueKey) {
                  val = flatData[trimmedValueKey] || '';
                  console.log(`üìã [${stepIndex}] fillType="valueKey" - Using valueKey "${trimmedValueKey}" = "${val}"`);
                } else {
                  console.warn(`‚ö†Ô∏è [${stepIndex}] fillType="valueKey" but no valueKey provided`);
                }
              } else if (fillType === 'userInput') {
                // fillType = "userInput": Use value directly (not valueKey)
                val = value || '';
                console.log(`üìã [${stepIndex}] fillType="userInput" - Using direct value = "${val}"`);
              } else {
                // No fillType specified or unknown fillType: Use legacy behavior (value first, then valueKey)
                val = value;
                console.log(`üìã [${stepIndex}] No fillType specified - Using legacy behavior (value first, then valueKey if empty)`);
              }
              
              // CRITICAL: If this is a category field and requiredCategory is true, override val from flatData
              // This ensures we use citations[domain].mainCategory instead of campaignData.mainCategoryBox
              if (isCategoryField && val) {
                const requiredCategory = await getRequiredCategoryFromAutomation(stepIndex);
                if (requiredCategory) {
                  console.log(`üîÑ [${stepIndex}] Category field detected with requiredCategory=true - overriding val from flatData`);
                  console.log(`   ‚Ä¢ Current val from flatData: "${val}"`);
                  console.log(`   ‚Ä¢ Will get mainCategory from citations instead`);
                  val = ''; // Clear val so citation lookup happens below
                }
              }
              
              // Check for blocked email domains even if value is provided directly
              if (val && step.blockedEmailDomains && Array.isArray(step.blockedEmailDomains) && step.blockedEmailDomains.length > 0) {
                // Check if this is an email field (campEmail or any email-related valueKey)
                const isEmailField = (valueKey && (
                  valueKey.toLowerCase().includes('email') || 
                  valueKey === 'campEmail' || 
                  valueKey === 'contactEmailBox'
                )) || (selector && (
                  selector.toLowerCase().includes('email') || 
                  selector.toLowerCase().includes('contact_email')
                ));
                
                if (isEmailField && typeof val === 'string' && val.includes('@')) {
                  // Extract domain from email
                  const emailDomain = val.split('@')[1]?.toLowerCase().trim();
                  
                  if (emailDomain) {
                    // Check if domain is in blocked list
                    const isBlocked = step.blockedEmailDomains.some(blockedDomain => {
                      const normalizedBlocked = blockedDomain.toLowerCase().trim();
                      return emailDomain === normalizedBlocked || emailDomain.endsWith('.' + normalizedBlocked);
                    });
                    
                    if (isBlocked) {
                      console.log(`üö´ [${stepIndex}] Email domain "${emailDomain}" is blocked in direct value. Using alternative email.`);
                      console.log(`   ‚Ä¢ Original email: "${val}"`);
                      console.log(`   ‚Ä¢ Blocked domains: ${step.blockedEmailDomains.join(', ')}`);
                      
                      // Try to get alternative email from campaignData
                      const alternativeEmail = flatData['campAlternativeEmail'] || flatData['campAlternativeEmailBox'] || '';
                      
                      if (alternativeEmail && alternativeEmail.trim() !== '') {
                        val = alternativeEmail.trim();
                        console.log(`‚úÖ [${stepIndex}] Using alternative email: "${val}"`);
                      } else {
                        console.warn(`‚ö†Ô∏è [${stepIndex}] Blocked email domain detected but no alternative email found (campAlternativeEmail)`);
                        console.warn(`   ‚Ä¢ Keeping original email: "${val}"`);
                      }
                    }
                  }
                }
              }
              
              // Only use valueKey fallback if fillType is not explicitly "userInput"
              // (If fillType is "valueKey", we already used it above)
              if (!val && trimmedValueKey && fillType !== 'userInput') {
                // Priority 1: Check for " + " separated valueKeys (combines with comma and space)
                // Example: "city + state" = "New York, New York"
                if (trimmedValueKey.includes(' + ')) {
                  const keys = trimmedValueKey.split(' + ').map(k => k.trim());
                  const altKeys = alternative && alternative.includes(' + ')
                    ? alternative.split(' + ').map(k => k.trim())
                    : [];
                  val = keys
                    .map((k, index) => {
                      const primary = flatData[k];
                      if (primary !== undefined && primary !== null && String(primary).trim() !== '') {
                        return String(primary).trim();
                      }
                      const altKey = altKeys[index];
                      if (altKey) {
                        const mappedKey = getAlternativeValueKey(altKey) || altKey;
                        const altVal = flatData[mappedKey];
                        if (altVal !== undefined && altVal !== null && String(altVal).trim() !== '') {
                          return String(altVal).trim();
                        }
                      }
                      return '';
                    })
                    .filter(v => v !== '')
                    .join(', ');
                  console.log(`üîß [${stepIndex}] Multiple valueKey: ${trimmedValueKey} = "${val}"`);
                  
                  // Check for blocked email domains in multiple valueKeys (check first email found)
                  if (val && step.blockedEmailDomains && Array.isArray(step.blockedEmailDomains) && step.blockedEmailDomains.length > 0) {
                    // Check if any of the keys is an email field
                    const hasEmailKey = keys.some(key => 
                      key.toLowerCase().includes('email') || 
                      key === 'campEmail' || 
                      key === 'contactEmailBox'
                    );
                    
                    if (hasEmailKey && typeof val === 'string' && val.includes('@')) {
                      // Extract domain from email (handle comma-separated values)
                      const emailPart = val.split(',')[0].trim(); // Get first email if multiple
                      const emailDomain = emailPart.split('@')[1]?.toLowerCase().trim();
                      
                      if (emailDomain) {
                        const isBlocked = step.blockedEmailDomains.some(blockedDomain => {
                          const normalizedBlocked = blockedDomain.toLowerCase().trim();
                          return emailDomain === normalizedBlocked || emailDomain.endsWith('.' + normalizedBlocked);
                        });
                        
                        if (isBlocked) {
                          console.log(`üö´ [${stepIndex}] Email domain "${emailDomain}" is blocked in multiple valueKeys. Using alternative email.`);
                          const alternativeEmail = flatData['campAlternativeEmail'] || flatData['campAlternativeEmailBox'] || '';
                          if (alternativeEmail && alternativeEmail.trim() !== '') {
                            // Replace the email part with alternative
                            const otherParts = keys.filter(k => 
                              !k.toLowerCase().includes('email') && 
                              k !== 'campEmail' && 
                              k !== 'contactEmailBox'
                            )
                              .map(k => flatData[k])
                              .filter(v => v !== undefined && v !== null && String(v).trim() !== '')
                              .map(v => String(v).trim());
                            val = [alternativeEmail.trim(), ...otherParts].filter(v => v).join(', ');
                            console.log(`‚úÖ [${stepIndex}] Using alternative email in combined value: "${val}"`);
                          }
                        }
                      }
                    }
                  }
                }
                // Priority 2: Check for space-separated valueKeys (combines with space separator)
                // Example: "firstname lastname" = "Business Manager"
                if (!val) {
                  const spaceKeys = trimmedValueKey.trim().split(/\s+/).map(k => k.trim()).filter(k => k);
                  const altKeys = alternative && !alternative.includes('+')
                    ? String(alternative).trim().split(/\s+/).map(k => k.trim()).filter(k => k)
                    : [];
                  const spaceValues = spaceKeys
                    .map((k, index) => {
                      const primary = flatData[k];
                      if (primary !== undefined && primary !== null && String(primary).trim() !== '') {
                        return String(primary).trim();
                      }
                      const altKey = altKeys[index];
                      if (altKey) {
                        const mappedKey = getAlternativeValueKey(altKey) || altKey;
                        const altVal = flatData[mappedKey];
                        if (altVal !== undefined && altVal !== null && String(altVal).trim() !== '') {
                          return String(altVal).trim();
                        }
                      }
                      return '';
                    })
                    .filter(v => v !== '');
                  if (spaceValues.length > 0) {
                    val = spaceValues.join(' ');
                    console.log(`üîß [${stepIndex}] Space-separated valueKey (with space): ${trimmedValueKey} = "${val}"`);
                  }
                }
                // Priority 3: Check for plus-separated valueKeys without spaces (combines without separator)
                // Example: "TelephonePrefix+TelephoneLine" = "1234567"
                if (!val) {
                  const plusKeys = trimmedValueKey.split('+').map(k => k.trim()).filter(k => k);
                  const altKeys = alternative && !alternative.includes(' + ') && String(alternative).includes('+')
                    ? String(alternative).split('+').map(k => k.trim()).filter(k => k)
                    : [];
                  const plusValues = plusKeys
                    .map((k, index) => {
                      const primary = flatData[k];
                      if (primary !== undefined && primary !== null && String(primary).trim() !== '') {
                        return String(primary).trim();
                      }
                      const altKey = altKeys[index];
                      if (altKey) {
                        const mappedKey = getAlternativeValueKey(altKey) || altKey;
                        const altVal = flatData[mappedKey];
                        if (altVal !== undefined && altVal !== null && String(altVal).trim() !== '') {
                          return String(altVal).trim();
                        }
                      }
                      return '';
                    })
                    .filter(v => v !== '');
                  if (plusValues.length > 0) {
                    val = plusValues.join('');
                    console.log(`üîß [${stepIndex}] Plus-separated valueKey (no separator): ${trimmedValueKey} = "${val}"`);
                  }
                }
                
                  // If still no value, check for single valueKey or category handling
                // Also check category fields if requiredCategory is true (to override with citation data)
                if (!val || isCategoryField) {
                  // ROBUST CATEGORY HANDLING: If valueKey indicates category field, handle it appropriately
                  // This works for any selector - detection is based on valueKey, not selector
                  if (isCategoryField) {
                    // Get requiredCategory setting from automationTasks/automationSteps based on user role
                    const requiredCategory = await getRequiredCategoryFromAutomation(stepIndex);
                    
                    // Determine behavior based on requiredCategory setting
                    // If requiredCategory = true: use citations[domain].mainCategory
                    // If requiredCategory = false: use campaignData.mainCategoryBox
                    
                    // Only process category handling if requiredCategory is true OR if val is not set
                    if (requiredCategory || !val) {
                      if (requiredCategory) {
                      // REQUIRED CATEGORY = TRUE: Use citations[domain].mainCategory
                      // IMPORTANT: Never use mainCategoryBox when requiredCategory = true
                      console.log(`üìã [${stepIndex}] requiredCategory = true - getting mainCategory from citations[domain].mainCategory (valueKey: ${trimmedValueKey})`);
                      console.log(`üìã [${stepIndex}] IMPORTANT: Will NOT use mainCategoryBox when requiredCategory = true`);
                      
                      // CRITICAL: Clear val first to prevent persistence of mainCategoryBox from flatData
                      console.log(`üßπ [${stepIndex}] requiredCategory = true - clearing val first to prevent mainCategoryBox persistence`);
                      val = ''; // Clear any existing value that might be from mainCategoryBox
                      
                      // Get CampaignData
                      const { CampaignData = {} } = await chrome.storage.local.get(["CampaignData"]);
                      const nestedCampaign = Object.values(CampaignData)[0];
                      const currentDomain = extractBaseDomain(window.location.hostname);
                      
                      // Try multiple paths to find citations
                      let citations = null;
                      
                      // Path 1: nestedCampaign.campaignData.citations
                      if (nestedCampaign?.campaignData?.citations && Array.isArray(nestedCampaign.campaignData.citations)) {
                        citations = nestedCampaign.campaignData.citations;
                        console.log(`üìã [${stepIndex}] Found citations at: nestedCampaign.campaignData.citations`);
                      }
                      // Path 2: nestedCampaign.citations
                      else if (nestedCampaign?.citations && Array.isArray(nestedCampaign.citations)) {
                        citations = nestedCampaign.citations;
                        console.log(`üìã [${stepIndex}] Found citations at: nestedCampaign.citations`);
                      }
                      // Path 3: CampaignData.citations (direct)
                      else if (CampaignData.citations && Array.isArray(CampaignData.citations)) {
                        citations = CampaignData.citations;
                        console.log(`üìã [${stepIndex}] Found citations at: CampaignData.citations`);
                      }
                      // Path 4: Check if CampaignData itself is an array of campaigns
                      else if (Array.isArray(CampaignData)) {
                        for (const campaign of CampaignData) {
                          if (campaign.citations && Array.isArray(campaign.citations)) {
                            citations = campaign.citations;
                            console.log(`üìã [${stepIndex}] Found citations in CampaignData array`);
                            break;
                          } else if (campaign.campaignData?.citations && Array.isArray(campaign.campaignData.citations)) {
                            citations = campaign.campaignData.citations;
                            console.log(`üìã [${stepIndex}] Found citations in CampaignData array (nested)`);
                            break;
                          }
                        }
                      }
                      
                      console.log(`üîç [${stepIndex}] Citation lookup debug (valueKey-based):`);
                      console.log(`   ‚Ä¢ Current domain: "${currentDomain}"`);
                      console.log(`   ‚Ä¢ Citations type: ${Array.isArray(citations) ? 'array' : typeof citations}`);
                      console.log(`   ‚Ä¢ Citations length: ${Array.isArray(citations) ? citations.length : 'N/A'}`);
                      
                      // Support both array and object-based citations structures
                      if (Array.isArray(citations)) {
                        // Array structure: citations is an array of citation objects
                        // Log all citation sites for debugging
                        const citationSites = citations.map(c => c.site).filter(Boolean);
                        console.log(`   ‚Ä¢ Available citation sites: ${citationSites.join(', ')}`);
                        
                        // Find citation matching current domain (try multiple matching strategies)
                        let matchingCitation = citations.find(citation => {
                          if (!citation.site) return false;
                          const citationSite = extractBaseDomain(citation.site);
                          return citationSite === currentDomain.toLowerCase();
                        });
                        
                        // If not found, try without www prefix removal
                        if (!matchingCitation) {
                          matchingCitation = citations.find(citation => {
                            if (!citation.site) return false;
                            return citation.site.toLowerCase() === currentDomain.toLowerCase() || 
                                   citation.site.toLowerCase() === `www.${currentDomain}`.toLowerCase();
                          });
                        }
                        
                        if (matchingCitation) {
                          val = matchingCitation.mainCategory || matchingCitation.maincategory || '';
                          console.log(`‚úÖ [${stepIndex}] Found matching citation for ${currentDomain}`);
                          console.log(`   ‚Ä¢ Citation site: "${matchingCitation.site}"`);
                          console.log(`   ‚Ä¢ Citation mainCategory: "${matchingCitation.mainCategory || matchingCitation.maincategory || 'N/A'}"`);
                          console.log(`   ‚Ä¢ Main category from citation: "${val}"`);
                        } else {
                          console.warn(`‚ö†Ô∏è [${stepIndex}] No citation found for domain: ${currentDomain}`);
                          console.warn(`   ‚Ä¢ Available sites: ${citationSites.join(', ')}`);
                          console.warn(`   ‚Ä¢ Field will be left empty (no fallback to mainCategoryBox when requiredCategory = true)`);
                          console.warn(`   ‚Ä¢ Previous mainCategoryBox value will be cleared to prevent persistence`);
                          val = ''; // Explicitly set to empty - do NOT use mainCategoryBox
                        }
                      } else if (citations && typeof citations === 'object' && !Array.isArray(citations)) {
                        // Object structure: citations is an object with site names as keys (e.g., CampaignData.citations[site])
                        // Try direct access by currentDomain
                        const citationBySite = citations[currentDomain] || citations[`www.${currentDomain}`];
                        
                        if (citationBySite) {
                          val = citationBySite.mainCategory || citationBySite.maincategory || '';
                          console.log(`‚úÖ [${stepIndex}] Found mainCategory from object citations[${currentDomain}]: "${val}"`);
                        } else {
                          // Try to find by matching site key (case-insensitive)
                          const siteKey = Object.keys(citations).find(key => {
                            const keyDomain = extractBaseDomain(key);
                            return keyDomain === currentDomain.toLowerCase() || 
                                   key.toLowerCase() === currentDomain.toLowerCase() ||
                                   key.toLowerCase() === `www.${currentDomain}`.toLowerCase();
                          });
                          
                          if (siteKey && citations[siteKey]) {
                            val = citations[siteKey].mainCategory || citations[siteKey].maincategory || '';
                            console.log(`‚úÖ [${stepIndex}] Found mainCategory from object citations["${siteKey}"]: "${val}"`);
                          } else {
                            // Fallback: if citations object itself has mainCategory (single citation object)
                            val = citations.mainCategory || citations.maincategory || '';
                            if (val) {
                              console.log(`‚úÖ [${stepIndex}] Found mainCategory from object citations (single citation): "${val}"`);
                            } else {
                              console.warn(`‚ö†Ô∏è [${stepIndex}] No citation found for domain: ${currentDomain} in object structure`);
                              console.warn(`   ‚Ä¢ Available site keys: ${Object.keys(citations).join(', ')}`);
                              console.warn(`   ‚Ä¢ Field will be left empty (no fallback to mainCategoryBox when requiredCategory = true)`);
                              console.warn(`   ‚Ä¢ Previous mainCategoryBox value will be cleared to prevent persistence`);
                              val = ''; // Explicitly set to empty - do NOT use mainCategoryBox
                            }
                          }
                        }
                      } else {
                        console.warn(`‚ö†Ô∏è [${stepIndex}] No citations data found or invalid format`);
                        console.warn(`   ‚Ä¢ Citations value:`, citations);
                        console.warn(`   ‚Ä¢ nestedCampaign:`, nestedCampaign);
                        console.warn(`   ‚Ä¢ CampaignData structure:`, Object.keys(CampaignData));
                        console.warn(`   ‚Ä¢ Field will be left empty (no fallback to mainCategoryBox when requiredCategory = true)`);
                        console.warn(`   ‚Ä¢ Previous mainCategoryBox value will be cleared to prevent persistence`);
                        val = ''; // Explicitly set to empty - do NOT use mainCategoryBox
                      }
                      
                      // Trim and validate
                      if (val && typeof val === 'string') {
                        val = val.trim();
                        if (val.length === 0) {
                          val = '';
                          console.warn(`‚ö†Ô∏è [${stepIndex}] Main category is empty after trimming`);
                        }
                      }
                      
                      // CRITICAL: Ensure we never use mainCategoryBox from flatData when requiredCategory = true
                      // Double-check that val is not from mainCategoryBox
                      if (val && (val === flatData['mainCategoryBox'] || val === flatData['mainCategory'])) {
                        console.warn(`‚ö†Ô∏è [${stepIndex}] DETECTED mainCategoryBox value in val - clearing to prevent persistence`);
                        console.warn(`   ‚Ä¢ This should not happen when requiredCategory = true`);
                        val = ''; // Clear it - we should only use citation data
                      }
                      } else {
                        // requiredCategory = false but val is not set - use campaignData.mainCategoryBox
                        console.log(`üìã [${stepIndex}] requiredCategory = false and val not set - filling from campaignData.mainCategoryBox (valueKey: ${trimmedValueKey})`);
                        val = flatData[trimmedValueKey] || '';
                      }
                    } else {
                      // requiredCategory = false and val is already set - keep existing val
                      console.log(`üìã [${stepIndex}] requiredCategory = false and val already set - keeping existing value: "${val}"`);
                    }
                  } else {
                    // Not a mainCategory field, use normal flatData lookup
                    val = flatData[trimmedValueKey] || '';
                    if (!val && trimmedValueKey) {
                      console.log(`üîç [${stepIndex}] Value not found for valueKey "${trimmedValueKey}" in flatData`);
                      // Check if it exists with different casing
                      const lowerKey = trimmedValueKey.toLowerCase();
                      const matchingKey = Object.keys(flatData).find(k => k.toLowerCase() === lowerKey);
                      if (matchingKey) {
                        console.log(`üîç [${stepIndex}] Found key with different casing: "${matchingKey}" = "${flatData[matchingKey]}"`);
                        val = flatData[matchingKey];
                      }
                    }
                  }
                  
                  // Check for blocked email domains
                  if (val && step.blockedEmailDomains && Array.isArray(step.blockedEmailDomains) && step.blockedEmailDomains.length > 0) {
                    // Check if this is an email field (campEmail or any email-related valueKey)
                    const isEmailField = trimmedValueKey && (
                      trimmedValueKey.toLowerCase().includes('email') || 
                      trimmedValueKey === 'campEmail' || 
                      trimmedValueKey === 'contactEmailBox'
                    );
                    
                    if (isEmailField && typeof val === 'string' && val.includes('@')) {
                      // Extract domain from email
                      const emailDomain = val.split('@')[1]?.toLowerCase().trim();
                      
                      if (emailDomain) {
                        // Check if domain is in blocked list
                        const isBlocked = step.blockedEmailDomains.some(blockedDomain => {
                          const normalizedBlocked = blockedDomain.toLowerCase().trim();
                          return emailDomain === normalizedBlocked || emailDomain.endsWith('.' + normalizedBlocked);
                        });
                        
                        if (isBlocked) {
                          console.log(`üö´ [${stepIndex}] Email domain "${emailDomain}" is blocked. Using alternative email.`);
                          console.log(`   ‚Ä¢ Original email: "${val}"`);
                          console.log(`   ‚Ä¢ Blocked domains: ${step.blockedEmailDomains.join(', ')}`);
                          
                          // Try to get alternative email from campaignData
                          const alternativeEmail = flatData['campAlternativeEmail'] || flatData['campAlternativeEmailBox'] || '';
                          
                          if (alternativeEmail && alternativeEmail.trim() !== '') {
                            val = alternativeEmail.trim();
                            console.log(`‚úÖ [${stepIndex}] Using alternative email: "${val}"`);
                          } else {
                            console.warn(`‚ö†Ô∏è [${stepIndex}] Blocked email domain detected but no alternative email found (campAlternativeEmail)`);
                            console.warn(`   ‚Ä¢ Keeping original email: "${val}"`);
                          }
                        } else {
                          console.log(`‚úÖ [${stepIndex}] Email domain "${emailDomain}" is not blocked. Using original email.`);
                        }
                      }
                    }
                  }
                }
              }
              
              // Apply address mode handling if mode is "address"
              if (mode === 'address' && trimmedValueKey) {
                // Get CampaignData to check addressMode
                const { CampaignData = {} } = await chrome.storage.local.get(["CampaignData"]);
                let nestedCampaign = null;
                
                // Handle nested structure
                if (Object.keys(CampaignData).length > 0) {
                  if (CampaignData.campaignData) {
                    nestedCampaign = CampaignData;
                  } else {
                    nestedCampaign = Object.values(CampaignData)[0];
                    if (!nestedCampaign?.campaignData) {
                      nestedCampaign = { campaignData: CampaignData };
                    }
                  }
                }
                
                // Get addressMode from CampaignData.campaignData.addressMode
                const addressMode = nestedCampaign?.campaignData?.addressMode || 
                                   CampaignData?.campaignData?.addressMode || 
                                   null;
                
                console.log(`üè† [${stepIndex}] Address mode detected - valueKey: "${trimmedValueKey}", addressMode: "${addressMode}"`);
                
                // Check if this is an address-related field
                const isAddressField = ['line1', 'line2', 'city', 'state', 'zipcode'].includes(trimmedValueKey.toLowerCase());
                
                if (isAddressField && addressMode) {
                  const normalizedAddressMode = String(addressMode).toLowerCase().trim();
                  const normalizedValueKey = trimmedValueKey.toLowerCase();
                  
                  if (normalizedAddressMode === 'show') {
                    // show = meaning the address will fill in all field without changes
                    console.log(`‚úÖ [${stepIndex}] Address mode: "show" - filling ${normalizedValueKey} with original value: "${val}"`);
                    // No changes needed, use value as-is
                  } else if (normalizedAddressMode === 'full') {
                    // full = meaning full address should be hide or skip during fill in process
                    console.log(`‚è≠Ô∏è [${stepIndex}] Address mode: "full" - skipping ${normalizedValueKey} (full address hidden)`);
                    val = ''; // Clear the value to skip filling
                  } else if (normalizedAddressMode === 'hide') {
                    // hide = meaning line1 and line2 will be skipped.
                    // City, State, and Zipcode will be fill in normally.
                    // Fallback for line1 will be handled by existing fallback mechanism (alternative key or direct value).
                    if (normalizedValueKey === 'line1') {
                      // line1 will be skipped - fallback will be handled by existing fallback mechanism
                      val = '';
                      console.log(`‚è≠Ô∏è [${stepIndex}] Address mode: "hide" - skipping line1 (fallback will be handled by existing fallback mechanism)`);
                    } else if (normalizedValueKey === 'line2') {
                      // line2 will be skipped
                      val = '';
                      console.log(`‚è≠Ô∏è [${stepIndex}] Address mode: "hide" - skipping line2`);
                    } else if (['city', 'state', 'zipcode'].includes(normalizedValueKey)) {
                      // City, State, and Zipcode will be filled in normally
                      console.log(`‚úÖ [${stepIndex}] Address mode: "hide" - filling ${normalizedValueKey} normally: "${val}"`);
                      // Use value as-is
                    }
                  } else {
                    console.log(`‚ö†Ô∏è [${stepIndex}] Unknown addressMode: "${addressMode}" - using default behavior`);
                  }
                } else if (isAddressField && !addressMode) {
                  console.log(`‚ÑπÔ∏è [${stepIndex}] Address field detected but no addressMode found - using default behavior`);
                }
              }
              
              // Transpose servicesBox when transpose: true (comma-separated -> one per line; prefer service1Box..service5Box)
              if (transpose === true && trimmedValueKey === 'servicesBox' && flatData) {
                val = transposeServicesBoxValue(flatData, val, stepIndex);
              }
              
              // Apply phone formatting if phoneFormat is specified and valueKey is a phone field
              if (val && phoneFormat && isPhoneField(trimmedValueKey)) {
                const originalVal = val;
                val = formatPhoneNumber(val, phoneFormat);
                if (val !== originalVal) {
                  console.log(`üìû [${stepIndex}] Phone number formatted: "${originalVal}" -> "${val}" (format: ${phoneFormat})`);
                } else {
                  console.log(`üìû [${stepIndex}] Phone formatting applied (format: ${phoneFormat}), value unchanged: "${val}"`);
                }
              } else if (phoneFormat && !isPhoneField(trimmedValueKey)) {
                console.log(`‚ÑπÔ∏è [${stepIndex}] phoneFormat specified (${phoneFormat}) but valueKey "${trimmedValueKey}" is not a phone field - skipping formatting`);
              }
              
              // Apply hours formatting if hoursFormat is specified and valueKey is a hours field
              if (hoursFormat && isHoursField(trimmedValueKey)) {
                const originalVal = val || '';
                const formatLower = hoursFormat.toLowerCase().trim();
                
                // For businessHoursBox, check if format is "default" - use raw value without formatting
                if (trimmedValueKey === 'businessHoursBox') {
                  if (formatLower === 'default') {
                    // Use the raw value from businessHoursBox without formatting
                    console.log(`üïí [${stepIndex}] Business hours format is "default" - using raw value from businessHoursBox: "${val}"`);
                    // val already contains the raw value from flatData, no need to change it
                  } else {
                    // Format business hours from flatData based on the specified format
                    val = formatHours(null, hoursFormat, trimmedValueKey);
                    console.log(`üïí [${stepIndex}] Business hours formatted from flatData (format: ${hoursFormat})`);
                    console.log(`üïí [${stepIndex}] Formatted hours: "${val}"`);
                  }
                } else if (val) {
                  // For individual hour fields (monAm, friPm, etc.), format the single time value
                  val = formatHours(val, hoursFormat, trimmedValueKey);
                  if (val !== originalVal) {
                    console.log(`üïí [${stepIndex}] Hours formatted: "${originalVal}" -> "${val}" (format: ${hoursFormat})`);
                  } else {
                    console.log(`üïí [${stepIndex}] Hours formatting applied (format: ${hoursFormat}), value unchanged: "${val}"`);
                  }
                }
              } else if (hoursFormat && !isHoursField(trimmedValueKey)) {
                console.log(`‚ÑπÔ∏è [${stepIndex}] hoursFormat specified (${hoursFormat}) but valueKey "${trimmedValueKey}" is not a hours field - skipping formatting`);
              }
              
              // Apply link formatting if linkFormat is specified and valueKey is a website field
              if (val && linkFormat && isWebsiteField(trimmedValueKey)) {
                const originalVal = val;
                val = formatLinkValue(val, linkFormat);
                if (val !== originalVal) {
                  console.log(`üîó [${stepIndex}] Link formatted: "${originalVal}" -> "${val}" (format: ${linkFormat})`);
                } else {
                  console.log(`üîó [${stepIndex}] Link formatting applied (format: ${linkFormat}), value unchanged: "${val}"`);
                }
              } else if (linkFormat && !isWebsiteField(trimmedValueKey)) {
                console.log(`‚ÑπÔ∏è [${stepIndex}] linkFormat specified (${linkFormat}) but valueKey "${trimmedValueKey}" is not a website field - skipping formatting`);
              }
              
              // Apply sanitization if sanitization is true
              if (sanitization && val) {
                const originalVal = val;
                val = sanitizeValue(val);
                if (val !== originalVal) {
                  console.log(`üßπ [${stepIndex}] Value sanitized: "${originalVal}" -> "${val}"`);
                } else {
                  console.log(`üßπ [${stepIndex}] Sanitization applied, value unchanged: "${val}"`);
                }
              }
              
              // REFACTORED: Check for fallbacks if main value is not found
              // Also check fallbacks when mode is "required" (even if step is optional)
              const isEmptyOrWhitespace = !val || (typeof val === 'string' && val.trim().length === 0);
              // Check fallback if: (value is empty AND valueKey exists) OR (mode is required AND value is empty AND fallback is configured)
              const shouldCheckFallback = (isEmptyOrWhitespace && trimmedValueKey) || 
                                         (mode === 'required' && isEmptyOrWhitespace && (fallbackType || alternative || directValue !== undefined));
              
              if (shouldCheckFallback) {
                // Check fallbackType to determine where to get the fallback value
                const normalizedFallbackType = fallbackType ? String(fallbackType).toLowerCase().trim() : null;
                
                if (normalizedFallbackType === 'directvalue') {
                  // FALLBACK TYPE: directvalue - Use directValue as literal value
                  if (directValue !== undefined && directValue !== null) {
                    val = String(directValue);
                    // Don't trim directValue - it might be "&nbsp;" or other HTML entities
                    console.log(`üîÑ [${stepIndex}] Using directValue fallback (fallbackType: "directvalue"): "${val}" (length: ${val.length})`);
                  } else {
                    console.warn(`‚ö†Ô∏è [${stepIndex}] fallbackType is "directvalue" but directValue is not provided`);
                  }
                } else {
                  // FALLBACK TYPE: alternativekey (default) - Use alternative as key lookup
                  // First, try the hardcoded alternative mappings
                  const alternativeKey = getAlternativeKey(trimmedValueKey);
                  if (alternativeKey) {
                    val = flatData[alternativeKey] || '';
                    if (val) {
                      console.log(`üîÑ [${stepIndex}] Using hardcoded alternative value: ${alternativeKey} = "${val}"`);
                    } else {
                      console.log(`‚ö†Ô∏è [${stepIndex}] Hardcoded alternative key "${alternativeKey}" not found in CampaignData`);
                    }
                  }
                  
                  // If still no value and step has an alternative field, try that
                  if (!val && alternative) {
                    const mapAlternativeKey = (rawKey) => {
                      const trimmedKey = String(rawKey || '').trim();
                      const mappedKey = getAlternativeValueKey(trimmedKey);
                      return mappedKey ? (flatData[mappedKey]) : (flatData[trimmedKey]);
                    };
                    
                    const normalizeAltValues = (values) => values
                      .filter(v => v !== undefined && v !== null && String(v).trim() !== '')
                      .map(v => String(v).trim());
                    
                    if (alternative.includes(' + ')) {
                      // Priority 1: " + " separated alternative keys (comma + space)
                      const altKeys = alternative.split(' + ').map(k => k.trim());
                      const altValues = normalizeAltValues(altKeys.map(mapAlternativeKey));
                      
                      if (altValues.length > 0) {
                        val = altValues.join(', ');
                        console.log(`üîÑ [${stepIndex}] Using multiple alternative values (fallbackType: "alternativekey"): ${alternative} = "${val}"`);
                      } else {
                        console.log(`‚ö†Ô∏è [${stepIndex}] Multiple alternative "${alternative}" not found in CampaignData`);
                      }
                    } else {
                      // Priority 2: space-separated alternative keys (space separator)
                      const spaceKeys = String(alternative).trim().split(/\s+/).filter(k => k);
                      const isSpaceSeparated = spaceKeys.length > 1 && !alternative.includes('+');
                      if (isSpaceSeparated) {
                        const spaceValues = normalizeAltValues(spaceKeys.map(mapAlternativeKey));
                        if (spaceValues.length > 0) {
                          val = spaceValues.join(' ');
                          console.log(`üîÑ [${stepIndex}] Using space-separated alternative values: ${alternative} = "${val}"`);
                        }
                      }
                      
                      // Priority 3: plus-separated alternative keys without spaces (no separator)
                      if (!val && String(alternative).includes('+')) {
                        const plusKeys = String(alternative).split('+').map(k => k.trim()).filter(k => k);
                        if (plusKeys.length > 1) {
                          const plusValues = normalizeAltValues(plusKeys.map(mapAlternativeKey));
                          if (plusValues.length > 0) {
                            val = plusValues.join('');
                            console.log(`üîÑ [${stepIndex}] Using plus-separated alternative values: ${alternative} = "${val}"`);
                          }
                        }
                      }
                      
                      if (!val) {
                        // Single alternative key handling
                        const alternativeValueKey = getAlternativeValueKey(alternative);
                        if (alternativeValueKey) {
                          val = flatData[alternativeValueKey] || '';
                          if (val) {
                            console.log(`üîÑ [${stepIndex}] Using step alternative value (fallbackType: "alternativekey"): ${alternative} -> ${alternativeValueKey} = "${val}"`);
                          } else {
                            console.log(`‚ö†Ô∏è [${stepIndex}] Step alternative "${alternative}" (${alternativeValueKey}) not found in CampaignData`);
                          }
                        } else {
                          // If mapping fails, try using the alternative directly as a valueKey
                          val = flatData[alternative] || '';
                          if (val) {
                            console.log(`üîÑ [${stepIndex}] Using alternative as direct valueKey (fallbackType: "alternativekey"): ${alternative} = "${val}"`);
                          } else {
                            console.log(`‚ö†Ô∏è [${stepIndex}] Alternative "${alternative}" not found in CampaignData`);
                          }
                        }
                      }
                    }
                  }
                }
                  
                // If still no value, log that no fallbacks were found
                if (!val) {
                  if (normalizedFallbackType === 'directvalue') {
                    console.log(`‚ö†Ô∏è [${stepIndex}] No directValue provided for fallback`);
                  } else {
                    console.log(`‚ö†Ô∏è [${stepIndex}] No alternative values found for valueKey: ${trimmedValueKey}`);
                  }
                }
              }
              
              // CUSTOM: Handle consolidated data injection for textareas
              if (trimmedValueKey === "consolidatedData") {
                console.log(`üîç [${stepIndex}] Injecting consolidated data into textarea: ${selector}`);
                
                try {
                  // Detect if textarea supports HTML (check for rich text editors)
                  // Check for TinyMCE: id="tinymce" or class="mceContentBody"
                  // Also check if element is inside a TinyMCE iframe
                  const isTinyMCE = el.id === 'tinymce' || 
                                   el.classList.contains('mceContentBody') ||
                                   (el.tagName === 'BODY' && (el.id === 'tinymce' || el.classList.contains('mceContentBody'))) ||
                                   (el.ownerDocument !== document && el.ownerDocument?.body?.id === 'tinymce') ||
                                   (el.ownerDocument !== document && el.ownerDocument?.body?.classList.contains('mceContentBody'));
                  
                  const isRichTextEditor = el.hasAttribute('contenteditable') || 
                                         el.classList.contains('froala-editor') ||
                                         el.classList.contains('ckeditor') ||
                                         el.classList.contains('tinymce') ||
                                         el.closest('.froala-editor') ||
                                         el.closest('.ckeditor') ||
                                         el.closest('.tinymce') ||
                                         isTinyMCE ||
                                         el.getAttribute('data-rich-text') === 'true';
                  
                  console.log(`üîç [${stepIndex}] Textarea HTML support detected: ${isRichTextEditor}`);
                  console.log(`üîç [${stepIndex}] TinyMCE detected: ${isTinyMCE}`);
                  
                  // Generate consolidated data with appropriate formatting
                  const consolidatedContent = await generateConsolidatedContentForTextarea(isRichTextEditor);
                  
                  if (consolidatedContent && consolidatedContent.trim() !== "") {
                    // Add delay before filling
                    const fillDelay = step.delay || 1000;
                    console.log(`‚è≥ [${stepIndex}] Waiting ${fillDelay}ms before injecting consolidated data...`);
                    await new Promise(resolve => setTimeout(resolve, fillDelay));
                    
                    // Focus the element first
                    el.focus();
                    
                    // Handle TinyMCE specifically
                    if (isTinyMCE) {
                      console.log(`üîß [${stepIndex}] Injecting into TinyMCE editor...`);
                      
                      // Get the actual TinyMCE body element (might be in iframe)
                      let tinyMCEBody = el;
                      if (el.tagName !== 'BODY' || (el.id !== 'tinymce' && !el.classList.contains('mceContentBody'))) {
                        // Try to find the body element in the iframe
                        const iframe = el.ownerDocument?.defaultView?.frameElement || 
                                     el.closest('iframe') ||
                                     document.querySelector('iframe[id*="tinymce"], iframe[class*="tinymce"]');
                        if (iframe && iframe.contentDocument) {
                          tinyMCEBody = iframe.contentDocument.body;
                          console.log(`üîç [${stepIndex}] Found TinyMCE body in iframe`);
                        }
                      }
                      
                      // Try to use TinyMCE API if available
                      let injected = false;
                      if (typeof tinymce !== 'undefined' && tinymce.editors && tinymce.editors.length > 0) {
                        try {
                          // Try to find the editor instance by various methods
                          let editor = null;
                          
                          // Method 1: Try to get by element
                          if (tinyMCEBody) {
                            for (let i = 0; i < tinymce.editors.length; i++) {
                              const ed = tinymce.editors[i];
                              if (ed.getBody && ed.getBody() === tinyMCEBody) {
                                editor = ed;
                                break;
                              }
                            }
                          }
                          
                          // Method 2: Try by ID
                          if (!editor) {
                            const editorId = tinyMCEBody.id || el.id || el.getAttribute('data-id') || el.closest('iframe')?.id;
                            if (editorId) {
                              editor = tinymce.get(editorId);
                            }
                          }
                          
                          // Method 3: Get the first available editor
                          if (!editor && tinymce.editors.length > 0) {
                            editor = tinymce.editors[0];
                          }
                          
                          if (editor) {
                            console.log(`‚úÖ [${stepIndex}] Using TinyMCE API to set content`);
                            editor.setContent(consolidatedContent);
                            editor.save(); // Save the content
                            // Trigger change event
                            editor.fire('change');
                            injected = true;
                          }
                        } catch (e) {
                          console.warn(`‚ö†Ô∏è [${stepIndex}] TinyMCE API method failed:`, e);
                        }
                      }
                      
                      // Fallback: Direct injection into TinyMCE body element
                      if (!injected) {
                        console.log(`üîß [${stepIndex}] Using direct injection into TinyMCE body element`);
                        
                        // Use the correct body element
                        const targetBody = tinyMCEBody || el;
                        
                        // Clear first
                        targetBody.innerHTML = '';
                        // Set content
                        targetBody.innerHTML = consolidatedContent;
                        
                        // Trigger TinyMCE events if possible
                        if (targetBody.dispatchEvent) {
                          targetBody.dispatchEvent(new Event('input', { bubbles: true }));
                          targetBody.dispatchEvent(new Event('change', { bubbles: true }));
                          
                          // Try to trigger TinyMCE's setContent event
                          const setContentEvent = new CustomEvent('tinymce-set-content', { 
                            bubbles: true, 
                            detail: { content: consolidatedContent } 
                          });
                          targetBody.dispatchEvent(setContentEvent);
                        }
                        
                        // Also trigger on the main document if we're in an iframe
                        if (targetBody.ownerDocument !== document) {
                          const iframe = targetBody.ownerDocument?.defaultView?.frameElement;
                          if (iframe) {
                            iframe.dispatchEvent(new Event('input', { bubbles: true }));
                            iframe.dispatchEvent(new Event('change', { bubbles: true }));
                          }
                        }
                        
                        injected = true;
                      }
                    } else {
                      // Clear the textarea first for other editors
                      if (isRichTextEditor) {
                        el.innerHTML = '';
                      } else {
                        el.value = '';
                      }
                      el.dispatchEvent(new Event('input', { bubbles: true }));
                      el.dispatchEvent(new Event('change', { bubbles: true }));
                      
                      // Fill the textarea with consolidated content
                      if (isRichTextEditor) {
                        el.innerHTML = consolidatedContent;
                      } else {
                        el.value = consolidatedContent;
                      }
                    }
                    
                    // Dispatch events to trigger any listeners
                    el.dispatchEvent(new Event('focus', { bubbles: true }));
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                    el.dispatchEvent(new Event('blur', { bubbles: true }));
                    
                    // Small delay to ensure content is set
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    // Highlight the element
                    const previewText = isRichTextEditor ? 
                      consolidatedContent.replace(/<[^>]*>/g, '').substring(0, 50) + '...' :
                      consolidatedContent.substring(0, 50) + '...';
                    highlightElement(el, stepIndex, 'Consolidated Data Injected', previewText);
                    
                    console.log(`‚úÖ [${stepIndex}] Successfully injected consolidated data into textarea`);
                    console.log(`üìÑ [${stepIndex}] Content length: ${consolidatedContent.length} characters`);
                    console.log(`üìÑ [${stepIndex}] Content type: ${isRichTextEditor ? 'HTML' : 'Plain Text'}`);
                    console.log(`üìÑ [${stepIndex}] Content preview: ${previewText}`);
                    
                    return { success: true };
                  } else {
                    console.warn(`‚ö†Ô∏è [${stepIndex}] No consolidated content generated for textarea injection`);
                    return { success: false, error: 'No consolidated content available' };
                  }
                } catch (error) {
                  console.error(`‚ùå [${stepIndex}] Error injecting consolidated data into textarea:`, error);
                  return { success: false, error: error.message };
                }
              }

              // ROBUST CATEGORY HANDLING: Based on valueKey detection (not selector array)
              // If valueKey is mainCategoryBox/mainCategory, apply category selection logic
              // This works for any selector - no need to maintain a selector array
              // This check happens AFTER valueKey retrieval, so it will override any value from flatData
              if (isCategoryField && el.tagName === "SELECT") {
                console.log(`üìã [${stepIndex}] Category field detected (valueKey: ${trimmedValueKey}) - selector: ${selector}, required: ${required || false}`);
                console.log(`üìã [${stepIndex}] Category field detected - selector: ${selector}, required: ${required || false}`);
                // Get requiredCategory setting from automationTasks/automationSteps based on user role
                const currentDomain = extractBaseDomain(window.location.hostname);
                const requiredCategory = await getRequiredCategoryFromAutomation(stepIndex);
                
                console.log(`üîç [${stepIndex}] Main category lookup (refactored) - OVERRIDING value from selector: ${selector}`);
                console.log(`   ‚Ä¢ Current val (before override): "${val}"`);
                console.log(`   ‚Ä¢ requiredCategory setting: ${requiredCategory} (from automation controller)`);
                console.log(`   ‚Ä¢ Current domain: ${currentDomain}`);
                
                // CRITICAL: If requiredCategory = true, clear field first to prevent persistence of mainCategoryBox
                if (requiredCategory) {
                  console.log(`üßπ [${stepIndex}] requiredCategory = true - clearing field first to prevent mainCategoryBox persistence`);
                  el.value = "";
                  el.dispatchEvent(new Event("change", { bubbles: true }));
                  el.dispatchEvent(new Event("input", { bubbles: true }));
                }
                
                // Get CampaignData
                const { CampaignData = {} } = await chrome.storage.local.get(["CampaignData"]);
                const nestedCampaign = Object.values(CampaignData)[0];
                let mainCategory = null;
                
                // Determine behavior based on requiredCategory setting
                // If requiredCategory = true: use citations[domain].mainCategory (category selection)
                // If requiredCategory = false: use campaignData.mainCategoryBox (direct fill)
                
                if (requiredCategory) {
                  // REQUIRED CATEGORY = TRUE: Use citations[domain].mainCategory (category selection)
                  // IMPORTANT: Never use mainCategoryBox when requiredCategory = true
                  console.log(`üìã [${stepIndex}] requiredCategory = true - using citations-based mainCategory from citations[domain].mainCategory`);
                  console.log(`üìã [${stepIndex}] IMPORTANT: Will NOT use mainCategoryBox when requiredCategory = true`);
                  
                  // Try multiple paths to find citations
                  let citations = null;
                  
                  // Path 1: nestedCampaign.campaignData.citations
                  if (nestedCampaign?.campaignData?.citations && Array.isArray(nestedCampaign.campaignData.citations)) {
                    citations = nestedCampaign.campaignData.citations;
                    console.log(`üìã [${stepIndex}] Found citations at: nestedCampaign.campaignData.citations`);
                  }
                  // Path 2: nestedCampaign.citations
                  else if (nestedCampaign?.citations && Array.isArray(nestedCampaign.citations)) {
                    citations = nestedCampaign.citations;
                    console.log(`üìã [${stepIndex}] Found citations at: nestedCampaign.citations`);
                  }
                  // Path 3: CampaignData.citations (direct)
                  else if (CampaignData.citations && Array.isArray(CampaignData.citations)) {
                    citations = CampaignData.citations;
                    console.log(`üìã [${stepIndex}] Found citations at: CampaignData.citations`);
                  }
                  // Path 4: Check if CampaignData itself is an array of campaigns
                  else if (Array.isArray(CampaignData)) {
                    for (const campaign of CampaignData) {
                      if (campaign.citations && Array.isArray(campaign.citations)) {
                        citations = campaign.citations;
                        console.log(`üìã [${stepIndex}] Found citations in CampaignData array`);
                        break;
                      } else if (campaign.campaignData?.citations && Array.isArray(campaign.campaignData.citations)) {
                        citations = campaign.campaignData.citations;
                        console.log(`üìã [${stepIndex}] Found citations in CampaignData array (nested)`);
                        break;
                      }
                    }
                  }
                  
                  console.log(`üîç [${stepIndex}] Citation lookup debug (selector-based):`);
                  console.log(`   ‚Ä¢ Current domain: "${currentDomain}"`);
                  console.log(`   ‚Ä¢ Citations type: ${Array.isArray(citations) ? 'array' : typeof citations}`);
                  console.log(`   ‚Ä¢ Citations length: ${Array.isArray(citations) ? citations.length : 'N/A'}`);
                  
                  if (Array.isArray(citations)) {
                    console.log(`   ‚Ä¢ Total citations: ${citations.length}`);
                    
                    // Log all citation sites for debugging
                    const citationSites = citations.map(c => c.site).filter(Boolean);
                    console.log(`   ‚Ä¢ Available citation sites: ${citationSites.join(', ')}`);
                    
                    // Find citation matching current domain (try multiple matching strategies)
                    let matchingCitation = citations.find(citation => {
                      if (!citation.site) return false;
                      const citationSite = extractBaseDomain(citation.site);
                      return citationSite === currentDomain.toLowerCase();
                    });
                    
                    // If not found, try without www prefix removal
                    if (!matchingCitation) {
                      matchingCitation = citations.find(citation => {
                        if (!citation.site) return false;
                        return citation.site.toLowerCase() === currentDomain.toLowerCase() || 
                               citation.site.toLowerCase() === `www.${currentDomain}`.toLowerCase();
                      });
                    }
                    
                    if (matchingCitation) {
                      mainCategory = matchingCitation.mainCategory || matchingCitation.maincategory || null;
                      console.log(`‚úÖ [${stepIndex}] Found matching citation for ${currentDomain}`);
                      console.log(`   ‚Ä¢ Citation site: "${matchingCitation.site}"`);
                      console.log(`   ‚Ä¢ Citation mainCategory: "${matchingCitation.mainCategory || matchingCitation.maincategory || 'N/A'}"`);
                      console.log(`üéØ [${stepIndex}] Main category from citation: "${mainCategory}"`);
                    } else {
                      console.warn(`‚ö†Ô∏è [${stepIndex}] No citation found for domain: ${currentDomain}`);
                      console.warn(`   ‚Ä¢ Available sites: ${citationSites.join(', ')}`);
                      console.warn(`   ‚Ä¢ Field will be left empty (no fallback to mainCategoryBox when requiredCategory = true)`);
                      console.warn(`   ‚Ä¢ Previous mainCategoryBox value will be cleared to prevent persistence`);
                      mainCategory = null; // Explicitly set to null - do NOT use mainCategoryBox
                    }
                  } else if (citations && typeof citations === 'object' && !Array.isArray(citations)) {
                    // Object structure: citations is an object with site names as keys (e.g., CampaignData.citations[site])
                    // Try direct access by currentDomain
                    const citationBySite = citations[currentDomain] || citations[`www.${currentDomain}`];
                    
                    if (citationBySite) {
                      mainCategory = citationBySite.mainCategory || citationBySite.maincategory || null;
                      console.log(`üéØ [${stepIndex}] Main category from object citations[${currentDomain}]: "${mainCategory}"`);
                    } else {
                      // Try to find by matching site key (case-insensitive)
                      const siteKey = Object.keys(citations).find(key => {
                        const keyDomain = extractBaseDomain(key);
                        return keyDomain === currentDomain.toLowerCase() || 
                               key.toLowerCase() === currentDomain.toLowerCase() ||
                               key.toLowerCase() === `www.${currentDomain}`.toLowerCase();
                      });
                      
                      if (siteKey && citations[siteKey]) {
                        mainCategory = citations[siteKey].mainCategory || citations[siteKey].maincategory || null;
                        console.log(`üéØ [${stepIndex}] Main category from object citations["${siteKey}"]: "${mainCategory}"`);
                      } else {
                        // Fallback: if citations object itself has mainCategory (single citation object)
                        mainCategory = citations.mainCategory || citations.maincategory || null;
                        if (mainCategory) {
                          console.log(`üéØ [${stepIndex}] Main category from object citations (single citation): "${mainCategory}"`);
                        } else {
                          console.warn(`‚ö†Ô∏è [${stepIndex}] No citation found for domain: ${currentDomain} in object structure`);
                          console.warn(`   ‚Ä¢ Available site keys: ${Object.keys(citations).join(', ')}`);
                          console.warn(`   ‚Ä¢ Field will be left empty (no fallback to mainCategoryBox when requiredCategory = true)`);
                          console.warn(`   ‚Ä¢ Previous mainCategoryBox value will be cleared to prevent persistence`);
                          mainCategory = null; // Explicitly set to null - do NOT use mainCategoryBox
                        }
                      }
                    }
                  } else {
                    console.warn(`‚ö†Ô∏è [${stepIndex}] No citations data found or invalid format`);
                    console.warn(`   ‚Ä¢ Citations value:`, citations);
                    console.warn(`   ‚Ä¢ nestedCampaign:`, nestedCampaign);
                    console.warn(`   ‚Ä¢ CampaignData structure:`, Object.keys(CampaignData));
                    console.warn(`   ‚Ä¢ Field will be left empty (no fallback to mainCategoryBox when requiredCategory = true)`);
                    console.warn(`   ‚Ä¢ Previous mainCategoryBox value will be cleared to prevent persistence`);
                    mainCategory = null; // Explicitly set to null - do NOT use mainCategoryBox
                  }
                  
                  // Trim and validate
                  if (mainCategory && typeof mainCategory === 'string') {
                    mainCategory = mainCategory.trim();
                    if (mainCategory.length === 0) {
                      mainCategory = null;
                      console.warn(`‚ö†Ô∏è [${stepIndex}] Main category is empty after trimming`);
                    }
                  }
                  
                  // CRITICAL: Ensure we never use mainCategoryBox when requiredCategory = true
                  // Double-check that mainCategory is not from mainCategoryBox
                  const mainCategoryBoxValue = nestedCampaign?.campaignData?.mainCategoryBox || 
                                               nestedCampaign?.campaignData?.mainCategory || 
                                               CampaignData.mainCategoryBox ||
                                               CampaignData.mainCategory ||
                                               flatData['mainCategoryBox'] ||
                                               flatData['mainCategory'] ||
                                               null;
                  
                  if (mainCategory && mainCategoryBoxValue && mainCategory === mainCategoryBoxValue) {
                    console.warn(`‚ö†Ô∏è [${stepIndex}] DETECTED mainCategoryBox value in mainCategory - clearing to prevent persistence`);
                    console.warn(`   ‚Ä¢ This should not happen when requiredCategory = true`);
                    console.warn(`   ‚Ä¢ mainCategory value: "${mainCategory}"`);
                    console.warn(`   ‚Ä¢ mainCategoryBox value: "${mainCategoryBoxValue}"`);
                    mainCategory = null; // Clear it - we should only use citation data
                  }
                } else {
                  // REQUIRED CATEGORY = FALSE: Fill directly using campaignData.mainCategoryBox (no category selection logic)
                  console.log(`üìã [${stepIndex}] requiredCategory = false - filling directly from campaignData.mainCategoryBox`);
                  mainCategory = nestedCampaign?.campaignData?.mainCategoryBox || 
                                 nestedCampaign?.campaignData?.mainCategory || 
                                 CampaignData.mainCategoryBox ||
                                 CampaignData.mainCategory ||
                                 flatData['mainCategoryBox'] ||
                                 flatData['mainCategory'] ||
                                 null;
                  
                  if (mainCategory) {
                    console.log(`üéØ [${stepIndex}] Main category from campaignData.mainCategoryBox: "${mainCategory}"`);
                  } else {
                    console.log(`‚ÑπÔ∏è [${stepIndex}] No mainCategoryBox found in campaignData, field will be left empty`);
                  }
                }
                
                if (mainCategory && mainCategory !== "") {
                  // Case 1: Handle "Skip Category" or "skipCategory1" - create/update first option and select it
                  // Check if mainCategory value indicates skip category (case-insensitive, supports variations)
                  const skipCategoryVariations = ["Skip Category", "skipCategory1", "skip category", "skip-category"];
                  const isSkipCategory = skipCategoryVariations.some(variation => 
                    mainCategory.toLowerCase().trim() === variation.toLowerCase().trim()
                  );
                  
                  if (isSkipCategory) {
                    // Check if "Skip Category" option already exists
                    let skipOption = el.querySelector('option[value="0000"]');
                    
                    if (!skipOption) {
                      // Create new "Skip Category" option as first option
                      skipOption = document.createElement('option');
                      skipOption.value = "0000";
                      skipOption.textContent = "Skip Category";
                      el.insertBefore(skipOption, el.firstChild);
                      console.log(`üîß [${stepIndex}] Created "Skip Category" option with value="0000"`);
                    } else {
                      // Update existing option text if needed
                      skipOption.textContent = "Skip Category";
                      console.log(`üîß [${stepIndex}] Updated existing "Skip Category" option`);
                    }
                    
                    // Select the "Skip Category" option
                    el.value = "0000";
                    el.dispatchEvent(new Event("change", { bubbles: true }));
                    el.dispatchEvent(new Event("input", { bubbles: true }));
                    el.dispatchEvent(new Event("blur", { bubbles: true }));
                    el.style.border = "2px solid #4CAF50";
                    console.log(`‚úÖ [${stepIndex}] Main category set to: "Skip Category" (value="0000")`);
                    return { success: true };
                  }
                  
                  // Case 2: Handle other categories - search for matching option by value first, then by text
                  else {
                    const options = Array.from(el.options);
                    let matchedOption = null;
                    const trimmedMainCategory = mainCategory.trim();
                    
                    console.log(`üîç [${stepIndex}] Searching for category match: "${trimmedMainCategory}"`);
                    console.log(`   ‚Ä¢ Available options: ${options.map(opt => `"${opt.textContent}" (value="${opt.value}")`).join(', ')}`);
                    
                    // Strategy 1: Try matching by VALUE first (if mainCategory is numeric or matches an option value)
                    // This handles cases where mainCategory might be "1", "2", etc. instead of "Automotive", "Computer Repair"
                    const valueMatch = options.find(option => {
                      const optionValue = String(option.value).trim();
                      const mainCategoryValue = String(trimmedMainCategory).trim();
                      return optionValue === mainCategoryValue;
                    });
                    
                    if (valueMatch) {
                      matchedOption = valueMatch;
                      console.log(`‚úÖ [${stepIndex}] Matched by VALUE: "${trimmedMainCategory}" ‚Üí option "${valueMatch.textContent}" (value="${valueMatch.value}")`);
                    }
                    
                    // Strategy 2: If no value match, try exact text match (case-insensitive)
                    if (!matchedOption) {
                      matchedOption = options.find(option => 
                        option.textContent.trim().toLowerCase() === trimmedMainCategory.toLowerCase()
                      );
                      if (matchedOption) {
                        console.log(`‚úÖ [${stepIndex}] Matched by EXACT TEXT: "${trimmedMainCategory}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                      }
                    }
                    
                    // Strategy 3: If no exact match, try partial text match (e.g., "Chiropractor" matches "CHIROPRACTORS")
                    if (!matchedOption) {
                      matchedOption = options.find(option => 
                        option.textContent.trim().toLowerCase().includes(trimmedMainCategory.toLowerCase()) ||
                        trimmedMainCategory.toLowerCase().includes(option.textContent.trim().toLowerCase())
                      );
                      if (matchedOption) {
                        console.log(`‚úÖ [${stepIndex}] Matched by PARTIAL TEXT: "${trimmedMainCategory}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                      }
                    }
                    
                    // Strategy 4: If still no match, try fuzzy matching (remove spaces, special chars)
                    if (!matchedOption) {
                      const cleanMainCategory = trimmedMainCategory.toLowerCase().replace(/[^a-z0-9]/g, '');
                      matchedOption = options.find(option => {
                        const cleanOptionText = option.textContent.trim().toLowerCase().replace(/[^a-z0-9]/g, '');
                        return cleanOptionText.includes(cleanMainCategory) || cleanMainCategory.includes(cleanOptionText);
                      });
                      if (matchedOption) {
                        console.log(`‚úÖ [${stepIndex}] Matched by FUZZY TEXT: "${trimmedMainCategory}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                      }
                    }
                    
                    if (matchedOption) {
                      el.value = matchedOption.value;
                      el.dispatchEvent(new Event("change", { bubbles: true }));
                      el.dispatchEvent(new Event("input", { bubbles: true }));
                      el.dispatchEvent(new Event("blur", { bubbles: true }));
                      el.style.border = "2px solid #4CAF50";
                      console.log(`‚úÖ [${stepIndex}] Main category set to: "${matchedOption.textContent}" (value="${matchedOption.value}") for input "${trimmedMainCategory}"`);
                      return { success: true };
                    } else {
                      // No match found, log available options for debugging
                      const availableOptions = options.map(opt => `"${opt.textContent}" (value="${opt.value}")`).join(', ');
                      console.warn(`‚ö†Ô∏è [${stepIndex}] No matching option found for "${trimmedMainCategory}"`);
                      console.warn(`   ‚Ä¢ Tried: value match, exact text, partial text, fuzzy text`);
                      console.warn(`   ‚Ä¢ Available options: ${availableOptions}`);
                      
                      // Set to empty as fallback (don't set a default value to avoid wrong selection)
                      el.value = "";
                      el.dispatchEvent(new Event("change", { bubbles: true }));
                      el.dispatchEvent(new Event("input", { bubbles: true }));
                      el.dispatchEvent(new Event("blur", { bubbles: true }));
                      el.style.border = "2px solid #FF9800"; // Orange border to indicate warning
                      console.log(`‚ö†Ô∏è [${stepIndex}] Main category set to: empty (no match found for "${trimmedMainCategory}")`);
                      return { success: true };
                    }
                  }
                } else {
                  // No main category value, set empty
                  el.value = "";
                  el.dispatchEvent(new Event("change", { bubbles: true }));
                  el.dispatchEvent(new Event("input", { bubbles: true }));
                  el.dispatchEvent(new Event("blur", { bubbles: true }));
                  el.style.border = "2px solid #4CAF50";
                  console.log(`‚úÖ [${stepIndex}] Main category set to: empty (no category value)`);
                  return { success: true };
                }
              }
              
              // Normalize string values: trim whitespace (but preserve if it becomes empty)
              // Exception: Don't trim if value came from directValue fallback (might be HTML entities like "&nbsp;")
              const isDirectValueFallback = fallbackType && String(fallbackType).toLowerCase().trim() === 'directvalue' && directValue !== undefined && directValue !== null && String(directValue) === val;
              if (val && typeof val === 'string' && !isDirectValueFallback) {
                const trimmed = val.trim();
                // If trimmed value is empty, treat as empty; otherwise use trimmed version
                if (trimmed.length === 0) {
                  val = '';
                } else {
                  val = trimmed;
                }
              }

              const normalizedMode = mode ? String(mode).toLowerCase().trim() : null;
              const parsedLimitValue = parseLimitValue(limitvalue);
              if (normalizedMode && parsedLimitValue && val !== undefined && val !== null) {
                const originalVal = typeof val === 'string' ? val : String(val);
                if (normalizedMode === 'limit') {
                  const limitedVal = applyLimit(originalVal, parsedLimitValue);
                  if (limitedVal !== originalVal) {
                    console.log(`‚úÇÔ∏è [${stepIndex}] limit mode applied (${parsedLimitValue} chars): "${originalVal}" -> "${limitedVal}"`);
                  }
                  val = limitedVal;
                } else if (normalizedMode === 'limitbysentence') {
                  const limitedVal = applyLimitBySentence(originalVal, parsedLimitValue);
                  if (limitedVal !== originalVal) {
                    console.log(`‚úÇÔ∏è [${stepIndex}] limitBySentence applied (${parsedLimitValue} chars): "${originalVal}" -> "${limitedVal}"`);
                  }
                  val = limitedVal;
                }
              }
              
              // Check if value is effectively empty (null, undefined, empty string, or only whitespace)
              const isEmptyValue = !val || (typeof val === 'string' && val.trim().length === 0);
              
              if (!isEmptyValue) {
                // Handle fillAndSelect: Match by label/text instead of value (similar to category fields)
                if (fillAndSelect === true && el) {
                  const searchValue = String(val).trim();
                  console.log(`üîç [${stepIndex}] fillAndSelect enabled - searching for label match: "${searchValue}"`);
                  
                  let fillAndSelectResult = null;
                  
                  // Helper function to detect Kendo UI dropdowns
                  const isKendoDropdown = (element) => {
                    if (!element) return false;
                    
                    // Check if element itself is a Kendo dropdown wrapper
                    if (element.classList.contains('k-dropdown') || 
                        element.classList.contains('k-widget') && element.classList.contains('k-dropdown')) {
                      return true;
                    }
                    
                    // Check if element is the hidden input with data-role="dropdownlist"
                    if (element.getAttribute('data-role') === 'dropdownlist' ||
                        (element.type === 'number' || element.type === 'text') && element.hasAttribute('data-role') && element.getAttribute('data-role') === 'dropdownlist') {
                      return true;
                    }
                    
                    // Check if element is inside a Kendo dropdown
                    const kendoWrapper = element.closest('.k-dropdown, .k-widget.k-dropdown');
                    if (kendoWrapper) {
                      return true;
                    }
                    
                    // Check if there's a Kendo dropdown wrapper nearby
                    const parent = element.parentElement;
                    if (parent && (parent.classList.contains('k-dropdown') || parent.classList.contains('k-widget'))) {
                      return true;
                    }
                    
                    return false;
                  };
                  
                  // Handle Kendo UI Dropdowns - must be checked before INPUT/TEXTAREA handler
                  if (isKendoDropdown(el)) {
                    console.log(`üîç [${stepIndex}] fillAndSelect: Detected Kendo UI dropdown, opening and searching for: "${searchValue}"`);
                    
                    try {
                      // Step 1: Find the Kendo dropdown wrapper
                      let kendoWrapper = el;
                      if (el.getAttribute('data-role') === 'dropdownlist' || (el.type === 'number' || el.type === 'text')) {
                        // Element is the hidden input, find the wrapper
                        kendoWrapper = el.closest('.k-dropdown, .k-widget.k-dropdown');
                        if (!kendoWrapper) {
                          // Try finding by parent or sibling
                          kendoWrapper = el.parentElement?.closest('.k-dropdown, .k-widget.k-dropdown');
                        }
                      }
                      
                      if (!kendoWrapper) {
                        console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: Could not find Kendo dropdown wrapper for element`);
                        fillAndSelectResult = { success: false, error: 'Could not find Kendo dropdown wrapper' };
                      } else {
                        console.log(`‚úÖ [${stepIndex}] fillAndSelect: Found Kendo dropdown wrapper`);
                        
                        // Step 2: Find and click the dropdown trigger
                        const triggerSelectors = [
                          '.k-select',
                          '.k-dropdown-wrap',
                          '[class*="k-select"]',
                          '[class*="k-dropdown-wrap"]',
                          'span.k-select',
                          'span[aria-label="select"]'
                        ];
                        
                        let trigger = null;
                        for (const selector of triggerSelectors) {
                          trigger = kendoWrapper.querySelector(selector);
                          if (trigger && trigger.offsetParent !== null) { // Check if visible
                            break;
                          }
                        }
                        
                        if (!trigger) {
                          console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: Could not find Kendo dropdown trigger button`);
                          fillAndSelectResult = { success: false, error: 'Could not find Kendo dropdown trigger' };
                        } else {
                          console.log(`‚úÖ [${stepIndex}] fillAndSelect: Found trigger, clicking to open dropdown...`);
                          
                          // Click to open dropdown
                          trigger.click();
                          await new Promise(resolve => setTimeout(resolve, 300)); // Wait for dropdown to open
                          
                          // Step 3: Find the listbox using aria-owns or other methods
                          const ariaOwns = kendoWrapper.getAttribute('aria-owns') || 
                                            kendoWrapper.querySelector('[aria-owns]')?.getAttribute('aria-owns');
                          
                          let listbox = null;
                          if (ariaOwns) {
                            // Try exact ID match first
                            listbox = document.getElementById(ariaOwns);
                            // If not found, try partial match
                            if (!listbox) {
                              listbox = document.querySelector(`[id*="${ariaOwns}"]`);
                            }
                          }
                          
                          // Fallback: Search for Kendo listbox patterns
                          if (!listbox) {
                            const listboxSelectors = [
                              'ul.k-listbox',
                              'ul[role="listbox"]',
                              'div.k-list-container',
                              '.k-list',
                              '[id*="listbox"]',
                              'ul.k-list',
                              'div[role="listbox"]',
                              '.k-popup .k-list',
                              '.k-animation-container .k-list'
                            ];
                            
                            for (const selector of listboxSelectors) {
                              const candidates = document.querySelectorAll(selector);
                              for (const candidate of candidates) {
                                // Check if visible and likely the right listbox
                                if (candidate.offsetParent !== null) {
                                  // Check if it's near the dropdown
                                  const candidateRect = candidate.getBoundingClientRect();
                                  const wrapperRect = kendoWrapper.getBoundingClientRect();
                                  const distance = Math.abs(candidateRect.top - wrapperRect.bottom);
                                  
                                  if (distance < 500) { // Within reasonable distance
                                    listbox = candidate;
                                    break;
                                  }
                                }
                              }
                              if (listbox) break;
                            }
                          }
                          
                          // Step 4: Wait for listbox to appear (with timeout)
                          const maxWait = 3000;
                          const startTime = Date.now();
                          while (!listbox || listbox.offsetParent === null) {
                            if (Date.now() - startTime > maxWait) {
                              console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: Kendo dropdown listbox did not appear within ${maxWait}ms`);
                              fillAndSelectResult = { success: false, error: 'Kendo dropdown listbox did not appear' };
                              break;
                            }
                            await new Promise(resolve => setTimeout(resolve, 100));
                            
                            // Re-check for listbox
                            if (ariaOwns && !listbox) {
                              listbox = document.getElementById(ariaOwns);
                            }
                            if (!listbox) {
                              // Try finding again with selectors
                              const tempListbox = document.querySelector('ul[role="listbox"], .k-list, ul.k-listbox');
                              if (tempListbox && tempListbox.offsetParent !== null) {
                                listbox = tempListbox;
                              }
                            }
                          }
                          
                          if (listbox && listbox.offsetParent !== null) {
                            console.log(`‚úÖ [${stepIndex}] fillAndSelect: Found Kendo listbox, searching for option: "${searchValue}"`);
                            
                            // Step 5: Find matching option in listbox
                            const optionSelectors = [
                              'li',
                              '[role="option"]',
                              '.k-item',
                              'li.k-item',
                              'div.k-item',
                              '[class*="k-item"]'
                            ];
                            
                            let allOptions = [];
                            for (const selector of optionSelectors) {
                              const options = listbox.querySelectorAll(selector);
                              options.forEach(opt => {
                                if (!allOptions.includes(opt) && opt.offsetParent !== null) {
                                  allOptions.push(opt);
                                }
                              });
                            }
                            
                            console.log(`   ‚Ä¢ Found ${allOptions.length} options in Kendo listbox`);
                            
                            // Matching strategies (same as SELECT element matching)
                            let matchedOption = null;
                            
                            // Strategy 1: Exact text match (case-insensitive)
                            matchedOption = allOptions.find(opt => {
                              const optText = (opt.textContent || opt.innerText || '').trim();
                              return optText.toLowerCase() === searchValue.toLowerCase();
                            });
                            
                            if (matchedOption) {
                              console.log(`‚úÖ [${stepIndex}] fillAndSelect: Matched by EXACT TEXT: "${searchValue}" ‚Üí "${matchedOption.textContent.trim()}"`);
                            }
                            
                            // Strategy 2: Partial text match
                            if (!matchedOption) {
                              matchedOption = allOptions.find(opt => {
                                const optText = (opt.textContent || opt.innerText || '').trim().toLowerCase();
                                return optText.includes(searchValue.toLowerCase()) ||
                                       searchValue.toLowerCase().includes(optText);
                              });
                              if (matchedOption) {
                                console.log(`‚úÖ [${stepIndex}] fillAndSelect: Matched by PARTIAL TEXT: "${searchValue}" ‚Üí "${matchedOption.textContent.trim()}"`);
                              }
                            }
                            
                            // Strategy 3: Fuzzy match (remove special characters)
                            if (!matchedOption) {
                              const cleanSearchValue = searchValue.toLowerCase().replace(/[^a-z0-9]/g, '');
                              matchedOption = allOptions.find(opt => {
                                const optText = (opt.textContent || opt.innerText || '').trim();
                                const cleanOptText = optText.toLowerCase().replace(/[^a-z0-9]/g, '');
                                return cleanOptText.includes(cleanSearchValue) || 
                                       cleanSearchValue.includes(cleanOptText);
                              });
                              if (matchedOption) {
                                console.log(`‚úÖ [${stepIndex}] fillAndSelect: Matched by FUZZY TEXT: "${searchValue}" ‚Üí "${matchedOption.textContent.trim()}"`);
                              }
                            }
                            
                            if (matchedOption) {
                              // Scroll into view
                              matchedOption.scrollIntoView({ behavior: 'smooth', block: 'center' });
                              await new Promise(resolve => setTimeout(resolve, 200));
                              
                              // Click the matched option
                              matchedOption.click();
                              
                              // Also try mouse events for better compatibility
                              if (matchedOption.dispatchEvent) {
                                matchedOption.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
                                matchedOption.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
                              }
                              
                              await new Promise(resolve => setTimeout(resolve, 200));
                              
                              // Update the hidden input value if possible
                              const hiddenInput = kendoWrapper.querySelector('input[data-role="dropdownlist"], input[type="number"]');
                              if (hiddenInput) {
                                // Try to get value from data attributes or option
                                const optionValue = matchedOption.getAttribute('data-value') || 
                                                   matchedOption.getAttribute('value') ||
                                                   matchedOption.textContent.trim();
                                hiddenInput.value = optionValue;
                                hiddenInput.dispatchEvent(new Event('change', { bubbles: true }));
                                hiddenInput.dispatchEvent(new Event('input', { bubbles: true }));
                              }
                              
                              console.log(`‚úÖ [${stepIndex}] fillAndSelect: Successfully selected Kendo option: "${matchedOption.textContent.trim()}"`);
                              highlightElement(kendoWrapper, stepIndex, 'Selected', matchedOption.textContent.trim());
                              fillAndSelectResult = { success: true };
                            } else {
                              const availableOptions = allOptions.slice(0, 10).map(opt => `"${(opt.textContent || opt.innerText || '').trim()}"`).join(', ');
                              console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: No matching option found in Kendo dropdown for "${searchValue}"`);
                              console.warn(`   ‚Ä¢ Available options (first 10): ${availableOptions}${allOptions.length > 10 ? '...' : ''}`);
                              fillAndSelectResult = { success: false, error: `No matching option found in Kendo dropdown for "${searchValue}"` };
                            }
                          }
                        }
                      }
                    } catch (error) {
                      console.error(`‚ùå [${stepIndex}] fillAndSelect: Error handling Kendo dropdown:`, error);
                      fillAndSelectResult = { success: false, error: `Error handling Kendo dropdown: ${error.message}` };
                    }
                  }
                  
                  // Handle INPUT/TEXTAREA elements - fill first, then wait for suggestions dropdown
                  else if ((el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') && el.type !== 'select-one' && el.type !== 'select-multiple') {
                    console.log(`üîç [${stepIndex}] fillAndSelect: Filling input field first, then waiting for suggestions dropdown`);
                    
                    // Step 1: Fill the input field
                    el.focus();
                    el.value = searchValue;
                    el.dispatchEvent(new Event('focus', { bubbles: true }));
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    el.dispatchEvent(new Event('keydown', { bubbles: true }));
                    el.dispatchEvent(new Event('keyup', { bubbles: true }));
                    
                    // Delay to allow input to be processed and autocomplete to trigger
                    // Increased delay to ensure autocomplete systems have time to process
                    await new Promise(resolve => setTimeout(resolve, 600));
                    
                    // Step 2: Wait for suggestions dropdown to appear
                    console.log(`üîç [${stepIndex}] fillAndSelect: Waiting for suggestions dropdown to appear...`);
                    
                    // Get list of existing UL elements before filling (to filter out static navigation menus)
                    const existingULs = new Set(Array.from(document.querySelectorAll('ul')).map(ul => ul));
                    
                    // Comprehensive list of suggestion container selectors
                    // Includes jQuery UI, Bootstrap, Material UI, and custom implementations
                    const suggestionSelectors = [
                      // jQuery UI menu (specific to user's example)
                      '.ui-menu',
                      'ul.ui-menu',
                      'div.ui-menu',
                      // Standard ARIA patterns
                      'ul[role="listbox"]',
                      'ul[role="menu"]',
                      'div[role="listbox"]',
                      'div[role="menu"]',
                      'div[role="combobox"]',
                      // Common class patterns
                      '.autocomplete',
                      '.suggestions',
                      '.dropdown-menu',
                      '.dropdown',
                      '.suggestion-list',
                      '.autocomplete-list',
                      '.select-dropdown',
                      '.typeahead',
                      '.awesomplete',
                      // Pattern-based selectors
                      '[class*="autocomplete"]',
                      '[class*="suggestion"]',
                      '[class*="dropdown"]',
                      '[class*="menu"]',
                      '[class*="select"]',
                      '[class*="typeahead"]',
                      // Specific element patterns
                      'ul.autocomplete',
                      'ul.suggestions',
                      'ul.dropdown-menu',
                      'div.autocomplete',
                      'div.suggestions'
                    ];
                    
                    // Helper function to extract clean text from a suggestion item
                    // Handles nested elements like icons, images, and other decorative content
                    const extractItemText = (item) => {
                      if (!item) return '';
                      
                      // Clone the item to avoid modifying the original
                      const clone = item.cloneNode(true);
                      
                      // Remove common decorative elements that don't contribute to text matching
                      const decorativeSelectors = [
                        '.flag-icon',
                        '.icon',
                        '[class*="icon"]',
                        '[class*="flag"]',
                        'img',
                        'svg',
                        '.badge',
                        '.label',
                        '[class*="badge"]',
                        '[class*="label"]'
                      ];
                      
                      decorativeSelectors.forEach(selector => {
                        try {
                          const decorativeElements = clone.querySelectorAll(selector);
                          decorativeElements.forEach(el => el.remove());
                        } catch (e) {
                          // Ignore invalid selectors
                        }
                      });
                      
                      // Get text content and clean it up
                      let text = clone.textContent || clone.innerText || '';
                      
                      // Normalize whitespace
                      text = text.replace(/\s+/g, ' ').trim();
                      
                      return text;
                    };
                    
                    // Robust function to find suggestion items within a container
                    // Handles jQuery UI, standard patterns, and custom implementations
                    const findSuggestionItems = (container) => {
                      if (!container) return [];
                      
                      // Comprehensive selectors for suggestion items
                      const itemSelectors = [
                        // jQuery UI menu items (specific to user's example)
                        '.ui-menu-item-wrapper',
                        '.ui-menu-item',
                        'li.ui-menu-item',
                        'div.ui-menu-item',
                        // Standard ARIA patterns
                        'li[role="option"]',
                        'div[role="option"]',
                        'a[role="option"]',
                        'button[role="option"]',
                        // Common list items
                        'li',
                        'div[class*="item"]',
                        'div[class*="option"]',
                        'a[class*="item"]',
                        'a[class*="option"]',
                        'button[class*="item"]',
                        'button[class*="option"]',
                        // Pattern-based
                        '[class*="menu-item"]',
                        '[class*="dropdown-item"]',
                        '[class*="suggestion-item"]',
                        '[class*="autocomplete-item"]',
                        '[class*="select-item"]',
                        '[class*="typeahead-item"]',
                        // Generic interactive elements in menu context
                        'a',
                        'button',
                        '[tabindex]'
                      ];
                      
                      const allItems = [];
                      for (const selector of itemSelectors) {
                        try {
                          const items = container.querySelectorAll(selector);
                          items.forEach(item => {
                            // Avoid duplicates
                            if (!allItems.includes(item)) {
                              // Check if item is visible and interactive
                              const style = window.getComputedStyle(item);
                              const isVisible = style.display !== 'none' && 
                                              style.visibility !== 'hidden' && 
                                              style.opacity !== '0';
                              
                              // Use extractItemText to check for meaningful content
                              const itemText = extractItemText(item);
                              const hasContent = itemText.length > 0 || item.children.length > 0;
                              
                              if (isVisible && hasContent) {
                                allItems.push(item);
                              }
                            }
                          });
                        } catch (e) {
                          // Skip invalid selectors
                          console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: Invalid selector "${selector}":`, e);
                        }
                      }
                      
                      return allItems;
                    };
                    
                    // Helper function to check if container is likely an autocomplete dropdown
                    const isLikelyAutocomplete = (container, inputEl) => {
                      // Exclude navigation menus (but allow jQuery UI menus which might have "menu" in class)
                      if ((container.classList.contains('nav') || 
                          container.classList.contains('navbar')) &&
                          !container.classList.contains('ui-menu')) {
                        return false;
                      }
                      
                      // Check if it's a navigation menu by context
                      if (container.closest('.nav') || container.closest('.navbar')) {
                        // But allow if it's a jQuery UI menu or explicitly an autocomplete
                        if (!container.classList.contains('ui-menu') && 
                            !container.classList.contains('autocomplete') &&
                            !container.getAttribute('role')?.includes('listbox') &&
                            !container.getAttribute('role')?.includes('menu')) {
                          return false;
                        }
                      }
                      
                      // Prefer containers near the input
                      const inputRect = inputEl.getBoundingClientRect();
                      const containerRect = container.getBoundingClientRect();
                      const distance = Math.abs(containerRect.top - inputRect.bottom);
                      
                      // If container is very far from input (more than 300px), it's probably not related
                      // But allow if it's a jQuery UI menu (they can appear anywhere)
                      const isJQueryUIMenu = container.classList.contains('ui-menu');
                      if (distance > 300 && !container.contains(inputEl) && 
                          !inputEl.parentElement?.contains(container) && !isJQueryUIMenu) {
                        return false;
                      }
                      
                      // Check if container has suggestion items using our robust function
                      const items = findSuggestionItems(container);
                      if (items.length === 0) {
                        return false;
                      }
                      
                      return true;
                    };
                    
                    let suggestionsContainer = null;
                    const maxWaitTime = 3000; // 3 seconds max wait
                    const checkInterval = 100; // Check every 100ms
                    let waitedTime = 0;
                    
                    while (!suggestionsContainer && waitedTime < maxWaitTime) {
                      // Try to find suggestions container in various locations
                      for (const selector of suggestionSelectors) {
                        // First, try to find near the input element (most reliable)
                        let container = el.parentElement?.querySelector(selector);
                        if (!container) {
                          // Try finding in siblings or nearby elements
                          let parent = el.parentElement;
                          while (parent && parent !== document.body) {
                            container = parent.querySelector(selector);
                            if (container && isLikelyAutocomplete(container, el)) {
                              break;
                            }
                            parent = parent.parentElement;
                          }
                        }
                        
                        if (!container) {
                          // Try in document body, but prioritize newly appeared elements
                          const allContainers = Array.from(document.querySelectorAll(selector));
                          container = allContainers.find(c => {
                            // Prefer containers that appeared after input was filled (not in original list)
                            const isNew = !existingULs.has(c);
                            return isLikelyAutocomplete(c, el) && (isNew || c.contains(el) || el.parentElement?.contains(c));
                          });
                        }
                        
                        if (!container) {
                          // Last resort: comprehensive page-wide search for suggestion containers
                          // This handles cases like jQuery UI menus that might appear anywhere
                          const allPossibleContainers = Array.from(document.querySelectorAll(
                            'ul, div[role="listbox"], div[role="menu"], div[role="combobox"], ' +
                            '.ui-menu, [class*="menu"], [class*="dropdown"], [class*="autocomplete"], [class*="suggestion"]'
                          ));
                          
                          container = allPossibleContainers.find(elem => {
                            const style = window.getComputedStyle(elem);
                            const isVisible = style.display !== 'none' && 
                                            style.visibility !== 'hidden' && 
                                            style.opacity !== '0';
                            const hasContent = elem.textContent.trim().length > 0 || elem.children.length > 0;
                            const isNew = !existingULs.has(elem);
                            
                            // For jQuery UI menus, be more lenient with distance check
                            const isJQueryUIMenu = elem.classList.contains('ui-menu');
                            
                            return isVisible && hasContent && isLikelyAutocomplete(elem, el) && 
                                   (isNew || elem.contains(el) || el.parentElement?.contains(elem) || isJQueryUIMenu);
                          });
                        }
                        
                        if (container) {
                          const style = window.getComputedStyle(container);
                          // Check if container is visible
                          if (style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {
                            if (isLikelyAutocomplete(container, el)) {
                              suggestionsContainer = container;
                              console.log(`‚úÖ [${stepIndex}] fillAndSelect: Found suggestions container: ${container.tagName}${container.className ? '.' + container.className.split(' ').join('.') : ''}`);
                              break;
                            }
                          }
                        }
                      }
                      
                      if (!suggestionsContainer) {
                        await new Promise(resolve => setTimeout(resolve, checkInterval));
                        waitedTime += checkInterval;
                      }
                    }
                    
                    if (suggestionsContainer) {
                      // Additional delay after dropdown appears to ensure items are fully rendered
                      console.log(`‚è≥ [${stepIndex}] fillAndSelect: Dropdown found, waiting for items to fully render...`);
                      await new Promise(resolve => setTimeout(resolve, 400));
                      
                      // Step 3: Find matching item in suggestions using robust function
                      // This handles jQuery UI menu items and other patterns
                      const suggestionItems = findSuggestionItems(suggestionsContainer);
                      
                      if (suggestionItems.length > 0) {
                        // Try to find matching item by search value first
                        let selectedItem = null;
                        const searchValueLower = searchValue.toLowerCase().trim();
                        
                        // Strategy 1: Exact text match (case-insensitive) using clean text extraction
                        selectedItem = suggestionItems.find(item => {
                          const itemText = extractItemText(item).toLowerCase();
                          return itemText === searchValueLower;
                        });
                        
                        // Strategy 2: Partial match (search value contains item text or vice versa)
                        if (!selectedItem) {
                          selectedItem = suggestionItems.find(item => {
                            const itemText = extractItemText(item).toLowerCase();
                            return itemText.includes(searchValueLower) || searchValueLower.includes(itemText);
                          });
                        }
                        
                        // Strategy 3: Match by data attributes (data-value, data-label, etc.)
                        if (!selectedItem) {
                          selectedItem = suggestionItems.find(item => {
                            const itemValue = (item.dataset.value || item.getAttribute('value') || '').toString().toLowerCase();
                            const itemLabel = (item.dataset.label || item.getAttribute('data-label') || '').toString().toLowerCase();
                            const itemText = extractItemText(item).toLowerCase();
                            return itemValue === searchValueLower || itemLabel === searchValueLower ||
                                   itemValue.includes(searchValueLower) || itemLabel.includes(searchValueLower) ||
                                   itemText.includes(searchValueLower) || searchValueLower.includes(itemText);
                          });
                        }
                        
                        // Strategy 4: Fuzzy match (remove special chars)
                        if (!selectedItem) {
                          const cleanSearch = searchValueLower.replace(/[^a-z0-9]/g, '');
                          selectedItem = suggestionItems.find(item => {
                            const itemText = extractItemText(item).toLowerCase().replace(/[^a-z0-9]/g, '');
                            return itemText.includes(cleanSearch) || cleanSearch.includes(itemText);
                          });
                        }
                        
                        // Strategy 5: Word-based matching (for cases like "United States" matching "united" or "states")
                        if (!selectedItem) {
                          const searchWords = searchValueLower.split(/\s+/).filter(w => w.length > 0);
                          selectedItem = suggestionItems.find(item => {
                            const itemText = extractItemText(item).toLowerCase();
                            const itemWords = itemText.split(/\s+/).filter(w => w.length > 0);
                            // Check if all search words appear in item text
                            return searchWords.every(word => itemWords.some(itemWord => 
                              itemWord.includes(word) || word.includes(itemWord)
                            ));
                          });
                        }
                        
                        // Fallback: Use first item if no match found
                        if (!selectedItem) {
                          selectedItem = suggestionItems[0];
                          const fallbackText = extractItemText(selectedItem);
                          console.log(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: No exact match found for "${searchValue}", using first item: "${fallbackText}"`);
                        } else {
                          const matchedText = extractItemText(selectedItem);
                          console.log(`‚úÖ [${stepIndex}] fillAndSelect: Found matching suggestion item: "${matchedText}" for search value "${searchValue}"`);
                        }
                        
                        // Scroll item into view if needed
                        selectedItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        // Additional delay before clicking to ensure item is fully visible and interactive
                        console.log(`‚è≥ [${stepIndex}] fillAndSelect: Item scrolled into view, waiting before click...`);
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        // Click the selected item using physical mouse simulation (more realistic for sensitive sites)
                        const itemTextForLog = extractItemText(selectedItem);
                        console.log(`‚úÖ [${stepIndex}] fillAndSelect: Performing physical mouse click on suggestion item: "${itemTextForLog}"`);
                        
                        // Use simulateMouseClick for realistic physical click simulation
                        // This dispatches mouseover, mousedown, mouseup, click, mouseout in sequence with proper coordinates
                        const clickSuccess = await simulateMouseClick(selectedItem);
                        
                        if (!clickSuccess) {
                          // Fallback: try native click if simulation didn't work
                          console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: Physical click simulation failed, trying native click...`);
                          try {
                            selectedItem.click();
                          } catch (e) {
                            console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: Native click also failed: ${e.message}`);
                          }
                        }
                        
                        // Wait for the click to process and any async handlers to complete
                        // Increased delay to ensure selection is fully processed
                        await new Promise(resolve => setTimeout(resolve, 400));
                        
                        // Update input value if the item has a data-value or value attribute
                        if (selectedItem.dataset.value) {
                          el.value = selectedItem.dataset.value;
                        } else if (selectedItem.getAttribute('value')) {
                          el.value = selectedItem.getAttribute('value');
                        } else {
                          // Use clean text content as fallback (handles nested elements like icons)
                          const cleanText = extractItemText(selectedItem);
                          if (cleanText) {
                            el.value = cleanText;
                          }
                        }
                        
                        el.dispatchEvent(new Event('change', { bubbles: true }));
                        el.dispatchEvent(new Event('input', { bubbles: true }));
                        
                        // Step 4: Find and update hidden SELECT element if it exists (for custom autocomplete patterns)
                        // Enhanced to handle jQuery UI autocomplete with hidden SELECT elements
                        let hiddenSelect = null;
                        
                        // Comprehensive search strategy for hidden SELECT
                        const searchStrategies = [
                          // Strategy 1: Find in same parent element
                          () => {
                            if (el.parentElement) {
                              return el.parentElement.querySelector('select[name], select[id*="select"], select[class*="select"]');
                            }
                            return null;
                          },
                          
                          // Strategy 2: Find by name attribute matching input name
                          () => {
                            if (el.name) {
                              return document.querySelector(`select[name="${el.name}"]`);
                            }
                            return null;
                          },
                          
                          // Strategy 3: Find by id pattern (e.g., input id="country-input" -> select id="country-selector")
                          () => {
                            if (el.id) {
                              const baseId = el.id.replace(/-input$/, '').replace(/input$/, '');
                              return document.querySelector(`select#${baseId}-selector, select#${baseId}-select, select[name="${baseId}"]`);
                            }
                            return null;
                          },
                          
                          // Strategy 4: Find hidden SELECT in form group (most common pattern)
                          () => {
                            const formGroup = el.closest('.form-group');
                            if (formGroup) {
                              return formGroup.querySelector('select[style*="display: none"], select[style*="display:none"], select[style*="display: none"]');
                            }
                            return null;
                          },
                          
                          // Strategy 5: Find by data attribute linking (jQuery UI pattern)
                          () => {
                            const selectId = el.getAttribute('data-select-id') || el.getAttribute('aria-controls');
                            if (selectId) {
                              return document.querySelector(`select#${selectId}`);
                            }
                            return null;
                          },
                          
                          // Strategy 6: Find any hidden SELECT in parent hierarchy
                          () => {
                            let parent = el.parentElement;
                            while (parent && parent !== document.body) {
                              const select = parent.querySelector('select[style*="display: none"], select[style*="display:none"]');
                              if (select) return select;
                              parent = parent.parentElement;
                            }
                            return null;
                          },
                          
                          // Strategy 7: Find SELECT with same name as input (fallback)
                          () => {
                            if (el.name) {
                              const allSelects = document.querySelectorAll('select');
                              for (const select of allSelects) {
                                if (select.name === el.name || 
                                    (select.id && select.id.includes(el.name)) ||
                                    (el.name && select.name && select.name.includes(el.name))) {
                                  return select;
                                }
                              }
                            }
                            return null;
                          }
                        ];
                        
                        // Try each strategy until we find a SELECT
                        for (let i = 0; i < searchStrategies.length && !hiddenSelect; i++) {
                          try {
                            hiddenSelect = searchStrategies[i]();
                            if (hiddenSelect && hiddenSelect.tagName === 'SELECT') {
                              console.log(`üîç [${stepIndex}] fillAndSelect: Found hidden SELECT using strategy ${i + 1}`);
                              break;
                            }
                          } catch (e) {
                            console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: Strategy ${i + 1} failed:`, e);
                          }
                        }
                        
                        if (hiddenSelect && hiddenSelect.tagName === 'SELECT') {
                          console.log(`üîç [${stepIndex}] fillAndSelect: Found hidden SELECT element (name="${hiddenSelect.name}", id="${hiddenSelect.id}"), updating value...`);
                          
                          // Get the selected text from the autocomplete item
                          const selectedText = extractItemText(selectedItem).trim();
                          const selectedTextLower = selectedText.toLowerCase();
                          
                          // Try to find matching option in SELECT using multiple strategies
                          const selectOptions = Array.from(hiddenSelect.options);
                          let matchedOption = null;
                          
                          // Strategy 1: Exact text match (case-insensitive)
                          matchedOption = selectOptions.find(opt => {
                            const optText = opt.textContent.trim().toLowerCase();
                            return optText === selectedTextLower;
                          });
                          
                          // Strategy 2: Partial text match (handles cases like "United States" matching "United States")
                          if (!matchedOption) {
                            matchedOption = selectOptions.find(opt => {
                              const optText = opt.textContent.trim().toLowerCase();
                              return optText.includes(selectedTextLower) || selectedTextLower.includes(optText);
                            });
                          }
                          
                          // Strategy 3: Word-based matching (for multi-word matches)
                          if (!matchedOption) {
                            const selectedWords = selectedTextLower.split(/\s+/).filter(w => w.length > 2);
                            matchedOption = selectOptions.find(opt => {
                              const optText = opt.textContent.trim().toLowerCase();
                              const optWords = optText.split(/\s+/).filter(w => w.length > 2);
                              // Check if all significant words from selected text appear in option
                              return selectedWords.every(word => 
                                optWords.some(optWord => optWord.includes(word) || word.includes(optWord))
                              );
                            });
                          }
                          
                          // Strategy 4: Match by jQuery UI autocomplete data attributes
                          // jQuery UI often stores the value in data attributes
                          if (!matchedOption) {
                            const itemValue = selectedItem.dataset.value || 
                                           selectedItem.getAttribute('data-value') ||
                                           selectedItem.getAttribute('value');
                            if (itemValue) {
                              matchedOption = selectOptions.find(opt => opt.value === itemValue);
                            }
                          }
                          
                          // Strategy 5: Match by alternative spellings (data-alternative-spellings attribute)
                          if (!matchedOption) {
                            // Check if any option has alternative spellings that match
                            matchedOption = selectOptions.find(opt => {
                              const altSpellings = opt.getAttribute('data-alternative-spellings');
                              if (altSpellings) {
                                const altSpellingsLower = altSpellings.toLowerCase();
                                return altSpellingsLower.includes(selectedTextLower) || 
                                       selectedTextLower.includes(altSpellingsLower);
                              }
                              return false;
                            });
                          }
                          
                          // Strategy 6: Fuzzy match (remove special characters and compare)
                          if (!matchedOption) {
                            const cleanSelected = selectedTextLower.replace(/[^a-z0-9\s]/g, '');
                            matchedOption = selectOptions.find(opt => {
                              const optText = opt.textContent.trim().toLowerCase().replace(/[^a-z0-9\s]/g, '');
                              return optText.includes(cleanSelected) || cleanSelected.includes(optText);
                            });
                          }
                          
                          if (matchedOption) {
                            // Update the hidden SELECT value
                            hiddenSelect.value = matchedOption.value;
                            
                            // Dispatch comprehensive events to trigger form validation
                            hiddenSelect.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                            hiddenSelect.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                            
                            // Also trigger on the input field to ensure jQuery UI autocomplete is updated
                            el.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                            el.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                            
                            // Wait a bit for form validation to process
                            await new Promise(resolve => setTimeout(resolve, 300));
                            
                            console.log(`‚úÖ [${stepIndex}] fillAndSelect: Updated hidden SELECT with option: "${matchedOption.textContent.trim()}" (value="${matchedOption.value}")`);
                            
                            // Verify the value was set correctly
                            if (hiddenSelect.value === matchedOption.value) {
                              console.log(`‚úÖ [${stepIndex}] fillAndSelect: Verified SELECT value is correctly set to "${hiddenSelect.value}"`);
                            } else {
                              console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: SELECT value verification failed. Expected "${matchedOption.value}", got "${hiddenSelect.value}"`);
                              // Force set it again
                              hiddenSelect.value = matchedOption.value;
                              hiddenSelect.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                            }
                            
                            // Additional step: Trigger form validation to update submit button state
                            // Some forms use validation libraries that need explicit triggers
                            const form = hiddenSelect.closest('form');
                            if (form) {
                              // Trigger validation events on the form
                              form.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                              form.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                              
                              // Also try triggering on the form group
                              const formGroup = hiddenSelect.closest('.form-group');
                              if (formGroup) {
                                formGroup.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                                formGroup.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                              }
                              
                              // Wait a bit more for validation to process
                              await new Promise(resolve => setTimeout(resolve, 200));
                              
                              console.log(`‚úÖ [${stepIndex}] fillAndSelect: Triggered form validation events`);
                            }
                          } else {
                            console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: Found hidden SELECT but no matching option found for "${selectedText}"`);
                            console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: Available options: ${selectOptions.slice(0, 5).map(opt => `"${opt.textContent.trim()}"`).join(', ')}${selectOptions.length > 5 ? '...' : ''}`);
                          }
                        } else {
                          // Log that we tried to find a hidden SELECT but couldn't
                          console.log(`‚ÑπÔ∏è [${stepIndex}] fillAndSelect: No hidden SELECT element found (this is OK if not using autocomplete pattern)`);
                        }
                        
                        // Visual feedback
                        selectedItem.style.border = "2px solid #4CAF50";
                        selectedItem.style.backgroundColor = "#E8F5E9";
                        el.style.border = "2px solid #4CAF50";
                        
                        highlightElement(el, stepIndex, 'Filled', selectedItem.textContent.trim());
                        fillAndSelectResult = { success: true };
                      } else {
                        console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: Suggestions container found but no items available`);
                        fillAndSelectResult = { success: false, error: 'No suggestion items found in dropdown' };
                      }
                    } else {
                      console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: No suggestions dropdown appeared after ${maxWaitTime}ms`);
                      fillAndSelectResult = { success: false, error: 'Suggestions dropdown did not appear' };
                    }
                  }
                  
                  // Handle SELECT elements
                  else if (el.tagName === 'SELECT') {
                    const options = Array.from(el.options);
                    let matchedOption = null;
                    
                    console.log(`   ‚Ä¢ Available options: ${options.map(opt => `"${opt.textContent}" (value="${opt.value}")`).join(', ')}`);
                    
                    // Strategy 1: Try matching by VALUE first (if searchValue is numeric or matches an option value)
                    const valueMatch = options.find(option => {
                      const optionValue = String(option.value).trim();
                      const searchValueStr = String(searchValue).trim();
                      return optionValue === searchValueStr;
                    });
                    
                    if (valueMatch) {
                      matchedOption = valueMatch;
                      console.log(`‚úÖ [${stepIndex}] Matched by VALUE: "${searchValue}" ‚Üí option "${valueMatch.textContent}" (value="${valueMatch.value}")`);
                    }
                    
                    // Strategy 2: If no value match, try exact text match (case-insensitive)
                    if (!matchedOption) {
                      matchedOption = options.find(option => 
                        option.textContent.trim().toLowerCase() === searchValue.toLowerCase()
                      );
                      if (matchedOption) {
                        console.log(`‚úÖ [${stepIndex}] Matched by EXACT TEXT: "${searchValue}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                      }
                    }
                    
                    // Strategy 3: If no exact match, try partial text match
                    if (!matchedOption) {
                      matchedOption = options.find(option => 
                        option.textContent.trim().toLowerCase().includes(searchValue.toLowerCase()) ||
                        searchValue.toLowerCase().includes(option.textContent.trim().toLowerCase())
                      );
                      if (matchedOption) {
                        console.log(`‚úÖ [${stepIndex}] Matched by PARTIAL TEXT: "${searchValue}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                      }
                    }
                    
                    // Strategy 4: If still no match, try fuzzy matching (remove spaces, special chars)
                    if (!matchedOption) {
                      const cleanSearchValue = searchValue.toLowerCase().replace(/[^a-z0-9]/g, '');
                      matchedOption = options.find(option => {
                        const cleanOptionText = option.textContent.trim().toLowerCase().replace(/[^a-z0-9]/g, '');
                        return cleanOptionText.includes(cleanSearchValue) || cleanSearchValue.includes(cleanOptionText);
                      });
                      if (matchedOption) {
                        console.log(`‚úÖ [${stepIndex}] Matched by FUZZY TEXT: "${searchValue}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                      }
                    }
                    
                    if (matchedOption) {
                      el.value = matchedOption.value;
                      el.dispatchEvent(new Event("change", { bubbles: true }));
                      el.dispatchEvent(new Event("input", { bubbles: true }));
                      el.dispatchEvent(new Event("blur", { bubbles: true }));
                      el.style.border = "2px solid #4CAF50";
                      console.log(`‚úÖ [${stepIndex}] fillAndSelect: Selected option "${matchedOption.textContent}" (value="${matchedOption.value}") for search value "${searchValue}"`);
                      highlightElement(el, stepIndex, 'Filled', matchedOption.textContent);
                      fillAndSelectResult = { success: true };
                    } else {
                      const availableOptions = options.map(opt => `"${opt.textContent}" (value="${opt.value}")`).join(', ');
                      console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: No matching option found for "${searchValue}"`);
                      console.warn(`   ‚Ä¢ Tried: value match, exact text, partial text, fuzzy text`);
                      console.warn(`   ‚Ä¢ Available options: ${availableOptions}`);
                      el.style.border = "2px solid #FF9800"; // Orange border to indicate warning
                      fillAndSelectResult = { success: false, error: `No matching option found for "${searchValue}"` };
                    }
                  }
                  
                  // Handle UL/LI elements (list items)
                  else if (el.tagName === 'UL' || (el.tagName === 'LI' && el.parentElement && el.parentElement.tagName === 'UL')) {
                    const ulElement = el.tagName === 'UL' ? el : el.parentElement;
                    const listItems = Array.from(ulElement.querySelectorAll('li'));
                    let matchedItem = null;
                    
                    console.log(`   ‚Ä¢ Available list items: ${listItems.map(li => `"${li.textContent.trim()}"`).join(', ')}`);
                    
                    // Strategy 1: Exact text match (case-insensitive)
                    matchedItem = listItems.find(li => 
                      li.textContent.trim().toLowerCase() === searchValue.toLowerCase()
                    );
                    if (matchedItem) {
                      console.log(`‚úÖ [${stepIndex}] Matched by EXACT TEXT: "${searchValue}" ‚Üí "${matchedItem.textContent.trim()}"`);
                    }
                    
                    // Strategy 2: Partial text match
                    if (!matchedItem) {
                      matchedItem = listItems.find(li => 
                        li.textContent.trim().toLowerCase().includes(searchValue.toLowerCase()) ||
                        searchValue.toLowerCase().includes(li.textContent.trim().toLowerCase())
                      );
                      if (matchedItem) {
                        console.log(`‚úÖ [${stepIndex}] Matched by PARTIAL TEXT: "${searchValue}" ‚Üí "${matchedItem.textContent.trim()}"`);
                      }
                    }
                    
                    // Strategy 3: Fuzzy match
                    if (!matchedItem) {
                      const cleanSearchValue = searchValue.toLowerCase().replace(/[^a-z0-9]/g, '');
                      matchedItem = listItems.find(li => {
                        const cleanItemText = li.textContent.trim().toLowerCase().replace(/[^a-z0-9]/g, '');
                        return cleanItemText.includes(cleanSearchValue) || cleanSearchValue.includes(cleanItemText);
                      });
                      if (matchedItem) {
                        console.log(`‚úÖ [${stepIndex}] Matched by FUZZY TEXT: "${searchValue}" ‚Üí "${matchedItem.textContent.trim()}"`);
                      }
                    }
                    
                    if (matchedItem) {
                      // If the matched item contains a checkbox, tick it instead of just clicking the LI
                      let matchedCheckbox = matchedItem.querySelector
                        ? matchedItem.querySelector('input[type="checkbox"]')
                        : null;
                      if (!matchedCheckbox && matchedItem.closest) {
                        const labelEl = matchedItem.closest('label');
                        if (labelEl) {
                          matchedCheckbox = labelEl.querySelector('input[type="checkbox"]');
                        }
                      }
                      if (!matchedCheckbox && matchedItem.closest) {
                        const liEl = matchedItem.closest('li');
                        if (liEl) {
                          matchedCheckbox = liEl.querySelector('input[type="checkbox"]');
                        }
                      }
                      if (!matchedCheckbox) {
                        // Fallback: try to find checkbox by label text within the list container
                        matchedCheckbox = findCheckboxByText(searchValue, matchedItem.parentElement || matchedItem);
                      }

                      if (matchedCheckbox) {
                        matchedCheckbox.checked = true;
                        matchedCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
                        matchedCheckbox.dispatchEvent(new Event('click', { bubbles: true }));
                        console.log(`‚úÖ [${stepIndex}] fillAndSelect: Ticked checkbox for "${matchedItem.textContent.trim()}"`);
                        highlightElement(matchedCheckbox, stepIndex, 'Checked', matchedItem.textContent.trim());
                        fillAndSelectResult = { success: true };
                      } else {
                        // Click the matched list item
                        matchedItem.click();
                        matchedItem.style.border = "2px solid #4CAF50";
                        matchedItem.style.backgroundColor = "#E8F5E9";
                        console.log(`‚úÖ [${stepIndex}] fillAndSelect: Clicked list item "${matchedItem.textContent.trim()}" for search value "${searchValue}"`);
                        highlightElement(matchedItem, stepIndex, 'Selected', matchedItem.textContent.trim());
                        fillAndSelectResult = { success: true };
                      }
                    } else {
                      const availableItems = listItems.map(li => `"${li.textContent.trim()}"`).join(', ');
                      console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect: No matching list item found for "${searchValue}"`);
                      console.warn(`   ‚Ä¢ Available items: ${availableItems}`);
                      fillAndSelectResult = { success: false, error: `No matching list item found for "${searchValue}"` };
                    }
                  }
                  
                  // Handle checkbox list containers (e.g., multi-category checkboxes)
                  else if (el.querySelectorAll && el.querySelectorAll('input[type="checkbox"]').length > 0) {
                    console.log(`üîç [${stepIndex}] fillAndSelect: Detected checkbox list, matching: "${searchValue}"`);
                    fillAndSelectResult = tickCheckboxesByText(el, searchValue, stepIndex);
                  }
                  
                  // If element is not SELECT/UL/LI/checkbox list, log warning and continue with normal fill
                  else {
                    console.warn(`‚ö†Ô∏è [${stepIndex}] fillAndSelect is enabled but element is not a SELECT, UL/LI, or checkbox list (tagName: ${el.tagName}). Using normal fill.`);
                    fillAndSelectResult = null; // Allow normal fill to proceed
                  }
                  
                  // Handle fillAndSelect result
                  if (fillAndSelectResult !== null) {
                    if (fillAndSelectResult.success) {
                      // Successfully matched and selected
                      return fillAndSelectResult;
                    } else {
                      // No match found - return error (don't continue to normal fill)
                      if (canSkip === true) {
                        console.log(`‚è≠Ô∏è [${stepIndex}] Skipping step (canSkip: true) - fillAndSelect failed: ${fillAndSelectResult.error}`);
                        return { success: true, skipped: true };
                      }
                      return fillAndSelectResult;
                    }
                  }
                  // If fillAndSelectResult is null, continue to normal fill below
                }
                
                // employeesBox: detect range (e.g. "10-50") and pick a value to fill
                const isEmployeesBoxField = trimmedValueKey === 'employeesBox' ||
                  (alternative && (getAlternativeValueKey(alternative) === 'employeesBox' || alternative === 'employeesBox' || alternative === 'Number of Employees'));
                if (isEmployeesBoxField && val != null && val !== '') {
                  val = processEmployeesBoxValue(val, stepIndex);
                }
                
                // Enhanced filling logic for required vs optional fields
                const fillDelay = required ? 200 : 100; // Longer delay for required fields
                const validationDelay = required ? 300 : 200; // Longer validation delay for required fields
                
                console.log(`üîç [${stepIndex}] Filling ${required ? 'required' : 'optional'} ${el.tagName.toLowerCase()} field: ${selector} with: "${val}"`);
                
                // Element-specific fill logic
                const fillResult = await fillElementByType(el, val, stepIndex, required, fillDelay, validationDelay);
                
                // Execute once, then validate. Only retry when execution throws an error (handled by main loop).
                const isValid = fillResult.success;
                if (isValid) {
                  highlightElement(el, stepIndex, 'Filled', val);
                  console.log(`‚úÖ [${stepIndex}] Successfully filled ${required ? 'required' : 'optional'} field ${selector} with: "${val}"`);
                  if (fillAndEnter === true && el) {
                    await new Promise(resolve => setTimeout(resolve, 80));
                    dispatchEnterKeyOnElement(el, stepIndex);
                  }
                  return { success: true };
                } else {
                  // For optional + fillAndEnter: still send Enter so typeahead can accept the value
                  if (!required && fillAndEnter === true && el) {
                    await new Promise(resolve => setTimeout(resolve, 80));
                    dispatchEnterKeyOnElement(el, stepIndex);
                  }
                  console.warn(`‚ö†Ô∏è [${stepIndex}] Field fill validation failed for ${selector} - no retry on validation failure`);
                  return { success: false, error: required ? 'Required field fill validation failed' : 'Optional field fill validation failed' };
                }
              } else {
                // Handle missing or empty values (including whitespace-only)
                if (isEmptyValue && val && typeof val === 'string') {
                  // Value exists but is only whitespace
                  console.log(`üîç [${stepIndex}] Value is whitespace-only: "${val}" (length: ${val.length})`);
                }
                
                // Check if mode is "required" - if so, try fallback before skipping
                if (mode === 'required' && (fallbackType || alternative || directValue)) {
                  const normalizedFallbackType = fallbackType ? String(fallbackType).toLowerCase().trim() : null;
                  
                  if (normalizedFallbackType === 'directvalue' && directValue !== undefined && directValue !== null) {
                    val = String(directValue);
                    console.log(`üîÑ [${stepIndex}] Mode is "required" - using directValue fallback: "${val}"`);
                    // Re-check if value is now valid and proceed to fill
                    const newIsEmptyValue = !val || (typeof val === 'string' && val.trim().length === 0);
                    if (!newIsEmptyValue) {
                      // Value is now available, continue to fill logic
                      const fillDelay = required ? 200 : 100;
                      const validationDelay = required ? 300 : 200;
                      console.log(`üîç [${stepIndex}] Filling ${required ? 'required' : 'optional'} ${el.tagName.toLowerCase()} field: ${selector} with fallback: "${val}"`);
                      const fillResult = await fillElementByType(el, val, stepIndex, required, fillDelay, validationDelay);
                      if (fillResult.success) {
                        highlightElement(el, stepIndex, 'Filled (fallback)', val);
                        console.log(`‚úÖ [${stepIndex}] Successfully filled field ${selector} with fallback value: "${val}"`);
                        if (fillAndEnter === true && el) {
                          await new Promise(resolve => setTimeout(resolve, 80));
                          dispatchEnterKeyOnElement(el, stepIndex);
                        }
                        return { success: true };
                      }
                    }
                  } else if (normalizedFallbackType !== 'directvalue' && alternative) {
                    // Try alternative key lookup
                    const alternativeValueKey = getAlternativeValueKey(alternative);
                    if (alternativeValueKey) {
                      val = flatData[alternativeValueKey] || '';
                    } else {
                      val = flatData[alternative] || '';
                    }
                    if (val) {
                      // employeesBox: detect range and pick value
                      if ((alternativeValueKey === 'employeesBox' || alternative === 'employeesBox' || alternative === 'Number of Employees') && val) {
                        val = processEmployeesBoxValue(val, stepIndex);
                      }
                      console.log(`üîÑ [${stepIndex}] Mode is "required" - using alternative fallback: "${val}"`);
                      const newIsEmptyValue = !val || (typeof val === 'string' && val.trim().length === 0);
                      if (!newIsEmptyValue) {
                        const fillDelay = required ? 200 : 100;
                        const validationDelay = required ? 300 : 200;
                        console.log(`üîç [${stepIndex}] Filling ${required ? 'required' : 'optional'} ${el.tagName.toLowerCase()} field: ${selector} with fallback: "${val}"`);
                        const fillResult = await fillElementByType(el, val, stepIndex, required, fillDelay, validationDelay);
                        if (fillResult.success) {
                          highlightElement(el, stepIndex, 'Filled (fallback)', val);
                          console.log(`‚úÖ [${stepIndex}] Successfully filled field ${selector} with fallback value: "${val}"`);
                          if (fillAndEnter === true && el) {
                            await new Promise(resolve => setTimeout(resolve, 80));
                            dispatchEnterKeyOnElement(el, stepIndex);
                          }
                          return { success: true };
                        }
                      }
                    }
                  }
                }
                
                // Even if valueKey is empty, clear the field instead of skipping
                // This ensures the field is cleared even when no value is provided
                console.log(`üßπ [${stepIndex}] valueKey is empty or value is empty - clearing field instead of skipping: ${selector}`);
                
                try {
                  // Clear the field based on element type
                  if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                    el.value = '';
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                    el.dispatchEvent(new Event('blur', { bubbles: true }));
                  } else if (el.isContentEditable || el.contentEditable === 'true') {
                    el.textContent = '';
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                  } else if (el.tagName === 'SELECT') {
                    // For SELECT, set to first option or empty value
                    if (el.options.length > 0) {
                      el.selectedIndex = 0;
                    }
                    el.dispatchEvent(new Event('change', { bubbles: true }));
                  }
                  
                  // Update flatData if valueKey exists in flatData
                  if (flatData && trimmedValueKey) {
                    flatData[trimmedValueKey] = '';
                    console.log(`üìù [${stepIndex}] Updated flatData["${trimmedValueKey}"] to empty string`);
                  }
                  
                  console.log(`‚úÖ [${stepIndex}] Successfully cleared field (valueKey was empty): ${selector}`);
                  highlightElement(el, stepIndex, 'Cleared (empty valueKey)', '');
                  
                  if (required) {
                    console.error(`‚ùå [${stepIndex}] Required field missing value for valueKey: ${trimmedValueKey} (field cleared)`);
                    return { success: false, error: `Required value missing for key: ${trimmedValueKey}` };
                  } else {
                    return { success: true }; // Return success to continue to next step
                  }
                } catch (error) {
                  console.error(`‚ùå [${stepIndex}] Error clearing field:`, error);
                  if (required) {
                    return { success: false, error: `Required value missing for key: ${trimmedValueKey} and failed to clear field` };
                  } else {
                    return { success: true }; // Return success even if clearing failed for optional fields
                  }
                }
              }
            }
            break;
            
          case 'click':
            // Resolve value for findAndClick based on value/valueKey
            let clickVal = value;
            if (fillType === 'valueKey' && trimmedValueKey) {
              clickVal = flatData[trimmedValueKey] || '';
            } else if ((!clickVal || clickVal === '') && trimmedValueKey && fillType !== 'userInput') {
              clickVal = flatData[trimmedValueKey] || '';
            }
            if (isCategoryField) {
              const requiredCategory = await getRequiredCategoryFromAutomation(stepIndex);
              if (requiredCategory) {
                console.log(`üìã [${stepIndex}] Click: requiredCategory = true - getting mainCategory from citations (valueKey: ${trimmedValueKey})`);
                clickVal = await getMainCategoryFromCitations(stepIndex);
                console.log(`üìã [${stepIndex}] Click: mainCategory from citations = "${clickVal}"`);
              }
            }
            const searchValue = String(clickVal || '').trim();
            if (!el && !selector) {
              const parentSelectorsArray = parentSelectors && Array.isArray(parentSelectors) && parentSelectors.length > 0
                ? parentSelectors
                : (parentSelector ? [parentSelector] : null);
              if (parentSelectorsArray && parentSelectorsArray.length > 0) {
                for (const parentSel of parentSelectorsArray) {
                  if (!parentSel || typeof parentSel !== 'string') continue;
                  const parentEl = document.querySelector(parentSel);
                  if (parentEl) {
                    el = parentEl;
                    console.log(`‚úÖ [${stepIndex}] Click: using parent selector "${parentSel}" as target`);
                    break;
                  }
                }
              }
            }
            if (findAndClick === true && (!el || !isClickableElement(el))) {
              if (searchValue) {
                console.log(`üîç [${stepIndex}] findAndClick enabled - searching for clickable element by text: "${searchValue}"`);

                const parentSelectorsArray = parentSelectors && Array.isArray(parentSelectors) && parentSelectors.length > 0
                  ? parentSelectors
                  : (parentSelector ? [parentSelector] : null);

                let foundClickable = null;
                let foundCheckbox = null;
                const exactOnly = false;
                // Resolve category list structure: step config ('checkbox'|'button'|'auto') or auto-detect from first parent
                let categoryStructure = (stepCategoryListStructure && typeof stepCategoryListStructure === 'string')
                  ? stepCategoryListStructure.trim().toLowerCase() : 'auto';
                let firstParentEl = null;
                if (parentSelectorsArray && parentSelectorsArray.length > 0) {
                  for (const parentSel of parentSelectorsArray) {
                    if (!parentSel || typeof parentSel !== 'string') continue;
                    const parentEl = document.querySelector(parentSel);
                    if (!parentEl) continue;
                    firstParentEl = firstParentEl || parentEl;
                    if (categoryStructure === 'auto') {
                      const detected = detectCategoryListStructure(parentEl);
                      categoryStructure = detected === 'button-list' ? 'button' : 'checkbox';
                      console.log(`üèóÔ∏è [${stepIndex}] findAndClick category structure: ${categoryStructure} (detected: ${detected})`);
                    }
                    const checkboxFirst = categoryStructure !== 'button';
                    if (checkboxFirst) {
                      foundCheckbox = findCheckboxByText(searchValue, parentEl, exactOnly);
                      if (foundCheckbox) break;
                      foundClickable = findClickableElementByText(searchValue, parentEl, exactOnly);
                      if (foundClickable) break;
                    } else {
                      foundClickable = findClickableElementByText(searchValue, parentEl, exactOnly);
                      if (foundClickable) break;
                      foundCheckbox = findCheckboxByText(searchValue, parentEl, exactOnly);
                      if (foundCheckbox) break;
                    }
                  }
                }
                if (!foundCheckbox) {
                  foundCheckbox = findCheckboxByText(searchValue, document, exactOnly);
                }
                if (!foundClickable) {
                  foundClickable = findClickableElementByText(searchValue, document, exactOnly);
                }

                if (foundCheckbox) {
                  el = foundCheckbox;
                  console.log(`‚úÖ [${stepIndex}] findAndClick found checkbox for "${searchValue}"`);
                } else if (foundClickable) {
                  el = foundClickable;
                  console.log(`‚úÖ [${stepIndex}] findAndClick found element: ${el.tagName.toLowerCase()} for "${searchValue}"`);
                } else {
                  console.warn(`‚ö†Ô∏è [${stepIndex}] findAndClick could not find clickable element for "${searchValue}"`);
                  el = null;
                  return { success: false, error: `findAndClick could not find clickable element for "${searchValue}"` };
                }
              } else {
                console.warn(`‚ö†Ô∏è [${stepIndex}] findAndClick enabled but no search value found`);
              }
            }

            if (el) {
              if (el.tagName && el.tagName.toLowerCase() === 'input' && el.type === 'checkbox') {
                const label = el.closest('label');
                const labelText = label ? label.textContent.trim() : '';
                el.checked = true;
                el.dispatchEvent(new Event('change', { bubbles: true }));
                el.dispatchEvent(new Event('click', { bubbles: true }));
                highlightElement(el, stepIndex, 'Checked', labelText || '');
                await new Promise(resolve => setTimeout(resolve, 100));
                break;
              }

              // Highlight element before clicking
              highlightElement(el, stepIndex, 'Clicking', '');
              
              // Add small delay before clicking
              await new Promise(resolve => setTimeout(resolve, 100));
              
              // Simulate real mouse click (works with any element type: button, span, div, etc.)
              console.log(`üñ±Ô∏è [${stepIndex}] Simulating mouse click on ${el.tagName.toLowerCase()} element: ${selector}`);
              const clickSuccess = await simulateMouseClick(el);
              
              if (clickSuccess) {
                console.log(`‚úÖ [${stepIndex}] Successfully clicked ${el.tagName.toLowerCase()} element: ${selector}`);
              } else {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Mouse click simulation may have failed, but continuing...`);
              }
              
              // Add delay after clicking
              await new Promise(resolve => setTimeout(resolve, 200));
              
              // Handle waitToClosePopup - wait for popup/modal to close after clicking
              if (waitToClosePopup === true) {
                console.log(`‚è≥ [${stepIndex}] waitToClosePopup enabled - waiting for popup/modal to close...`);
                
                // Helper function to check if popup/modal is present
                const isPopupPresent = () => {
                  // Common popup/modal selectors
                  const popupSelectors = [
                    '.modal',
                    '.modal-dialog',
                    '.modal-content',
                    '.popup',
                    '.popup-content',
                    '.dialog',
                    '.overlay',
                    '[role="dialog"]',
                    '[class*="modal"]',
                    '[class*="popup"]',
                    '[class*="dialog"]',
                    '[class*="overlay"]',
                    '.modal-backdrop',
                    '.modal-overlay'
                  ];
                  
                  for (const popupSelector of popupSelectors) {
                    const elements = document.querySelectorAll(popupSelector);
                    // Check if any element is visible (not hidden)
                    for (const element of elements) {
                      const style = window.getComputedStyle(element);
                      const rect = element.getBoundingClientRect();
                      const isVisible = style.display !== 'none' && 
                                     style.visibility !== 'hidden' && 
                                     style.opacity !== '0' &&
                                     rect.width > 0 && 
                                     rect.height > 0;
                      
                      if (isVisible) {
                        console.log(`üîç [${stepIndex}] Popup/modal found: ${popupSelector}`);
                        return true;
                      }
                    }
                  }
                  
                  return false;
                };
                
                // Wait for popup to close with timeout
                const waitForPopupClose = async (maxWaitTime = 10000, checkInterval = 200) => {
                  const startTime = Date.now();
                  let wasPresent = false;
                  
                  return new Promise((resolve) => {
                    const checkPopup = () => {
                      const elapsed = Date.now() - startTime;
                      const isPresent = isPopupPresent();
                      
                      // Track if popup was ever present
                      if (isPresent) {
                        wasPresent = true;
                      }
                      
                      // If popup is not present and it was previously present, it has closed
                      if (!isPresent && wasPresent) {
                        console.log(`‚úÖ [${stepIndex}] Popup/modal closed (waited ${elapsed}ms)`);
                        resolve(true);
                        return;
                      }
                      
                      // If popup was never present, it might have closed immediately or never appeared
                      if (!isPresent && !wasPresent && elapsed > 500) {
                        // Wait a bit to see if popup appears, then consider it already closed
                        console.log(`‚úÖ [${stepIndex}] No popup/modal detected after ${elapsed}ms - considering already closed`);
                        resolve(true);
                        return;
                      }
                      
                      // Check timeout
                      if (elapsed > maxWaitTime) {
                        console.warn(`‚è∞ [${stepIndex}] Timeout waiting for popup/modal to close (${elapsed}ms)`);
                        resolve(false);
                        return;
                      }
                      
                      // Continue checking
                      setTimeout(checkPopup, checkInterval);
                    };
                    
                    // Start checking after a small delay to allow popup to appear
                    setTimeout(checkPopup, checkInterval);
                  });
                };
                
                // Wait for popup to close
                const popupClosed = await waitForPopupClose(10000, 200);
                
                if (popupClosed) {
                  console.log(`‚úÖ [${stepIndex}] Popup/modal closed successfully`);
                } else {
                  console.warn(`‚ö†Ô∏è [${stepIndex}] Popup/modal did not close within timeout, continuing anyway...`);
                }
              }
              
              // Handle NextButtonSave: no page-state checking; signal next step to wait for its target element
              if (valueKey === 'NextButtonSave') {
                console.log(`üéØ [NextButtonSave] Button clicked - next step will wait for its target (textbox/button) before executing`);
                window.__NEXT_BUTTON_SAVE_PENDING__ = true;
                setResumeIndex(stepIndex + 1);
                console.log(`‚úÖ [NextButtonSave] Resume index updated to ${stepIndex + 1}`);
                await new Promise(function(r) { setTimeout(r, 1500); }); // Short delay after click
                return { success: true };
              }
              
              // For ALL successful clicks: persist resume index (domain + current run) so that if the click
              // causes navigation/reload, the new page loads with the correct next step index.
              setResumeIndex(stepIndex + 1);
              console.log(`‚úÖ [${stepIndex}] Click success - resume index updated to ${stepIndex + 1} (prevents re-execute on page load)`);
              return { success: true };
            }
            break;
            
          case 'uploadImages':
            // If element not found and canSkip is true, skip the step
            if (!el) {
              if (canSkip === true) {
                console.log(`‚è≠Ô∏è [${stepIndex}] Skipping uploadImages step (canSkip: true) - Element not found: ${selector}`);
                return { success: true, skipped: true };
              }
              console.error(`‚ùå [${stepIndex}] Element not found: ${selector}`);
              return { success: false, error: `Element not found: ${selector}` };
            }
            
            if (el) {
            // Check if element is a file input or a wrapper containing one
            let fileInput = null;
            let wrapperElement = null;
            
            if (el.tagName.toLowerCase() === 'input' && el.type === 'file') {
              // Direct file input
              fileInput = el;
              console.log(`‚úÖ [${stepIndex}] Found direct file input: ${selector}`);
            } else {
              // Check if it's a wrapper element (span, button, div, etc.) containing a file input
              console.log(`üîç [${stepIndex}] Element ${selector} is not a direct file input (tag: ${el.tagName}), searching for file input inside...`);
              
              // Try to find file input within the element or its parent
              fileInput = el.querySelector('input[type="file"]');
              
              // If not found, check parent elements
              if (!fileInput) {
                let parent = el.parentElement;
                let depth = 0;
                while (parent && depth < 3) { // Search up to 3 levels up
                  fileInput = parent.querySelector('input[type="file"]');
                  if (fileInput) {
                    console.log(`‚úÖ [${stepIndex}] Found file input in parent element (depth: ${depth})`);
                    wrapperElement = el; // Keep reference to wrapper for clicking
                    break;
                  }
                  parent = parent.parentElement;
                  depth++;
                }
              } else {
                wrapperElement = el; // Keep reference to wrapper
                console.log(`‚úÖ [${stepIndex}] Found file input inside wrapper element: ${el.tagName}`);
              }
              
              // If still not found, check siblings
              if (!fileInput && el.parentElement) {
                const siblings = Array.from(el.parentElement.children);
                for (const sibling of siblings) {
                  if (sibling.querySelector) {
                    fileInput = sibling.querySelector('input[type="file"]');
                    if (fileInput) {
                      wrapperElement = el;
                      console.log(`‚úÖ [${stepIndex}] Found file input in sibling element`);
                      break;
                    }
                  }
                }
              }
              
              // Last resort: search the entire document for a file input near this element
              if (!fileInput) {
                const allFileInputs = document.querySelectorAll('input[type="file"]');
                if (allFileInputs.length === 1) {
                  fileInput = allFileInputs[0];
                  wrapperElement = el;
                  console.log(`‚úÖ [${stepIndex}] Found single file input in document, using it`);
                } else if (allFileInputs.length > 1) {
                  // Try to find the closest one
                  let closestInput = null;
                  let minDistance = Infinity;
                  const elRect = el.getBoundingClientRect();
                  
                  for (const input of allFileInputs) {
                    const inputRect = input.getBoundingClientRect();
                    const distance = Math.abs(elRect.top - inputRect.top) + Math.abs(elRect.left - inputRect.left);
                    if (distance < minDistance) {
                      minDistance = distance;
                      closestInput = input;
                    }
                  }
                  
                  if (closestInput && minDistance < 500) { // Within reasonable distance
                    fileInput = closestInput;
                    wrapperElement = el;
                    console.log(`‚úÖ [${stepIndex}] Found closest file input (distance: ${minDistance}px)`);
                  }
                }
              }
            }
            
            // If still no file input found, return error
            if (!fileInput) {
              console.error(`‚ùå [${stepIndex}] No file input found for ${selector} (element tag: ${el.tagName})`);
              return { success: false, error: 'No file input element found' };
            }
            
            // Use the file input for upload operations
            el = fileInput;
            
            // If we have a wrapper element, click it first to trigger file picker (some sites require this)
            if (wrapperElement && wrapperElement !== fileInput) {
              console.log(`üñ±Ô∏è [${stepIndex}] Clicking wrapper element (${wrapperElement.tagName}) to trigger file picker...`);
              try {
                // Click the wrapper element
                wrapperElement.click();
                // Small delay to allow any handlers to process
                await new Promise(resolve => setTimeout(resolve, 100));
              } catch (error) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Error clicking wrapper element:`, error);
                // Continue anyway, the file assignment might still work
              }
            }
            
            // Get the required, mode, and alternative parameters from the step
            const { required = false, mode, alternative, imagesize } = step;
            
            // Check if step is required (either required=true or mode="required")
            const isRequired = required === true || mode === 'required';
            
            // Helper function to get campaign data if flatData is not available
            async function getCampaignDataValue(key) {
              // First try flatData if available
              if (typeof flatData !== 'undefined' && flatData !== null) {
                const value = flatData[key];
                if (value !== undefined && value !== null && String(value).trim() !== '') {
                  return String(value);
                }
              }
              
              // Fallback: Try to get from chrome.storage directly
              return new Promise((resolve) => {
                chrome.storage.local.get(['CampaignData'], (data) => {
                  if (chrome.runtime.lastError) {
                    console.warn(`‚ö†Ô∏è [${stepIndex}] Error accessing CampaignData:`, chrome.runtime.lastError);
                    resolve(null);
                    return;
                  }
                  
                  if (data.CampaignData) {
                    const campaignData = data.CampaignData;
                    let value = null;
                    
                    // Priority 1: Check CampaignData.base64Data[key] (for image data like logoBox)
                    if (campaignData.base64Data && campaignData.base64Data[key]) {
                      value = campaignData.base64Data[key];
                      console.log(`‚úÖ [${stepIndex}] Found ${key} in CampaignData.base64Data`);
                    }
                    // Priority 2: Check CampaignData.campaignData[key]
                    else if (campaignData.campaignData && campaignData.campaignData[key]) {
                      value = campaignData.campaignData[key];
                      console.log(`‚úÖ [${stepIndex}] Found ${key} in CampaignData.campaignData`);
                    }
                    // Priority 3: Check nested structure (first value)
                    else if (Object.keys(campaignData).length > 0) {
                      const firstValue = Object.values(campaignData)[0];
                      if (firstValue) {
                        // Try base64Data in nested structure
                        if (firstValue.base64Data && firstValue.base64Data[key]) {
                          value = firstValue.base64Data[key];
                          console.log(`‚úÖ [${stepIndex}] Found ${key} in nested base64Data`);
                        }
                        // Try campaignData in nested structure
                        else if (firstValue.campaignData && firstValue.campaignData[key]) {
                          value = firstValue.campaignData[key];
                          console.log(`‚úÖ [${stepIndex}] Found ${key} in nested campaignData`);
                        }
                        // Try direct access in nested structure
                        else if (firstValue[key]) {
                          value = firstValue[key];
                          console.log(`‚úÖ [${stepIndex}] Found ${key} in nested structure`);
                        }
                      }
                    }
                    // Priority 4: Try direct access on CampaignData
                    else if (campaignData[key]) {
                      value = campaignData[key];
                      console.log(`‚úÖ [${stepIndex}] Found ${key} directly in CampaignData`);
                    }
                    
                    if (value !== undefined && value !== null && String(value).trim() !== '') {
                      resolve(String(value));
                    } else {
                      console.log(`‚ö†Ô∏è [${stepIndex}] ${key} not found in any CampaignData path`);
                      resolve(null);
                    }
                  } else {
                    console.log(`‚ö†Ô∏è [${stepIndex}] CampaignData not found in storage`);
                    resolve(null);
                  }
                });
              });
            }
            
              // Try to get base64 data from flatData (CampaignData)
              let base64Data;
            let imageName = valueKey;
              
              console.log(`üîç [${stepIndex}] UploadImages - valueKey: ${valueKey}, alternative: ${alternative}, required: ${required}, mode: ${mode}, isRequired: ${isRequired}`);
            
            // Debug: Check if flatData exists and log available keys
            if (typeof flatData !== 'undefined' && flatData !== null) {
              const imageKeys = Object.keys(flatData).filter(k => 
                k.toLowerCase().includes('logo') || 
                k.toLowerCase().includes('image') ||
                k === valueKey ||
                (alternative && k === alternative)
              );
              console.log(`üîç [${stepIndex}] Available image-related keys in flatData:`, imageKeys);
              if (valueKey && flatData[valueKey] !== undefined) {
                const val = flatData[valueKey];
                console.log(`üîç [${stepIndex}] flatData["${valueKey}"] = ${val ? (typeof val === 'string' ? `"${val.substring(0, 50)}..." (length: ${val.length})` : String(val)) : 'undefined/null'}`);
              }
            } else {
              console.warn(`‚ö†Ô∏è [${stepIndex}] flatData is not available, will try direct storage access`);
            }
            
            // Support for multiple valueKeys separated by " + "
            if (valueKey && valueKey.includes(' + ')) {
              console.log(`üîç [${stepIndex}] Processing multiple valueKeys for image upload: ${valueKey}`);
              const keys = valueKey.split(' + ').map(k => k.trim());
              
              for (const key of keys) {
                let value = null;
                if (typeof flatData !== 'undefined' && flatData !== null) {
                  value = flatData[key];
                } else {
                  value = await getCampaignDataValue(key);
                }
                
                if (value !== undefined && value !== null && String(value).trim() !== '') {
                  base64Data = String(value);
                  imageName = key;
                  console.log(`   ‚úÖ Found image data for ${key} (length: ${base64Data.length})`);
                  break; // Use the first available image
                } else {
                  console.log(`   ‚ö†Ô∏è No image data found for ${key}`);
                }
              }
              } else {
                // Single valueKey
                if (typeof flatData !== 'undefined' && flatData !== null) {
                  base64Data = flatData[valueKey];
                } else {
                  base64Data = await getCampaignDataValue(valueKey);
                }
                
                if (base64Data) {
                  base64Data = String(base64Data);
                  console.log(`üîç [${stepIndex}] Retrieved base64Data for ${valueKey} (length: ${base64Data.length})`);
                } else {
                  console.log(`‚ö†Ô∏è [${stepIndex}] No base64Data found for ${valueKey}`);
                }
            }
            
            // If main value is empty and alternative is provided, try alternative
            // Only fallback to alternative if isRequired is true (required=true or mode="required")
            if ((!base64Data || (typeof base64Data === 'string' && base64Data.trim() === '')) && alternative && isRequired) {
                if (typeof flatData !== 'undefined' && flatData !== null) {
                  base64Data = flatData[alternative];
                } else {
                  base64Data = await getCampaignDataValue(alternative);
                }
                
                if (base64Data) {
                  base64Data = String(base64Data);
                  imageName = alternative;
                  console.log(`üîÑ [${stepIndex}] Using alternative image for ${selector}: ${alternative} (length: ${base64Data.length})`);
                } else {
                  console.log(`‚ö†Ô∏è [${stepIndex}] Alternative image ${alternative} is also empty`);
                }
            } else if ((!base64Data || (typeof base64Data === 'string' && base64Data.trim() === '')) && alternative && !isRequired) {
              console.log(`‚ÑπÔ∏è [${stepIndex}] Skipping alternative fallback (${alternative}) because step is not required (required: ${required}, mode: ${mode})`);
            }
              
              // Enhanced fallback logic for specific primary keys
            // Only fallback if isRequired is true (required=true or mode="required")
            if ((!base64Data || (typeof base64Data === 'string' && base64Data.trim() === '')) && isRequired) {
                let fallbackKey = null;
                
                // Check specific fallback mappings
                if (valueKey === 'logoBox') {
                  fallbackKey = 'logoalternative';
                  console.log(`üîÑ [${stepIndex}] logoBox is empty, trying fallback: ${fallbackKey}`);
                } else if (valueKey === 'image1Box') {
                  fallbackKey = 'image1alternative';
                  console.log(`üîÑ [${stepIndex}] image1Box is empty, trying fallback: ${fallbackKey}`);
                }
                
                // Try the specific fallback key
                if (fallbackKey) {
                  let fallbackValue = null;
                  if (typeof flatData !== 'undefined' && flatData !== null) {
                    fallbackValue = flatData[fallbackKey];
                  } else {
                    fallbackValue = await getCampaignDataValue(fallbackKey);
                  }
                  
                  if (fallbackValue && String(fallbackValue).trim() !== '') {
                    base64Data = String(fallbackValue);
                    imageName = fallbackKey;
                    console.log(`‚úÖ [${stepIndex}] Found fallback image data for ${fallbackKey} (length: ${base64Data.length})`);
                  } else {
                    console.log(`‚ö†Ô∏è [${stepIndex}] Fallback key ${fallbackKey} is also empty or not found`);
                  }
                }
            } else if ((!base64Data || (typeof base64Data === 'string' && base64Data.trim() === '')) && !isRequired) {
              console.log(`‚ÑπÔ∏è [${stepIndex}] Skipping fallback logic because step is not required (required: ${required}, mode: ${mode})`);
              }
            
            // If still no data and isRequired, log warning and continue
              if (!base64Data || (typeof base64Data === 'string' && base64Data.trim() === '')) {
              if (isRequired) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Required image missing for ${valueKey} (and alternative ${alternative})`);
                  return { success: false, error: 'Required image missing' };
              } else {
                console.log(`‚ÑπÔ∏è [${stepIndex}] Optional image not provided for ${valueKey}`);
              return { success: true };
            }
            }
            
            // Ensure base64Data is a string
            base64Data = String(base64Data);
            
            // Final validation: ensure we have valid base64 data
            if (!base64Data || base64Data.trim() === '') {
              if (isRequired) {
                console.error(`‚ùå [${stepIndex}] No base64 data available for ${valueKey}`);
                return { success: false, error: 'No base64 data available' };
              } else {
                console.log(`‚ÑπÔ∏è [${stepIndex}] Optional image not provided for ${valueKey}`);
                return { success: true };
              }
            }
            
            console.log(`üì§ [${stepIndex}] Preparing to upload image: ${imageName}`);
            console.log(`   ‚Ä¢ Base64 data length: ${base64Data.length}`);
            console.log(`   ‚Ä¢ Starts with data: URL: ${base64Data.startsWith('data:')}`);
            console.log(`   ‚Ä¢ Target element: ${selector}`);
            
            try {
              // Function to resize image
              const resizeImage = (base64Data, targetWidth, targetHeight) => {
                return new Promise((resolve, reject) => {
                  const img = new Image();
                  img.onload = () => {
                    try {
                      // Create canvas for resizing
                      const canvas = document.createElement('canvas');
                      const ctx = canvas.getContext('2d');
                      
                      // Set canvas dimensions
                      canvas.width = targetWidth;
                      canvas.height = targetHeight;
                      
                      // Calculate scaling to maintain aspect ratio
                      const scale = Math.min(targetWidth / img.width, targetHeight / img.height);
                      const scaledWidth = img.width * scale;
                      const scaledHeight = img.height * scale;
                      
                      // Center the image on canvas
                      const offsetX = (targetWidth - scaledWidth) / 2;
                      const offsetY = (targetHeight - scaledHeight) / 2;
                      
                      // Draw resized image
                      ctx.fillStyle = '#FFFFFF'; // White background
                      ctx.fillRect(0, 0, targetWidth, targetHeight);
                      ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                      
                      // Convert to base64
                      const resizedBase64 = canvas.toDataURL('image/jpeg', 0.9);
                      resolve(resizedBase64);
                    } catch (error) {
                      reject(error);
                    }
                  };
                  img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = base64Data.startsWith('data:') ? base64Data : `data:image/jpeg;base64,${base64Data}`;
                });
              };
              
              // Process image with resizing if specified
                let processedBase64 = base64Data;
              if (imagesize) {
                const [width, height] = imagesize.split('x').map(Number);
                if (width && height && width > 0 && height > 0) {
                  console.log(`üñºÔ∏è [${stepIndex}] Resizing image to ${width}x${height}px`);
                    processedBase64 = await resizeImage(base64Data, width, height);
                } else {
                  console.warn(`‚ö†Ô∏è [${stepIndex}] Invalid image size format: ${imagesize}. Expected format: "widthxheight"`);
                }
              }
              
                // Remove data URL prefix if present
                let cleanBase64 = processedBase64;
                if (processedBase64.startsWith('data:')) {
                  cleanBase64 = processedBase64.split(',')[1];
                }
                
                // Validate base64 string
                if (!cleanBase64 || cleanBase64.trim() === '') {
                  throw new Error('Empty base64 data after processing');
                }
                
                // Convert base64 to File
                let byteCharacters;
                try {
                  byteCharacters = atob(cleanBase64);
                } catch (error) {
                  throw new Error(`Invalid base64 data: ${error.message}`);
                }
                
                const byteArray = new Uint8Array([...byteCharacters].map(c => c.charCodeAt(0)));
                
                // Determine file type and name
                // Check original base64Data first (before resizing) to get the correct MIME type
                let fileType = 'image/jpeg'; // default
                let fileName = `${imageName}.jpg`; // default
                
                // Try to detect file type from original base64 data URL (before processing)
                const base64ToCheck = base64Data.startsWith('data:') ? base64Data : processedBase64;
                if (base64ToCheck.startsWith('data:')) {
                  const matches = base64ToCheck.match(/data:([^;]+);base64,/);
                  if (matches && matches[1]) {
                    fileType = matches[1];
                    const extension = fileType.split('/')[1] || 'jpg';
                    fileName = `${imageName}.${extension}`;
                    console.log(`üîç [${stepIndex}] Detected file type: ${fileType}, extension: ${extension}`);
                  }
                } else {
                  // If no data URL prefix, try to infer from file signature (magic bytes)
                  // PNG: 89 50 4E 47, JPEG: FF D8 FF
                  if (byteArray.length >= 4) {
                    if (byteArray[0] === 0x89 && byteArray[1] === 0x50 && byteArray[2] === 0x4E && byteArray[3] === 0x47) {
                      fileType = 'image/png';
                      fileName = `${imageName}.png`;
                      console.log(`üîç [${stepIndex}] Detected PNG from magic bytes`);
                    } else if (byteArray[0] === 0xFF && byteArray[1] === 0xD8 && byteArray[2] === 0xFF) {
                      fileType = 'image/jpeg';
                      fileName = `${imageName}.jpg`;
                      console.log(`üîç [${stepIndex}] Detected JPEG from magic bytes`);
                    }
                  }
                }
                
                const blob = new Blob([byteArray], { type: fileType });
                const file = new File([blob], fileName, { type: fileType });

                // Focus the element first
                el.focus();
                
                // Clear any existing files first
                el.value = '';
                
                // Assign file using DataTransfer (modern approach)
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                el.files = dataTransfer.files;
                
                // Dispatch events in the correct order to trigger all listeners
                // Many frameworks listen to 'input' event, not just 'change'
                el.dispatchEvent(new Event('focus', { bubbles: true, cancelable: true }));
                el.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                el.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                el.dispatchEvent(new Event('blur', { bubbles: true, cancelable: true }));
                
                // Also trigger a custom file input event for better compatibility
                const fileInputEvent = new Event('file', { bubbles: true, cancelable: true });
                el.dispatchEvent(fileInputEvent);
                
                // Verify the file was set correctly
                if (!el.files || el.files.length === 0) {
                  throw new Error('File was not set on input element');
                }
                
                if (el.files[0].size !== file.size) {
                  console.warn(`‚ö†Ô∏è [${stepIndex}] File size mismatch: expected ${file.size}, got ${el.files[0].size}`);
                }
                
                // Add visual feedback
                el.style.border = "2px solid #4CAF50";
                
                console.log(`‚úÖ [${stepIndex}] Uploaded image for ${selector} (${imageName}) - ${file.size} bytes, type: ${fileType}`);
              return { success: true };
            } catch (error) {
              console.error(`‚ùå [${stepIndex}] Error uploading image for ${valueKey}:`, error);
              if (required) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Required image upload failed for ${valueKey}`);
              }
                return { success: false, error: error.message };
              }
            }
            break;
            
          case 'consolidateData':
            console.log(`üîç [${stepIndex}] Consolidating data...`);
            try {
              // Just call the working consolidateData function directly
              const consolidatedContent = await consolidateData();
              
              if (consolidatedContent) {
                console.log(`‚úÖ [${stepIndex}] Data consolidated successfully`);
                return { success: true };
              } else {
                console.warn(`‚ö†Ô∏è [${stepIndex}] No consolidated content generated`);
                return { success: false, error: 'No consolidated content generated' };
              }
            } catch (error) {
              console.error(`‚ùå [${stepIndex}] Error consolidating data:`, error);
              return { success: false, error: error.message };
            }
            break;
            
          case 'injectToFroala':
            console.log(`üîç [${stepIndex}] Injecting consolidated data to rich text editor (supports: Froala, TinyMCE, Quill, Summernote, CKEditor 0-5, Redactor, Aloha, and generic contenteditable)...`);
            try {
              // Call the comprehensive injectConsolidatedDataToFroala function
              // This function now supports multiple editors including all CKEditor versions (0-5)
              const injectionResult = await injectConsolidatedDataToFroala();
              
              if (injectionResult) {
                console.log(`‚úÖ [${stepIndex}] Successfully injected consolidated data to rich text editor`);
                return { success: true };
              } else {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Failed to inject data to rich text editor (no supported editor found)`);
                return { success: false, error: 'Failed to inject data to rich text editor (no supported editor found)' };
              }
            } catch (error) {
              console.error(`‚ùå [${stepIndex}] Error injecting data to rich text editor:`, error);
              return { success: false, error: error.message };
            }
            break;
            
          case 'GoTo':
            if (link) {
              await setResumeIndexAndWait(stepIndex + 1);
              console.log(`‚úÖ [${stepIndex}] Saved resume index for GoTo: ${stepIndex + 1} (next step will be ${stepIndex + 2})`);
              window.location.href = link;
              return { success: true };
            }
            break;
            
          case 'formatHours':
            if (el) {
              // Highlight element before formatting
              highlightElement(el, stepIndex, 'Formatting Hours', '');
              
              console.log(`üïí [${stepIndex}] Formatting business hours with format: ${format || 'standard'}`);
              
              // Get business hours data from campaign data
              let businessHoursData = {};
              if (valueKey) {
                // Try to get the business hours data from the specified valueKey
                businessHoursData = flatData[valueKey] || {};
              } else {
                // If no valueKey specified, try to get individual day data
                const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
                days.forEach(day => {
                  const amKey = `${day}Am`;
                  const pmKey = `${day}Pm`;
                  if (flatData[amKey] || flatData[pmKey]) {
                    businessHoursData[amKey] = flatData[amKey] || '';
                    businessHoursData[pmKey] = flatData[pmKey] || '';
                  }
                });
              }
              
              if (Object.keys(businessHoursData).length === 0) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] No business hours data found for valueKey: ${valueKey}`);
                return { success: false, error: 'No business hours data found' };
              }
              
              // Format the business hours using the existing function
              const formattedHours = formatBusinessHours(businessHoursData, format || 'standard');
              
              if (formattedHours && formattedHours.trim() !== '') {
                // Clear the field first
                el.value = '';
                el.focus();
                
                // Fill with formatted hours
                el.value = formattedHours;
                
                // Trigger input events to ensure the field is properly updated
                el.dispatchEvent(new Event('input', { bubbles: true }));
                el.dispatchEvent(new Event('change', { bubbles: true }));
                
                console.log(`‚úÖ [${stepIndex}] Formatted business hours: "${formattedHours}"`);
                console.log(`üìù [${stepIndex}] Applied to element: ${selector}`);
              } else {
                console.warn(`‚ö†Ô∏è [${stepIndex}] No formatted hours generated`);
                return { success: false, error: 'No formatted hours generated' };
              }
            } else {
              // If element not found and canSkip is true, skip the step
              if (canSkip === true) {
                console.log(`‚è≠Ô∏è [${stepIndex}] Skipping formatHours step (canSkip: true) - Element not found: ${selector}`);
                return { success: true, skipped: true };
              }
              console.error(`‚ùå [${stepIndex}] Element not found: ${selector}`);
              return { success: false, error: `Element not found: ${selector}` };
            }
            break;
            
          case 'selectHours':
            // BUSINESS HOURS AUTOMATION ENGINE WITH AUTO-DETECTION
            // Check if we need to process business hours with automation rules
            const businessHoursStatus = flatData?.businessHoursStatus || step.businessHoursStatus;
            const siteConfig = step.siteConfig || {
              acceptSplitHours: step.acceptSplitHours,
              acceptHideSkipHours: step.acceptHideSkipHours,
              acceptOverlapHours: step.acceptOverlapHours
            };
            const normalizeAutomationRule = (ruleValue) => {
              if (!ruleValue) return null;
              const normalized = String(ruleValue).trim().toLowerCase();
              if (!normalized) return null;
              if (normalized === 'consolidate' || normalized === 'consolidatesplit' || normalized === 'consolidate_split') {
                return 'CONSOLIDATE_SPLIT';
              }
              if (normalized === 'hideandconsolidate' || normalized === 'hide_and_consolidate') {
                return 'HIDE_AND_CONSOLIDATE';
              }
              if (normalized === 'skipandconsolidate' || normalized === 'skip_and_consolidate') {
                return 'SKIP_AND_CONSOLIDATE';
              }
              if (normalized === 'consolidate-split') return 'CONSOLIDATE_SPLIT';
              if (normalized === 'hide-and-consolidate') return 'HIDE_AND_CONSOLIDATE';
              if (normalized === 'skip-and-consolidate') return 'SKIP_AND_CONSOLIDATE';
              return ruleValue;
            };
            const ruleFromList = Array.isArray(step.rules) ? step.rules[0] : null;
            const automationRule = normalizeAutomationRule(step.automationRule || step.rule || ruleFromList);
            const autoDetect = step.autoDetect !== false; // Default to true if not specified
            let hoursDataToUse = flatData;
            const contextElement = getHoursContextElement(el);
            if (contextElement && contextElement.id === 'hours-of-operation') {
              console.log(`‚úÖ [${stepIndex}] Found #hours-of-operation container, using as context`);
            }
            const detectedStructureType = detectHourStructure(contextElement);
            let applied24Hours = false;
            const shouldSkipOpenHoursTable = Array.isArray(step.rules) && step.rules.some(rule => String(rule).toLowerCase() === 'skip');
            const isOpeningHoursTable = Array.isArray(step.parentSelectors) && step.parentSelectors.some(selector => String(selector).includes('opening-hours'));
            if (shouldSkipOpenHoursTable && isOpeningHoursTable) {
              const descriptionHours = flatData?.businessHoursBox || flatData?.businessHours || flatData?.hours;
              appendBusinessHoursToDescription(flatData, descriptionHours, stepIndex);
              console.log(`‚ÑπÔ∏è [${stepIndex}] Skipping opening-hours table fill due to rule: skip`);
              return { success: true, skipped: true };
            }
            
            // AUTO-DETECTION MODE: If autoDetect is enabled, try to auto-detect and fill all hour fields
            if (autoDetect) {
              // Check if we have business hours data (either from status or direct data)
              const hasHoursData = businessHoursStatus || 
                (flatData && (
                  flatData.monAm || flatData.monPm || flatData.tueAm || flatData.tuePm ||
                  flatData.wedAm || flatData.wedPm || flatData.thuAm || flatData.thuPm ||
                  flatData.friAm || flatData.friPm || flatData.satAm || flatData.satPm ||
                  flatData.sunAm || flatData.sunPm
                ));
              
              if (hasHoursData) {
                console.log(`üîß [${stepIndex}] Business Hours Auto-Detection mode activated${businessHoursStatus ? ` - Status: ${businessHoursStatus}` : ''}`);
                
                try {
                  // Parse businessHoursBox into per-day fields before automation (supports split hours)
                  const rawHoursBox = hoursDataToUse.businessHoursBox || flatData.businessHoursBox;
                  if (rawHoursBox) {
                    const parsedHours = parseBusinessHoursBoxToData(rawHoursBox, hoursFormat);
                    Object.entries(parsedHours).forEach(([key, value]) => {
                      const existing = hoursDataToUse[key];
                      if (!existing || String(existing).trim() === '') {
                        hoursDataToUse[key] = value;
                        flatData[key] = value;
                      }
                    });
                  }

                  // Step 1: Process business hours with automation engine if status exists
                  if (businessHoursStatus) {
                    const processedHours = processBusinessHoursAutomation(
                      businessHoursStatus,
                      siteConfig,
                      automationRule,
                      flatData,
                      stepIndex
                    );
                    
                    if (processedHours && processedHours.success) {
                      console.log(`‚úÖ [${stepIndex}] Business hours processed successfully by automation engine`);
                      
                      // Update flatData with processed hours
                      if (processedHours.processedData && Object.keys(processedHours.processedData).length > 0) {
                        Object.assign(flatData, processedHours.processedData);
                        // Preserve raw fields (e.g., businessHoursBox) for closed-day detection
                        hoursDataToUse = { ...flatData, ...processedHours.processedData };
                      }
                    }
                  }
                  
                  // Normalize per-day values to the requested hoursFormat
                  if (hoursFormat === '12Hrs' || hoursFormat === '24Hrs') {
                    const dayKeys = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun', 'holiday'];
                    dayKeys.forEach(day => {
                      const amKey = day === 'holiday' ? 'holidayAm' : `${day}Am`;
                      const pmKey = day === 'holiday' ? 'holidayPm' : `${day}Pm`;
                      const am2Key = day === 'holiday' ? 'holidayAm2' : `${day}Am2`;
                      const pm2Key = day === 'holiday' ? 'holidayPm2' : `${day}Pm2`;
                      if (hoursDataToUse[amKey]) {
                        const normalized = normalizeTimeToFormat(hoursDataToUse[amKey], hoursFormat);
                        hoursDataToUse[amKey] = normalized;
                        flatData[amKey] = normalized;
                      }
                      if (hoursDataToUse[pmKey]) {
                        const normalized = normalizeTimeToFormat(hoursDataToUse[pmKey], hoursFormat);
                        hoursDataToUse[pmKey] = normalized;
                        flatData[pmKey] = normalized;
                      }
                      if (hoursDataToUse[am2Key]) {
                        const normalized = normalizeTimeToFormat(hoursDataToUse[am2Key], hoursFormat);
                        hoursDataToUse[am2Key] = normalized;
                        flatData[am2Key] = normalized;
                      }
                      if (hoursDataToUse[pm2Key]) {
                        const normalized = normalizeTimeToFormat(hoursDataToUse[pm2Key], hoursFormat);
                        hoursDataToUse[pm2Key] = normalized;
                        flatData[pm2Key] = normalized;
                      }
                    });
                  }

                  const hoursTextFor24 = getHoursTextFor24HourDetection(hoursDataToUse, flatData);
                  const detection24 = detect24HourOperation(hoursTextFor24, detectedStructureType, businessHoursStatus);
                  const normalized24 = apply24HourNormalization(
                    hoursDataToUse,
                    flatData,
                    detection24,
                    detectedStructureType,
                    contextElement,
                    stepIndex
                  );
                  applied24Hours = Boolean(normalized24);
                  if (!applied24Hours) {
                    normalizeMidnightPairsToFullDay(
                      hoursDataToUse,
                      flatData,
                      detectedStructureType,
                      businessHoursStatus,
                      hoursFormat,
                      stepIndex
                    );
                  }

                  // Step 2: Auto-detect and fill all hour fields on the page
                  console.log(`üîç [${stepIndex}] Starting auto-detection of hour fields...`);
                  const autoFillResult = await autoDetectAndFillHours(hoursDataToUse, stepIndex, contextElement);
                  
                  if (autoFillResult.success && autoFillResult.filledCount > 0) {
                    console.log(`‚úÖ [${stepIndex}] Auto-detection completed: ${autoFillResult.filledCount} hour field(s) filled automatically`);
                    
                    // If auto-detection filled fields and no specific selector provided, return success
                    if (!selector || !el) {
                      return { success: true, autoFilled: true, filledCount: autoFillResult.filledCount, details: autoFillResult.filledDetails };
                    }
                    // Otherwise, continue to fill the specific field as well (for backward compatibility)
                  } else {
                    console.warn(`‚ö†Ô∏è [${stepIndex}] Auto-detection found ${autoFillResult.detectedCount || 0} field(s) but filled ${autoFillResult.filledCount || 0}`);
                    
                    // If no fields were auto-filled and no selector provided, return error
                    if (!selector || !el) {
                      return { 
                        success: false, 
                        error: `No hour fields could be auto-filled (detected: ${autoFillResult.detectedCount || 0})`,
                        detectedCount: autoFillResult.detectedCount || 0
                      };
                    }
                    // Otherwise, continue with manual fill
                  }
                } catch (error) {
                  console.warn(`‚ö†Ô∏è [${stepIndex}] Business hours auto-detection error:`, error);
                  // Continue with normal flow if auto-detection fails
                }
              }
            }

            if (!applied24Hours) {
              const hoursTextFor24 = getHoursTextFor24HourDetection(hoursDataToUse, flatData);
              const detection24 = detect24HourOperation(hoursTextFor24, detectedStructureType, businessHoursStatus);
              const normalized24 = apply24HourNormalization(
                hoursDataToUse,
                flatData,
                detection24,
                detectedStructureType,
                contextElement,
                stepIndex
              );
              applied24Hours = Boolean(normalized24);
              if (!applied24Hours) {
                normalizeMidnightPairsToFullDay(
                  hoursDataToUse,
                  flatData,
                  detectedStructureType,
                  businessHoursStatus,
                  hoursFormat,
                  stepIndex
                );
              }
            }
            
            // Continue with normal selectHours flow if element exists
            if (el) {
              // Highlight element before selecting
              highlightElement(el, stepIndex, 'Selecting Hours', '');
              
              console.log(`‚è∞ [${stepIndex}] selectHours action - selector: ${selector}, valueKey: ${valueKey}`);
              
              // SMART MULTIPLE HOURS AUTOFILLING: Detect if this is part of a business hours form
              // and automatically fill all related hour fields
              const isBusinessHoursForm = selector && (
                selector.toLowerCase().includes('hour') ||
                selector.toLowerCase().includes('time') ||
                selector.toLowerCase().includes('monday') ||
                selector.toLowerCase().includes('tuesday') ||
                selector.toLowerCase().includes('wednesday') ||
                selector.toLowerCase().includes('thursday') ||
                selector.toLowerCase().includes('friday') ||
                selector.toLowerCase().includes('saturday') ||
                selector.toLowerCase().includes('sunday') ||
                selector.toLowerCase().includes('mon') ||
                selector.toLowerCase().includes('tue') ||
                selector.toLowerCase().includes('wed') ||
                selector.toLowerCase().includes('thu') ||
                selector.toLowerCase().includes('fri') ||
                selector.toLowerCase().includes('sat') ||
                selector.toLowerCase().includes('sun')
              );
              
              // Check if page has dl#anw-hour1 structure (common hour form pattern)
              const hasAnwHourStructure = document.querySelector('dl#anw-hour1, #anw-hour1, dl[id*="hour"]');
              
              // Check if page has hours-of-operation structure with hidden inputs and time pickers
              // Structure: hidden inputs (mo_s1, mo_s2, mo_e1, mo_e2) + visible time pickers (id="mo_s1", etc.)
              const hasHoursOfOperationStructure = document.querySelector('#hours-of-operation, #hourswrapper, [id*="hoursPicker"]') ||
                                                    document.querySelector('input[name*="_s1"], input[name*="_s2"], input[name*="_e1"], input[name*="_e2"]') ||
                                                    document.querySelector('input.ui-timepicker-input[id*="_s"], input.ui-timepicker-input[id*="_e"]');
              
              // Check if page has opening-hours table structure (table with class "opening-hours" and inputs week[1-6,0], op[1-6,0], cl[1-6,0])
              const hasOpeningHoursTableStructure = document.querySelector('table.opening-hours, table[class*="opening-hours"], .opening-hours table') &&
                                                    document.querySelector('input[type="checkbox"][name^="week["]') &&
                                                    document.querySelector('input[type="time"][name^="op["], input[name^="op["]') &&
                                                    document.querySelector('input[type="time"][name^="cl["], input[name^="cl["]');
              
              // Check if page has oHcnt/ohline structure (.oHcnt > .ohline, select.ohtime von1/bis1, select.status; mo[von1], mo[bis1], mo[status1], etc.)
              const hasOHcntStructure = document.querySelector('.oHcnt, .container.ohline, [class*="oHcnt"]') &&
                (document.querySelector('select.ohtime[name*="von1"], select#von1mo, select[name="mo[von1]"]') ||
                 document.querySelector('select[name*="von1"], select[id^="von1"]'));
              
              // Check if page has timetable structure (table.timetable with input#monday_start, input#monday_end, input#monday_closed)
              const hasTimetableStructure = document.querySelector('table.timetable, table[class*="timetable"]') &&
                document.querySelector('input#monday_start, input[id="monday_start"], input[id$="_start"]');
              
              // Check if page has CompanyWorkingHoursForm structure (.form-subsection, .radio-label, .day-of-week, openingStart/closingEnd selects)
              const hasCompanyWorkingHoursFormStructure = document.querySelector('form[data-form-name="CompanyWorkingHoursForm"]') ||
                (document.querySelector('.form-subsection') && document.querySelector('.radio-label .day-of-week') && 
                 document.querySelector('select[name="openingStart"]') && document.querySelector('select[name="closingEnd"]'));
              
              // If this looks like a business hours form OR has the anw-hour structure OR hours-of-operation structure OR opening-hours table structure OR oHcnt structure OR timetable structure OR CompanyWorkingHoursForm, and valueKey indicates a specific day/hour,
              // try to auto-fill all related hour fields
              if ((isBusinessHoursForm || hasAnwHourStructure || hasHoursOfOperationStructure || hasOpeningHoursTableStructure || hasOHcntStructure || hasTimetableStructure || hasCompanyWorkingHoursFormStructure) && valueKey && (valueKey.includes('Am') || valueKey.includes('Pm'))) {
                console.log(`üîç [${stepIndex}] Business hours form detected (isBusinessHoursForm: ${isBusinessHoursForm}, hasAnwHourStructure: ${!!hasAnwHourStructure}, hasHoursOfOperationStructure: ${!!hasHoursOfOperationStructure}, hasOpeningHoursTableStructure: ${!!hasOpeningHoursTableStructure}, hasOHcntStructure: ${!!hasOHcntStructure}, hasTimetableStructure: ${!!hasTimetableStructure}, hasCompanyWorkingHoursFormStructure: ${!!hasCompanyWorkingHoursFormStructure}) - attempting smart multiple hours autofilling`);
                
                // Handle hours-of-operation structure (hidden inputs + time pickers)
                if (hasHoursOfOperationStructure) {
                  console.log(`üîç [${stepIndex}] Detected hours-of-operation structure - filling hidden inputs and time pickers`);
                  
                  const dayMap = {
                    'mon': 'mo', 'tue': 'tu', 'wed': 'we', 'thu': 'th', 
                    'fri': 'fr', 'sat': 'sa', 'sun': 'su'
                  };
                  
                  const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
                  let hoursFilledCount = 0;
                  
                  for (const day of days) {
                    const dayPrefix = dayMap[day];
                    const amKey = `${day}Am`;
                    const pmKey = `${day}Pm`;
                    const amValue = flatData[amKey];
                    const pmValue = flatData[pmKey];
                    
                    // Convert times to 24-hour format
                    const am24 = amValue ? convertTo24Hour(String(amValue).trim()) : null;
                    const pm24 = pmValue ? convertTo24Hour(String(pmValue).trim()) : null;
                    
                    // Fill first time slot (s1/e1) if we have AM/PM values
                    if (am24 && pm24) {
                      // Fill visible time picker inputs
                      const startInput1 = document.querySelector(`#${dayPrefix}_s1`);
                      const endInput1 = document.querySelector(`#${dayPrefix}_e1`);
                      
                      if (startInput1 && endInput1) {
                        // Fill visible inputs using robust approach
                        startInput1.focus();
                        startInput1.value = '';
                        startInput1.value = am24;
                        startInput1.dispatchEvent(new Event('input', { bubbles: true }));
                        startInput1.dispatchEvent(new Event('change', { bubbles: true }));
                        startInput1.blur();
                        
                        endInput1.focus();
                        endInput1.value = '';
                        endInput1.value = pm24;
                        endInput1.dispatchEvent(new Event('input', { bubbles: true }));
                        endInput1.dispatchEvent(new Event('change', { bubbles: true }));
                        endInput1.blur();
                        
                        // Fill hidden inputs
                        const hiddenStart1 = document.querySelector(`input[name="${dayPrefix}_s1"]`);
                        const hiddenEnd1 = document.querySelector(`input[name="${dayPrefix}_e1"]`);
                        
                        if (hiddenStart1) {
                          hiddenStart1.value = am24;
                          hiddenStart1.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                        
                        if (hiddenEnd1) {
                          hiddenEnd1.value = pm24;
                          hiddenEnd1.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                        
                        hoursFilledCount += 2;
                        console.log(`‚úÖ [${stepIndex}] Filled ${day} slot 1: ${am24} - ${pm24}`);
                      }
                      
                      // Try to fill second time slot (s2/e2) if fields exist
                      const startInput2 = document.querySelector(`#${dayPrefix}_s2`);
                      const endInput2 = document.querySelector(`#${dayPrefix}_e2`);
                      
                      if (startInput2 && endInput2) {
                        // For second slot, we can use the same values or leave empty
                        // You can customize this logic based on your needs
                        // For now, we'll leave second slot empty unless there's specific data for it
                        const s2Value = flatData[`${day}Am2`] || flatData[`${day}AmSlot2`];
                        const e2Value = flatData[`${day}Pm2`] || flatData[`${day}PmSlot2`];
                        
                        if (s2Value && e2Value) {
                          const s2_24 = convertTo24Hour(String(s2Value).trim());
                          const e2_24 = convertTo24Hour(String(e2Value).trim());
                          
                          startInput2.focus();
                          startInput2.value = '';
                          startInput2.value = s2_24;
                          startInput2.dispatchEvent(new Event('input', { bubbles: true }));
                          startInput2.dispatchEvent(new Event('change', { bubbles: true }));
                          startInput2.blur();
                          
                          endInput2.focus();
                          endInput2.value = '';
                          endInput2.value = e2_24;
                          endInput2.dispatchEvent(new Event('input', { bubbles: true }));
                          endInput2.dispatchEvent(new Event('change', { bubbles: true }));
                          endInput2.blur();
                          
                          const hiddenStart2 = document.querySelector(`input[name="${dayPrefix}_s2"]`);
                          const hiddenEnd2 = document.querySelector(`input[name="${dayPrefix}_e2"]`);
                          
                          if (hiddenStart2) {
                            hiddenStart2.value = s2_24;
                            hiddenStart2.dispatchEvent(new Event('change', { bubbles: true }));
                          }
                          
                          if (hiddenEnd2) {
                            hiddenEnd2.value = e2_24;
                            hiddenEnd2.dispatchEvent(new Event('change', { bubbles: true }));
                          }
                          
                          hoursFilledCount += 2;
                          console.log(`‚úÖ [${stepIndex}] Filled ${day} slot 2: ${s2_24} - ${e2_24}`);
                        }
                      }
                    } else if (am24 || pm24) {
                      console.log(`‚ö†Ô∏è [${stepIndex}] ${day} has only one time value (AM: ${am24 || 'none'}, PM: ${pm24 || 'none'}) - skipping`);
                    }
                  }
                  
                  if (hoursFilledCount > 0) {
                    console.log(`‚úÖ [${stepIndex}] Hours-of-operation structure: ${hoursFilledCount} field(s) filled`);
                    // Continue with normal flow for the specific selector if provided
                  }
                }
                
                // Handle opening-hours table structure (table with checkboxes week[1-6,0] and time inputs op[1-6,0], cl[1-6,0])
                if (hasOpeningHoursTableStructure) {
                  console.log(`üîç [${stepIndex}] Detected opening-hours table structure - filling checkboxes and time inputs`);
                  
                  const dayMap = {
                    'mon': { weekIndex: 1, dayName: 'Monday' },
                    'tue': { weekIndex: 2, dayName: 'Tuesday' },
                    'wed': { weekIndex: 3, dayName: 'Wednesday' },
                    'thu': { weekIndex: 4, dayName: 'Thursday' },
                    'fri': { weekIndex: 5, dayName: 'Friday' },
                    'sat': { weekIndex: 6, dayName: 'Saturday' },
                    'sun': { weekIndex: 0, dayName: 'Sunday' }
                  };
                  
                  const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
                  let hoursFilledCount = 0;
                  
                  for (const day of days) {
                    const dayInfo = dayMap[day];
                    if (!dayInfo) continue;
                    
                    const weekIndex = dayInfo.weekIndex;
                    const amKey = `${day}Am`;
                    const pmKey = `${day}Pm`;
                    const amValue = flatData[amKey];
                    const pmValue = flatData[pmKey];
                    
                    // Check if day has hours
                    const hasHours = isDayExplicitlyClosed(flatData, day)
                      ? false
                      : (isUsableHourValue(amValue) || isUsableHourValue(pmValue));
                    
                    // Find the checkbox for this day
                    const weekCheckbox = document.querySelector(`input[type="checkbox"][name="week[${weekIndex}]"]`);
                    
                    if (weekCheckbox) {
                      // Set checkbox state: checked = open, unchecked = closed
                      if (hasHours) {
                        // Day has hours - check the checkbox
                        if (!weekCheckbox.checked) {
                          weekCheckbox.checked = true;
                          weekCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
                          weekCheckbox.dispatchEvent(new Event('click', { bubbles: true }));
                          console.log(`‚úÖ [${stepIndex}] Checked ${day} checkbox (day is open)`);
                        }
                        
                        // Convert times to 24-hour format
                        const am24 = amValue ? convertTo24Hour(String(amValue).trim()) : null;
                        const pm24 = pmValue ? convertTo24Hour(String(pmValue).trim()) : null;
                        
                        // Fill opening time (op[X])
                        if (am24) {
                          const opInput = document.querySelector(`input[type="time"][name="op[${weekIndex}]"], input[name="op[${weekIndex}]"]`);
                          if (opInput) {
                            opInput.focus();
                            opInput.value = '';
                            opInput.value = am24;
                            opInput.dispatchEvent(new Event('input', { bubbles: true }));
                            opInput.dispatchEvent(new Event('change', { bubbles: true }));
                            opInput.blur();
                            hoursFilledCount++;
                            console.log(`‚úÖ [${stepIndex}] Filled ${day} opening time (op[${weekIndex}]): ${am24}`);
                          }
                        }
                        
                        // Fill closing time (cl[X])
                        if (pm24) {
                          const clInput = document.querySelector(`input[type="time"][name="cl[${weekIndex}]"], input[name="cl[${weekIndex}]"]`);
                          if (clInput) {
                            clInput.focus();
                            clInput.value = '';
                            clInput.value = pm24;
                            clInput.dispatchEvent(new Event('input', { bubbles: true }));
                            clInput.dispatchEvent(new Event('change', { bubbles: true }));
                            clInput.blur();
                            hoursFilledCount++;
                            console.log(`‚úÖ [${stepIndex}] Filled ${day} closing time (cl[${weekIndex}]): ${pm24}`);
                          }
                        }
                      } else {
                        // Day has no hours - uncheck the checkbox (closed)
                        if (weekCheckbox.checked) {
                          weekCheckbox.checked = false;
                          weekCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
                          weekCheckbox.dispatchEvent(new Event('click', { bubbles: true }));
                          console.log(`‚úÖ [${stepIndex}] Unchecked ${day} checkbox (day is closed)`);
                        }
                      }
                    }
                  }
                  
                  if (hoursFilledCount > 0) {
                    console.log(`‚úÖ [${stepIndex}] Opening-hours table structure: ${hoursFilledCount} field(s) filled`);
                    // Continue with normal flow for the specific selector if provided
                  }
                }
                
                // Handle oHcnt/ohline structure (German-style: von1/bis1/status1 per day; IDs von1mo, bis1mo, status1mo; names mo[von1], mo[bis1], mo[status1])
                if (hasOHcntStructure) {
                  console.log(`üîç [${stepIndex}] Detected oHcnt/ohline structure - filling von1/bis1/status1 per day`);
                  const oHcntDayMap = { mon: 'mo', tue: 'di', wed: 'mi', thu: 'do', fri: 'fr', sat: 'sa', sun: 'so' };
                  const oHcntDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
                  let oHcntFilledCount = 0;
                  for (const day of oHcntDays) {
                    const prefix = oHcntDayMap[day];
                    const amKey = `${day}Am`;
                    const pmKey = `${day}Pm`;
                    const amValue = flatData[amKey];
                    const pmValue = flatData[pmKey];
                    const am24 = amValue ? convertTo24Hour(String(amValue).trim()) : null;
                    const pm24 = pmValue ? convertTo24Hour(String(pmValue).trim()) : null;
                    const isClosed = !amValue || !pmValue || String(amValue).trim().toLowerCase() === 'closed' || String(pmValue).trim().toLowerCase() === 'closed';
                    const von1Select = document.querySelector(`select#von1${prefix}, select[name="${prefix}[von1]"], select.ohtime.von1[name="${prefix}[von1]"]`) ||
                      document.querySelector(`.oHcnt select[name="${prefix}[von1]"], .ohline select[name="${prefix}[von1]"]`);
                    const bis1Select = document.querySelector(`select#bis1${prefix}, select[name="${prefix}[bis1]"], select.ohtime.bis1[name="${prefix}[bis1]"]`) ||
                      document.querySelector(`.oHcnt select[name="${prefix}[bis1]"], .ohline select[name="${prefix}[bis1]"]`);
                    const status1Select = document.querySelector(`select#status1${prefix}, select[name="${prefix}[status1]"], select.status.status1[name="${prefix}[status1]"]`) ||
                      document.querySelector(`.oHcnt select[name="${prefix}[status1]"], .ohline select[name="${prefix}[status1]"]`);
                    if (von1Select && bis1Select && status1Select) {
                      if (isClosed || !am24 || !pm24) {
                        const closedOption = Array.from(status1Select.options).find(opt => (opt.value || '').toLowerCase() === 'geschlossen');
                        if (closedOption) {
                          status1Select.value = closedOption.value;
                          status1Select.dispatchEvent(new Event('change', { bubbles: true }));
                          status1Select.dispatchEvent(new Event('input', { bubbles: true }));
                          oHcntFilledCount++;
                          console.log(`‚úÖ [${stepIndex}] Set ${day} (${prefix}) status to closed`);
                        }
                      } else {
                        const findTimeOption = (selectEl, time24) => {
                          if (!selectEl || !time24) return null;
                          const options = Array.from(selectEl.options);
                          const normalized = time24.includes(':') ? time24 : time24.length === 4 ? time24.slice(0, 2) + ':' + time24.slice(2) : time24;
                          return options.find(opt => String(opt.value).trim() === normalized || String(opt.value).trim() === time24) || options.find(opt => opt.value && convertTo24Hour(opt.textContent.trim()) === normalized);
                        };
                        const vonOption = findTimeOption(von1Select, am24);
                        const bisOption = findTimeOption(bis1Select, pm24) || findTimeOption(bis1Select, '24:00');
                        if (vonOption) {
                          von1Select.value = vonOption.value;
                          von1Select.dispatchEvent(new Event('change', { bubbles: true }));
                          von1Select.dispatchEvent(new Event('input', { bubbles: true }));
                          oHcntFilledCount++;
                        }
                        if (bisOption) {
                          bis1Select.value = bisOption.value;
                          bis1Select.dispatchEvent(new Event('change', { bubbles: true }));
                          bis1Select.dispatchEvent(new Event('input', { bubbles: true }));
                          oHcntFilledCount++;
                        }
                        const openOption = Array.from(status1Select.options).find(opt => (opt.value || '').toLowerCase() === 'offen');
                        if (openOption) {
                          status1Select.value = openOption.value;
                          status1Select.dispatchEvent(new Event('change', { bubbles: true }));
                          status1Select.dispatchEvent(new Event('input', { bubbles: true }));
                          oHcntFilledCount++;
                        }
                        console.log(`‚úÖ [${stepIndex}] Filled ${day} (${prefix}): von1=${am24}, bis1=${pm24}`);
                      }
                    }
                  }
                  if (oHcntFilledCount > 0) {
                    console.log(`‚úÖ [${stepIndex}] oHcnt/ohline structure: ${oHcntFilledCount} field(s) filled`);
                  }
                }
                
                // Handle timetable structure (table.timetable with input#monday_start, input#monday_end, input#monday_closed)
                if (hasTimetableStructure) {
                  console.log(`üîç [${stepIndex}] Detected timetable structure - filling {day}_start, {day}_end, {day}_closed`);
                  const timetableDayMap = { mon: 'monday', tue: 'tuesday', wed: 'wednesday', thu: 'thursday', fri: 'friday', sat: 'saturday', sun: 'sunday' };
                  const timetableDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
                  let timetableFilledCount = 0;
                  for (const day of timetableDays) {
                    const dayName = timetableDayMap[day];
                    const amKey = `${day}Am`;
                    const pmKey = `${day}Pm`;
                    const amValue = flatData[amKey];
                    const pmValue = flatData[pmKey];
                    const am24 = amValue ? convertTo24Hour(String(amValue).trim()) : null;
                    const pm24 = pmValue ? convertTo24Hour(String(pmValue).trim()) : null;
                    const isClosed = !amValue || !pmValue || String(amValue).trim().toLowerCase() === 'closed' || String(pmValue).trim().toLowerCase() === 'closed';
                    const startInput = document.querySelector(`input#${dayName}_start, input[id="${dayName}_start"]`);
                    const endInput = document.querySelector(`input#${dayName}_end, input[id="${dayName}_end"]`);
                    const closedCheckbox = document.querySelector(`input#${dayName}_closed, input[id="${dayName}_closed"]`);
                    if (startInput && endInput) {
                      if (isClosed || !am24 || !pm24) {
                        if (closedCheckbox && !closedCheckbox.checked) {
                          closedCheckbox.checked = true;
                          closedCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
                          closedCheckbox.dispatchEvent(new Event('click', { bubbles: true }));
                          timetableFilledCount++;
                        }
                        if (startInput.value) { startInput.value = ''; startInput.dispatchEvent(new Event('input', { bubbles: true })); startInput.dispatchEvent(new Event('change', { bubbles: true })); }
                        if (endInput.value) { endInput.value = ''; endInput.dispatchEvent(new Event('input', { bubbles: true })); endInput.dispatchEvent(new Event('change', { bubbles: true })); }
                        console.log(`‚úÖ [${stepIndex}] Set ${day} (${dayName}) to closed`);
                      } else {
                        if (closedCheckbox && closedCheckbox.checked) {
                          closedCheckbox.checked = false;
                          closedCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
                          closedCheckbox.dispatchEvent(new Event('click', { bubbles: true }));
                          timetableFilledCount++;
                        }
                        const formatTime5 = (time24) => {
                          if (!time24) return '';
                          const s = String(time24).trim();
                          if (s.length <= 5) return s;
                          if (s.indexOf(':') !== -1) return s.slice(0, 5);
                          return s.slice(0, 2) + ':' + s.slice(2, 4);
                        };
                        const startVal = formatTime5(am24);
                        const endVal = formatTime5(pm24);
                        if (startVal) {
                          startInput.focus();
                          startInput.value = '';
                          startInput.value = startVal;
                          startInput.dispatchEvent(new Event('input', { bubbles: true }));
                          startInput.dispatchEvent(new Event('change', { bubbles: true }));
                          startInput.dispatchEvent(new Event('blur', { bubbles: true }));
                          timetableFilledCount++;
                        }
                        if (endVal) {
                          endInput.focus();
                          endInput.value = '';
                          endInput.value = endVal;
                          endInput.dispatchEvent(new Event('input', { bubbles: true }));
                          endInput.dispatchEvent(new Event('change', { bubbles: true }));
                          endInput.dispatchEvent(new Event('blur', { bubbles: true }));
                          timetableFilledCount++;
                        }
                        console.log(`‚úÖ [${stepIndex}] Filled ${day} (${dayName}): start=${startVal}, end=${endVal}`);
                      }
                    }
                  }
                  if (timetableFilledCount > 0) {
                    console.log(`‚úÖ [${stepIndex}] Timetable structure: ${timetableFilledCount} field(s) filled`);
                  }
                }
                
                // Extract day and period from valueKey (e.g., "monAm" -> day="mon", period="Am")
                const dayMatch = valueKey.match(/^(mon|tue|wed|thu|fri|sat|sun)(Am|Pm)$/i);
                if (dayMatch) {
                  const [, day, period] = dayMatch;
                  const dayLower = day.toLowerCase();
                  const periodLower = period.toLowerCase();
                  
                  console.log(`üîç [${stepIndex}] Detected day: ${dayLower}, period: ${periodLower}`);
                  
                  // Try to find and fill all related hour fields for all days
                  const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
                  const dayNames = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
                  const periods = ['am', 'pm'];
                  
                  let filledCount = 0;
                  
                  // Function to find related selector for a day/period
                  const findRelatedSelector = (targetDay, targetPeriod) => {
                    // Try multiple selector patterns
                    const patterns = [
                      // Pattern 1: Replace day in current selector
                      selector.replace(new RegExp(dayLower, 'gi'), targetDay),
                      selector.replace(new RegExp(dayNames[days.indexOf(dayLower)] || '', 'gi'), dayNames[days.indexOf(targetDay)] || ''),
                      // Pattern 2: Replace period in current selector
                      selector.replace(new RegExp(periodLower === 'am' ? 'open' : 'close', 'gi'), targetPeriod === 'am' ? 'open' : 'close'),
                      // Pattern 3: Generic patterns
                      selector.replace(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gi, dayNames[days.indexOf(targetDay)] || ''),
                      selector.replace(/mon|tue|wed|thu|fri|sat|sun/gi, targetDay),
                    ];
                    
                    // Enhanced patterns for _am/_pm format and other common formats
                    const commonPatterns = [
                      // Pattern: name="_day_am" or name="_day_pm" (e.g., mon_am, tue_pm)
                      `select[name="${targetDay}_${targetPeriod}"]`,
                      `select[name*="${targetDay}_${targetPeriod}"]`,
                      `[name="${targetDay}_${targetPeriod}"]`,
                      `[name*="${targetDay}_${targetPeriod}"]`,
                      // Pattern: id="_day_am" or id="_day_pm"
                      `select#${targetDay}_${targetPeriod}`,
                      `#${targetDay}_${targetPeriod}`,
                      `select[id="${targetDay}_${targetPeriod}"]`,
                      `[id="${targetDay}_${targetPeriod}"]`,
                      // Pattern: name="_dayAm" or name="_dayPm" (camelCase)
                      `select[name="${targetDay}${targetPeriod.charAt(0).toUpperCase() + targetPeriod.slice(1)}"]`,
                      `[name="${targetDay}${targetPeriod.charAt(0).toUpperCase() + targetPeriod.slice(1)}"]`,
                      // Pattern: Within dl#anw-hour1 structure
                      `dl#anw-hour1 select[name="${targetDay}_${targetPeriod}"]`,
                      `dl#anw-hour1 [name="${targetDay}_${targetPeriod}"]`,
                      `#anw-hour1 select[name="${targetDay}_${targetPeriod}"]`,
                      // Pattern: Generic day/period patterns
                      `[name*="${targetDay}"][name*="${targetPeriod}"]`,
                      `[name*="${targetDay}"][name*="${targetPeriod === 'am' ? 'open' : 'close'}"]`,
                      `[id*="${targetDay}"][id*="${targetPeriod}"]`,
                      `[id*="${targetDay}"][id*="${targetPeriod === 'am' ? 'open' : 'close'}"]`,
                      // Pattern: PM fields with sel-hour2 class
                      targetPeriod === 'pm' ? `select.sel-hour2[name*="${targetDay}"]` : null,
                      targetPeriod === 'pm' ? `.sel-hour2[name*="${targetDay}"]` : null,
                      // Pattern: Generic select with day name
                      `select[name*="${targetDay}"]`,
                      `select[id*="${targetDay}"]`,
                    ].filter(p => p !== null);
                    
                    return [...patterns, ...commonPatterns];
                  };
                  
                  // Enhanced function to find element by multiple strategies
                  const findElementByMultipleStrategies = (targetDay, targetPeriod) => {
                    // Strategy 1: Direct name/id search (most reliable for _am/_pm format)
                    const directName = `${targetDay}_${targetPeriod}`;
                    let directEl = document.querySelector(`select[name="${directName}"]`);
                    if (directEl && directEl.tagName === 'SELECT' && directEl !== el) {
                      console.log(`‚úÖ [${stepIndex}] Found ${targetDay}_${targetPeriod} by direct name: ${directName}`);
                      return directEl;
                    }
                    
                    // Strategy 2: Search within dl#anw-hour1 structure (most common format)
                    const hourContainer = document.querySelector('dl#anw-hour1, #anw-hour1, dl[id*="hour"], [id*="hour"]');
                    if (hourContainer) {
                      // Method 2a: Direct select search within container
                      const containerSelect = hourContainer.querySelector(`select[name="${directName}"]`);
                      if (containerSelect && containerSelect.tagName === 'SELECT' && containerSelect !== el) {
                        console.log(`‚úÖ [${stepIndex}] Found ${targetDay}_${targetPeriod} in hour container by name: ${directName}`);
                        return containerSelect;
                      }
                      
                      // Method 2b: Look for label containing day name, then find select in same dd
                      const dayLabels = Array.from(hourContainer.querySelectorAll('dt label, label'));
                      for (const label of dayLabels) {
                        const labelText = label.textContent.toLowerCase().trim();
                        const dayFullName = dayNames[days.indexOf(targetDay)];
                        const dayMatch = labelText === targetDay || 
                                        labelText === dayFullName || 
                                        labelText.includes(targetDay) || 
                                        labelText.includes(dayFullName);
                        
                        if (dayMatch) {
                          // Find the dd element containing the selects
                          const dt = label.closest('dt');
                          const dd = dt?.nextElementSibling;
                          
                          if (dd && dd.tagName === 'DD') {
                            // First, try exact name match
                            const exactNameSelect = dd.querySelector(`select[name="${directName}"]`);
                            if (exactNameSelect && exactNameSelect !== el) {
                              console.log(`‚úÖ [${stepIndex}] Found ${targetDay}_${targetPeriod} in dd by exact name: ${directName}`);
                              return exactNameSelect;
                            }
                            
                            // Second, try pattern match (name contains day and period)
                            const patternSelect = dd.querySelector(`select[name*="${targetDay}"][name*="${targetPeriod}"]`);
                            if (patternSelect && patternSelect !== el) {
                              console.log(`‚úÖ [${stepIndex}] Found ${targetDay}_${targetPeriod} in dd by pattern: name contains "${targetDay}" and "${targetPeriod}"`);
                              return patternSelect;
                            }
                            
                            // Third, try by position (first = AM, second = PM)
                            const allSelects = Array.from(dd.querySelectorAll('select'));
                            if (allSelects.length >= 2) {
                              const selectIndex = targetPeriod === 'am' ? 0 : 1;
                              const positionSelect = allSelects[selectIndex];
                              
                              if (positionSelect && positionSelect !== el) {
                                const selectName = (positionSelect.name || positionSelect.id || '').toLowerCase();
                                
                                // Verify the select has the correct period in its name or matches expected pattern
                                const isCorrectPeriod = selectName.includes(targetPeriod) || 
                                    (targetPeriod === 'am' && !selectName.includes('pm') && !positionSelect.classList.contains('sel-hour2')) ||
                                    (targetPeriod === 'pm' && (selectName.includes('pm') || positionSelect.classList.contains('sel-hour2')));
                                
                                // If name verification fails but we're in a structured format, trust position
                                // (This handles cases where name might not match exactly but position is reliable)
                                if (isCorrectPeriod || (hourContainer && allSelects.length === 2)) {
                                  console.log(`‚úÖ [${stepIndex}] Found ${targetDay}_${targetPeriod} in dd by position (index ${selectIndex}): name="${positionSelect.name || positionSelect.id}", verified=${isCorrectPeriod}`);
                                  return positionSelect;
                                }
                              } else if (allSelects.length === 1 && targetPeriod === 'am') {
                                // If only one select exists and we're looking for AM, use it
                                if (allSelects[0] && allSelects[0] !== el && !allSelects[0].classList.contains('sel-hour2')) {
                                  console.log(`‚úÖ [${stepIndex}] Found ${targetDay}_${targetPeriod} in dd (only one select, assuming AM): name="${allSelects[0].name || allSelects[0].id}"`);
                                  return allSelects[0];
                                }
                              }
                            } else if (allSelects.length === 1) {
                              // If only one select, check if it matches our period
                              const singleSelect = allSelects[0];
                              if (singleSelect && singleSelect !== el) {
                                const selectName = (singleSelect.name || singleSelect.id || '').toLowerCase();
                                if ((targetPeriod === 'am' && !selectName.includes('pm') && !singleSelect.classList.contains('sel-hour2')) ||
                                    (targetPeriod === 'pm' && (selectName.includes('pm') || singleSelect.classList.contains('sel-hour2')))) {
                                  console.log(`‚úÖ [${stepIndex}] Found ${targetDay}_${targetPeriod} in dd (single select): name="${singleSelect.name || singleSelect.id}"`);
                                  return singleSelect;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    
                    // Strategy 3: Try CSS selectors from findRelatedSelector
                    const relatedSelectors = findRelatedSelector(targetDay, targetPeriod);
                    for (const relatedSelector of relatedSelectors) {
                      try {
                        const foundEl = document.querySelector(relatedSelector);
                        if (foundEl && foundEl.tagName === 'SELECT' && foundEl !== el) {
                          // Verify it's the right period
                          const foundName = (foundEl.name || foundEl.id || '').toLowerCase();
                          if (foundName.includes(targetPeriod) || 
                              (targetPeriod === 'pm' && foundEl.classList.contains('sel-hour2')) ||
                              (targetPeriod === 'am' && !foundEl.classList.contains('sel-hour2') && !foundName.includes('pm'))) {
                            console.log(`‚úÖ [${stepIndex}] Found ${targetDay}_${targetPeriod} by selector: ${relatedSelector}`);
                            return foundEl;
                          }
                        }
                      } catch (e) {
                        // Invalid selector, continue
                      }
                    }
                    
                    console.warn(`‚ö†Ô∏è [${stepIndex}] Could not find select element for ${targetDay}_${targetPeriod}`);
                    return null;
                  };
                  
                  // Fill all days and periods
                  console.log(`üîç [${stepIndex}] Starting smart autofill for all days and periods...`);
                  for (const targetDay of days) {
                    for (const targetPeriod of periods) {
                      const targetValueKey = `${targetDay}${targetPeriod.charAt(0).toUpperCase() + targetPeriod.slice(1)}`;
                      const targetValue = flatData[targetValueKey];
                      
                      console.log(`üîç [${stepIndex}] Checking ${targetValueKey}: value="${targetValue}"`);
                      
                      // Skip only if value is explicitly "Closed", "00", "00:00", or empty
                      const shouldSkip = !targetValue || 
                                        targetValue.trim() === '' || 
                                        targetValue.trim().toLowerCase() === 'closed' ||
                                        targetValue.trim() === '00' ||
                                        targetValue.trim() === '00:00';
                      
                      if (!shouldSkip) {
                        // Find the related element using multiple strategies
                        console.log(`üîç [${stepIndex}] Searching for select element: ${targetDay}_${targetPeriod}`);
                        const relatedEl = findElementByMultipleStrategies(targetDay, targetPeriod);
                        
                        // If found, fill it
                        if (relatedEl && relatedEl.tagName === 'SELECT') {
                          console.log(`‚úÖ [${stepIndex}] Found select for ${targetValueKey}: name="${relatedEl.name || relatedEl.id}"`);
                          const targetHour24 = convertTo24Hour(String(targetValue).trim());
                          const relatedOptions = Array.from(relatedEl.options);
                          
                          // Convert to 4-digit format (e.g., "09:00" -> "0900", "9:00 AM" -> "0900")
                          const convertTo4Digit = (timeStr) => {
                            if (!timeStr) return '';
                            // If already 4 digits, return as is
                            if (/^\d{4}$/.test(timeStr.trim())) {
                              return timeStr.trim();
                            }
                            // Convert "09:00" to "0900"
                            const time24 = convertTo24Hour(timeStr.trim());
                            if (time24.includes(':')) {
                              return time24.replace(':', '');
                            }
                            return time24;
                          };
                          
                          const target4Digit = convertTo4Digit(targetValue);
                          const hour244Digit = convertTo4Digit(targetHour24);
                          
                          // Try to find matching option with enhanced matching
                          // Priority: 4-digit format first (since that's what the options use)
                          let matchedRelatedOption = relatedOptions.find(opt => {
                            const optVal = String(opt.value).trim();
                            // Clean option text - remove &nbsp; and normalize whitespace
                            const optText = opt.textContent.trim()
                              .replace(/&nbsp;/gi, ' ')
                              .replace(/\s+/g, ' ')
                              .trim()
                              .toLowerCase();
                            
                            // Priority 1: 4-digit format matches (most common in this format - e.g., "0900")
                            if (optVal === target4Digit || optVal === hour244Digit) {
                              return true;
                            }
                            
                            // Priority 2: Exact value matches (24-hour format - e.g., "09:00")
                            if (optVal === targetHour24 || optVal === targetValue.trim()) {
                              return true;
                            }
                            
                            // Priority 3: Text content matches (handles "9:00am", "&nbsp;9:00am", etc.)
                            const cleanOptText = optText.replace(/\s+/g, '').replace(/:/g, '');
                            const cleanTarget = targetValue.trim().toLowerCase()
                              .replace(/\s+/g, '')
                              .replace(/:/g, '')
                              .replace(/[ap]m/gi, '');
                            const clean24 = targetHour24.toLowerCase().replace(/\s+/g, '').replace(/:/g, '');
                            
                            if (cleanOptText === cleanTarget || cleanOptText === clean24 ||
                                optText.includes(cleanTarget) || optText.includes(clean24)) {
                              return true;
                            }
                            
                            return false;
                          });
                          
                          // Try normalized matching
                          if (!matchedRelatedOption) {
                            const normalizeTime = (timeStr) => {
                              if (!timeStr) return '';
                              return String(timeStr).toLowerCase()
                                .replace(/\s+/g, '')
                                .replace(/[ap]m/gi, '')
                                .replace(/:/g, '')
                                .replace(/^0+/, '');
                            };
                            
                            const normalized24 = normalizeTime(targetHour24);
                            const normalized4Digit = normalizeTime(target4Digit);
                            const normalizedValue = normalizeTime(targetValue);
                            
                            matchedRelatedOption = relatedOptions.find(opt => {
                              const optText = normalizeTime(opt.textContent.trim());
                              const optValue = normalizeTime(opt.value);
                              return optText === normalized24 || optValue === normalized24 ||
                                     optText === normalized4Digit || optValue === normalized4Digit ||
                                     optText === normalizedValue || optValue === normalizedValue;
                            });
                          }
                          
                          // Try 4-digit format matching (e.g., "0900" matches option value "0900")
                          if (!matchedRelatedOption && target4Digit) {
                            matchedRelatedOption = relatedOptions.find(opt => {
                              const optVal = String(opt.value).trim();
                              // Direct 4-digit match
                              if (optVal === target4Digit || optVal === hour244Digit) {
                                return true;
                              }
                              // Match option text that contains the time (e.g., "9:00am" contains "0900" when normalized)
                              const optText = opt.textContent.trim();
                              const optTextNormalized = optText.replace(/\s+/g, '').replace(/:/g, '').replace(/[ap]m/gi, '').replace(/^0+/, '');
                              const targetNormalized = target4Digit.replace(/^0+/, '');
                              return optTextNormalized === targetNormalized;
                            });
                          }
                          
                          if (matchedRelatedOption) {
                            relatedEl.value = matchedRelatedOption.value;
                            relatedEl.dispatchEvent(new Event("change", { bubbles: true }));
                            relatedEl.dispatchEvent(new Event("input", { bubbles: true }));
                            relatedEl.dispatchEvent(new Event("blur", { bubbles: true }));
                            relatedEl.style.border = "2px solid #4CAF50";
                            filledCount++;
                            console.log(`‚úÖ [${stepIndex}] ‚úÖ Auto-filled ${targetValueKey}: "${matchedRelatedOption.textContent}" (value="${matchedRelatedOption.value}", target="${targetHour24}", 4-digit="${target4Digit}")`);
                          } else {
                            console.warn(`‚ö†Ô∏è [${stepIndex}] Could not find matching option for ${targetValueKey}="${targetValue}" (24h="${targetHour24}", 4-digit="${target4Digit}") in select[name="${relatedEl.name || relatedEl.id}"]`);
                            console.warn(`   ‚Ä¢ Available options: ${relatedOptions.slice(0, 5).map(opt => `"${opt.textContent}" (value="${opt.value}")`).join(', ')}${relatedOptions.length > 5 ? '...' : ''}`);
                          }
                        } else {
                          console.warn(`‚ö†Ô∏è [${stepIndex}] Element not found for ${targetValueKey} (${targetDay}_${targetPeriod})`);
                        }
                      } else {
                        if (!targetValue || targetValue.trim() === '') {
                          console.log(`‚è≠Ô∏è [${stepIndex}] Skipping ${targetValueKey} - no value provided`);
                        } else {
                          console.log(`‚è≠Ô∏è [${stepIndex}] Skipping ${targetValueKey} - value is "${targetValue}" (Closed or 00:00)`);
                        }
                      }
                    }
                  }
                  
                  if (filledCount > 0) {
                    console.log(`‚úÖ [${stepIndex}] ‚úÖ Smart autofilling completed: ${filledCount} additional hour field(s) filled automatically`);
                  } else {
                    console.warn(`‚ö†Ô∏è [${stepIndex}] Smart autofilling found no fields to fill. Check if valueKeys (monAm, monPm, etc.) have values in flatData.`);
                  }
                }
              }
              
              // Get the hour value from flatData based on valueKey
              let hourValue = null;
              
              if (valueKey) {
                // Get the hour value from flatData
                hourValue = flatData[valueKey] || '';
                console.log(`‚è∞ [${stepIndex}] Hour value from valueKey "${valueKey}": "${hourValue}"`);
              } else if (value) {
                // Use direct value if provided
                hourValue = value;
                console.log(`‚è∞ [${stepIndex}] Using direct value: "${hourValue}"`);
              } else {
                console.warn(`‚ö†Ô∏è [${stepIndex}] No valueKey or value provided for selectHours`);
                return { success: false, error: 'No valueKey or value provided' };
              }
              
              if (!hourValue || (typeof hourValue === 'string' && hourValue.trim() === '')) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Hour value is empty for valueKey: ${valueKey}`);
                if (canSkip === true) {
                  console.log(`‚è≠Ô∏è [${stepIndex}] Skipping selectHours step (canSkip: true) - Empty value`);
                  return { success: true, skipped: true };
                }
                return { success: false, error: 'Hour value is empty' };
              }
              
              // Convert to 24-hour format for dropdown selection
              const hour24 = convertTo24Hour(String(hourValue).trim());
              
              // Convert to 4-digit format (e.g., "09:00" -> "0900", "9:00 AM" -> "0900")
              const convertTo4Digit = (timeStr) => {
                if (!timeStr) return '';
                // If already 4 digits, return as is
                if (/^\d{4}$/.test(String(timeStr).trim())) {
                  return String(timeStr).trim();
                }
                // Convert "09:00" to "0900"
                const time24 = convertTo24Hour(String(timeStr).trim());
                if (time24.includes(':')) {
                  return time24.replace(':', '');
                }
                return time24;
              };
              
              const hour4Digit = convertTo4Digit(hourValue);
              const hour244Digit = convertTo4Digit(hour24);
              
              console.log(`‚è∞ [${stepIndex}] Converted "${hourValue}" to 24-hour format: "${hour24}", 4-digit: "${hour4Digit}"`);
              
              // Handle SELECT dropdown
              if (el.tagName === 'SELECT') {
                const options = Array.from(el.options);
                let matchedOption = null;
                
                console.log(`‚è∞ [${stepIndex}] Searching for hour match in dropdown: "${hour24}" (4-digit: "${hour4Digit}")`);
                console.log(`   ‚Ä¢ Available options: ${options.map(opt => `"${opt.textContent}" (value="${opt.value}")`).join(', ')}`);
                
                // Strategy 1: Try matching by VALUE first (exact match - supports both "09:00" and "0900" formats)
                matchedOption = options.find(option => {
                  const optionValue = String(option.value).trim();
                  return optionValue === hour24 || 
                         optionValue === hourValue.trim() ||
                         optionValue === hour4Digit ||
                         optionValue === hour244Digit;
                });
                
                if (matchedOption) {
                  console.log(`‚úÖ [${stepIndex}] Matched by VALUE: "${hour24}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                }
                
                // Strategy 2: Try matching by TEXT (exact match, case-insensitive)
                if (!matchedOption) {
                  matchedOption = options.find(option => {
                    const optionText = option.textContent.trim().toLowerCase();
                    const search24 = hour24.toLowerCase();
                    const search12 = hourValue.trim().toLowerCase();
                    return optionText === search24 || optionText === search12;
                  });
                  
                  if (matchedOption) {
                    console.log(`‚úÖ [${stepIndex}] Matched by TEXT: "${hour24}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                  }
                }
                
                // Strategy 3: Try partial text match (handles formats like "08:00", "8:00 AM", "8:00am")
                if (!matchedOption) {
                  // Normalize both search value and option text for comparison
                  const normalizeTime = (timeStr) => {
                    return timeStr.toLowerCase()
                      .replace(/\s+/g, '')
                      .replace(/[ap]m/gi, '')
                      .replace(/:/g, '')
                      .replace(/^0+/, ''); // Remove leading zeros
                  };
                  
                  const normalized24 = normalizeTime(hour24);
                  const normalized12 = normalizeTime(hourValue.trim());
                  
                  matchedOption = options.find(option => {
                    const optionText = normalizeTime(option.textContent.trim());
                    const optionValue = normalizeTime(option.value);
                    return optionText === normalized24 || optionText === normalized12 ||
                           optionValue === normalized24 || optionValue === normalized12;
                  });
                  
                  if (matchedOption) {
                    console.log(`‚úÖ [${stepIndex}] Matched by NORMALIZED TEXT: "${hour24}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                  }
                }
                
                // Strategy 4: Try 4-digit format matching (e.g., "0900" format)
                if (!matchedOption && hour4Digit) {
                  matchedOption = options.find(option => {
                    const optionValue = String(option.value).trim();
                    // Direct 4-digit match
                    if (optionValue === hour4Digit || optionValue === hour244Digit) {
                      return true;
                    }
                    // Match option text that contains the time (e.g., "9:00am" contains "0900" when normalized)
                    const optText = option.textContent.trim();
                    const optTextNormalized = optText.replace(/\s+/g, '').replace(/:/g, '').replace(/[ap]m/gi, '').replace(/^0+/, '');
                    const targetNormalized = hour4Digit.replace(/^0+/, '');
                    return optTextNormalized === targetNormalized;
                  });
                  
                  if (matchedOption) {
                    console.log(`‚úÖ [${stepIndex}] Matched by 4-DIGIT FORMAT: "${hour4Digit}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                  }
                }
                
                // Strategy 5: Try fuzzy matching (remove all non-numeric characters and compare)
                if (!matchedOption) {
                  const extractNumbers = (str) => {
                    return str.replace(/\D/g, '');
                  };
                  
                  const hourNumbers = extractNumbers(hour24);
                  const hour4DigitNumbers = extractNumbers(hour4Digit);
                  
                  matchedOption = options.find(option => {
                    const optionNumbers = extractNumbers(option.textContent + ' ' + option.value);
                    return optionNumbers === hourNumbers || optionNumbers === hour4DigitNumbers;
                  });
                  
                  if (matchedOption) {
                    console.log(`‚úÖ [${stepIndex}] Matched by FUZZY (numbers only): "${hour24}" ‚Üí option "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                  }
                }
                
                if (matchedOption) {
                  // Select the matched option
                  el.value = matchedOption.value;
                  el.dispatchEvent(new Event("change", { bubbles: true }));
                  el.dispatchEvent(new Event("input", { bubbles: true }));
                  el.dispatchEvent(new Event("blur", { bubbles: true }));
                  el.style.border = "2px solid #4CAF50";
                  
                  console.log(`‚úÖ [${stepIndex}] Successfully selected hour: "${matchedOption.textContent}" (value="${matchedOption.value}")`);
                  highlightElement(el, stepIndex, 'Hours Selected', matchedOption.textContent);
                  return { success: true };
                } else {
                  const availableOptions = options.map(opt => `"${opt.textContent}" (value="${opt.value}")`).join(', ');
                  console.warn(`‚ö†Ô∏è [${stepIndex}] No matching option found for hour "${hour24}" (original: "${hourValue}")`);
                  console.warn(`   ‚Ä¢ Tried: value match, text match, normalized match, fuzzy match`);
                  console.warn(`   ‚Ä¢ Available options: ${availableOptions}`);
                  
                  if (canSkip === true) {
                    console.log(`‚è≠Ô∏è [${stepIndex}] Skipping selectHours step (canSkip: true) - No match found`);
                    return { success: true, skipped: true };
                  }
                  
                  el.style.border = "2px solid #FF9800"; // Orange border to indicate warning
                  return { success: false, error: `No matching option found for hour "${hour24}"` };
                }
              } else {
                // Not a SELECT element - try to fill as text input
                console.log(`‚è∞ [${stepIndex}] Element is not a SELECT, attempting to fill as text input with 24-hour format: "${hour24}"`);
                
                // Clear and fill
                el.value = '';
                el.focus();
                el.value = hour24;
                
                // Trigger events
                el.dispatchEvent(new Event('input', { bubbles: true }));
                el.dispatchEvent(new Event('change', { bubbles: true }));
                el.dispatchEvent(new Event('blur', { bubbles: true }));
                
                el.style.border = "2px solid #4CAF50";
                console.log(`‚úÖ [${stepIndex}] Successfully filled hour as text: "${hour24}"`);
                highlightElement(el, stepIndex, 'Hours Filled', hour24);
                return { success: true };
              }
            } else {
              // Element not found
              if (canSkip === true) {
                console.log(`‚è≠Ô∏è [${stepIndex}] Skipping selectHours step (canSkip: true) - Element not found: ${selector}`);
                return { success: true, skipped: true };
              }
              console.error(`‚ùå [${stepIndex}] Element not found: ${selector}`);
              return { success: false, error: `Element not found: ${selector}` };
            }
            break;
            
          case 'ailoqLikeVerification':
            console.log(`üîç [${stepIndex}] ailoqLikeVerification action - selector: ${selector}`);
            
            try {
              // Find the target element
              if (!selector) {
                console.error(`‚ùå [${stepIndex}] No selector provided for ailoqLikeVerification`);
                return { success: false, error: 'No selector provided' };
              }
              
              // Wait for element to appear
              const targetEl = await waitFor(selector, waitTimeout || 5000);
              
              if (!targetEl) {
                console.error(`‚ùå [${stepIndex}] Element not found: ${selector}`);
                if (canSkip === true) {
                  console.log(`‚è≠Ô∏è [${stepIndex}] Skipping ailoqLikeVerification step (canSkip: true) - Element not found`);
                  return { success: true, skipped: true };
                }
                return { success: false, error: `Element not found: ${selector}` };
              }
              
              // Get the action attribute value
              const actionValue = targetEl.getAttribute('action');
              
              if (!actionValue) {
                console.error(`‚ùå [${stepIndex}] No action attribute found on element: ${selector}`);
                return { success: false, error: 'No action attribute found on target element' };
              }
              
              console.log(`üîç [${stepIndex}] Found action attribute: "${actionValue}"`);
              
              // Get findValue and formattedLink from step parameters
              const findValue = step.findValue || '';
              const formattedLink = step.formattedLink || '';
              
              if (!findValue) {
                console.error(`‚ùå [${stepIndex}] No findValue provided for ailoqLikeVerification`);
                return { success: false, error: 'No findValue provided' };
              }
              
              if (!formattedLink) {
                console.error(`‚ùå [${stepIndex}] No formattedLink provided for ailoqLikeVerification`);
                return { success: false, error: 'No formattedLink provided' };
              }
              
              console.log(`üîç [${stepIndex}] findValue: "${findValue}"`);
              console.log(`üîç [${stepIndex}] formattedLink: "${formattedLink}"`);
              
              // Extract the value after findValue
              let extractedValue = '';
              
              if (actionValue.includes(findValue)) {
                // Find the position after findValue
                const findIndex = actionValue.indexOf(findValue);
                if (findIndex !== -1) {
                  extractedValue = actionValue.substring(findIndex + findValue.length);
                  console.log(`‚úÖ [${stepIndex}] Extracted value: "${extractedValue}"`);
                } else {
                  console.error(`‚ùå [${stepIndex}] findValue "${findValue}" not found in action "${actionValue}"`);
                  return { success: false, error: `findValue not found in action attribute` };
                }
              } else {
                console.error(`‚ùå [${stepIndex}] findValue "${findValue}" not found in action "${actionValue}"`);
                return { success: false, error: `findValue not found in action attribute` };
              }
              
              // Combine formattedLink with extractedValue
              const finalUrl = formattedLink + extractedValue;
              console.log(`‚úÖ [${stepIndex}] Final URL: "${finalUrl}"`);
              
              // Highlight element before redirecting
              highlightElement(targetEl, stepIndex, 'Redirecting', finalUrl);
              
              // Save resume index (domain + current run) before redirecting - wait for write so new page sees it
              await setResumeIndexAndWait(stepIndex + 1);
              console.log(`‚úÖ [${stepIndex}] Saved resume index for ailoqLikeVerification: ${stepIndex + 1}`);
              
              // Store redirect information in storage for page load detection on new page
              chrome.storage.local.set({ 
                __AILOQ_VERIFICATION_REDIRECT__: true,
                __AILOQ_VERIFICATION_START_TIME__: Date.now(),
                __AILOQ_VERIFICATION_TARGET_URL__: finalUrl,
                __AILOQ_VERIFICATION_EXTRACTED_VALUE__: extractedValue
              }, () => {
                console.log(`‚úÖ [${stepIndex}] Stored redirect information for page load detection`);
              });
              
              // Add delay before redirect to ensure storage is saved and next steps don't trigger too fast
              // Since delays are now lower (250ms), we add extra delay to ensure proper redirect
              const redirectDelay = 500; // 500ms delay before redirect
              console.log(`‚è≥ [${stepIndex}] Waiting ${redirectDelay}ms before redirect to ensure storage is saved...`);
              await delay(redirectDelay);
              
              // Redirect to the final URL
              console.log(`üîÑ [${stepIndex}] Redirecting to: ${finalUrl}`);
              showToast(`Redirecting to verification page...`);
              
              // Perform redirect - page will reload, automation will resume on new page
              window.location.href = finalUrl;
              
              // Note: Code after this won't execute because page reloads
              // The automation will resume on the new page and check for redirect flag
              return { success: true };
              
            } catch (error) {
              console.error(`‚ùå [${stepIndex}] Error in ailoqLikeVerification:`, error);
              return { success: false, error: error.message };
            }
            break;
            
          case 'tickSubcategory':
            console.log(`üîç [${stepIndex}] Ticking subcategory checkboxes...`);
            try {
              const tickedCount = await tickSubcategoryCheckboxes();
              if (tickedCount > 0) {
                console.log(`‚úÖ [${stepIndex}] Successfully ticked ${tickedCount} subcategory checkbox(es)`);
                return { success: true };
              } else {
                console.warn(`‚ö†Ô∏è [${stepIndex}] No subcategory checkboxes were ticked`);
                return { success: true }; // Return success even if none found (non-critical)
              }
            } catch (error) {
              console.error(`‚ùå [${stepIndex}] Error ticking subcategory checkboxes:`, error);
              return { success: false, error: error.message };
            }
            break;
            
          case 'tickPaymentMethod':
          case 'tickPaymentMethods':
            console.log(`üîç [${stepIndex}] Ticking payment method checkboxes... (actionMode: ${step.actionMode || 'default'})`);
            try {
              const tickedCount = await tickPaymentMethodCheckboxes({ ...step, stepIndex });
              if (tickedCount > 0) {
                console.log(`‚úÖ [${stepIndex}] Successfully processed ${tickedCount} payment method(s)`);
                return { success: true };
              } else {
                console.warn(`‚ö†Ô∏è [${stepIndex}] No payment methods were processed`);
                return { success: true }; // Return success even if none found (non-critical)
              }
            } catch (error) {
              console.error(`‚ùå [${stepIndex}] Error processing payment methods:`, error);
              return { success: false, error: error.message };
            }
            break;
            
          case 'initClearCheckbox':
            console.log(`üîç [${stepIndex}] Clearing all checkboxes...`);
            try {
              const checkboxes = document.querySelectorAll('input[type="checkbox"]');
              let clearedCount = 0;
              checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                  checkbox.checked = false;
                  checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                  checkbox.dispatchEvent(new Event('click', { bubbles: true }));
                  clearedCount++;
                }
              });
              let clearedButtonsCount = 0;
              const buttons = Array.from(document.querySelectorAll('button, [role="button"]'));
              const isButtonSelected = (button) => {
                const ariaPressed = button.getAttribute('aria-pressed');
                const ariaChecked = button.getAttribute('aria-checked');
                if (ariaPressed && ariaPressed.toLowerCase() === 'true') return true;
                if (ariaChecked && ariaChecked.toLowerCase() === 'true') return true;
                const className = button.className || '';
                if (typeof className === 'string' && (className.toLowerCase().includes('selected') || className.toLowerCase().includes('active') || className.toLowerCase().includes('checked'))) {
                  return true;
                }
                if (button.querySelector('i[class*="tick"], i[class*="check"], i[class*="checked"]')) return true;
                return false;
              };

              for (const button of buttons) {
                if (button.disabled) continue;
                if (button.tagName.toLowerCase() === 'button' && button.type === 'submit') continue;
                if (!isButtonSelected(button)) continue;
                try {
                  if (typeof simulateMouseClick === 'function') {
                    await simulateMouseClick(button);
                  } else {
                    button.click();
                  }
                  clearedButtonsCount++;
                } catch (e) {
                  console.warn(`‚ö†Ô∏è [${stepIndex}] Failed to clear selected button`, e);
                }
              }

              // Advertising Preferences style: rows with link (ChangeAccountSettingState) + material icon check_box (checked)
              let clearedLinkCheckboxCount = 0;
              const stateLinks = document.querySelectorAll('a[href*="ChangeAccountSettingState"]');
              const processedRows = new Set();
              for (const link of stateLinks) {
                const row = link.closest('.row.mfi-listing, .row, .contentbox .row, [class*="listing"]');
                const container = row || link.closest('.contentbox, [class*="preference"]') || link.parentElement;
                if (!container || processedRows.has(container)) continue;
                const icon = container.querySelector('i.material-icons, i[class*="material-icons"]');
                if (!icon) continue;
                const iconText = (icon.textContent || '').trim();
                const iconClass = (icon.className || '').toLowerCase();
                const isChecked = iconText === 'check_box' || (iconClass.includes('check_box') && !iconClass.includes('outline'));
                if (!isChecked) continue;
                processedRows.add(container);
                try {
                  if (typeof simulateMouseClick === 'function') {
                    await simulateMouseClick(link);
                  } else {
                    link.click();
                  }
                  clearedLinkCheckboxCount++;
                  await new Promise(r => setTimeout(r, 150));
                } catch (e) {
                  console.warn(`‚ö†Ô∏è [${stepIndex}] Failed to clear link-style checkbox`, e);
                }
              }
              if (clearedLinkCheckboxCount > 0) {
                console.log(`‚úÖ [${stepIndex}] Cleared ${clearedLinkCheckboxCount} link-style preference(s) (ChangeAccountSettingState)`);
              }

              const totalCleared = clearedCount + clearedButtonsCount + clearedLinkCheckboxCount;
              console.log(`‚úÖ [${stepIndex}] Cleared ${clearedCount} checkbox(es), ${clearedButtonsCount} button(s), ${clearedLinkCheckboxCount} link-style preference(s) (total: ${totalCleared})`);
              return { success: true };
            } catch (error) {
              console.error(`‚ùå [${stepIndex}] Error clearing checkboxes:`, error);
              return { success: false, error: error.message };
            }
            break;
            
          case 'screenshot':
            console.log(`üì∏ [${stepIndex}] Screenshot step - pausing automation for user action`);
            try {
              // Pause automation
              const state = AUTOMATION_STATE.get();
              if (state) {
                state.paused = true;
              }
              paused = true;
              updateAutomationStatus(AutomationStatus.PAUSED);
              
              console.log(`‚è∏Ô∏è [${stepIndex}] Automation paused for screenshot`);
              
              // Send system notification (non-blocking)
              sendSystemNotification("CB-PHAA Automation Paused", "Automation paused for screenshot. Please take your screenshot and click Done to continue.");
              
              // Show screenshot modal and wait for user action
              const result = await showScreenshotModal();
              
              // Resume automation
              if (state) {
                state.paused = false;
              }
              paused = false;
              updateAutomationStatus(AutomationStatus.RUNNING);
              
              console.log(`‚úÖ [${stepIndex}] User clicked Done - resuming automation`);
              return { success: true };
            } catch (error) {
              // Error occurred during screenshot step
              console.log(`‚ùå [${stepIndex}] Error in screenshot step:`, error);
              
              const state = AUTOMATION_STATE.get();
              if (state) {
                state.aborted = true;
                state.paused = false;
              }
              paused = false;
              automationRunning = false;
              updateAutomationStatus(AutomationStatus.ABORTED, { error: 'User cancelled screenshot' });
              
              return { success: false, error: error.error || 'Automation cancelled by user', aborted: true };
            }
            break;
            
          case 'pause':
            console.log(`‚è∏Ô∏è [${stepIndex}] Pause step - pausing automation for user action`);
            try {
              // Pause automation
              const state = AUTOMATION_STATE.get();
              if (state) {
                state.paused = true;
              }
              paused = true;
              updateAutomationStatus(AutomationStatus.PAUSED);
              
              console.log(`‚è∏Ô∏è [${stepIndex}] Automation paused at pause step`);
              
              // Send system notification (non-blocking)
              sendSystemNotification("CB-PHAA Automation Paused", "Automation paused. Please complete any manual actions and click Done to continue.");
              
              // Show pause modal and wait for user action
              const pauseResult = await showPauseModal(step);
              
              // Resume automation
              if (state) {
                state.paused = false;
              }
              paused = false;
              updateAutomationStatus(AutomationStatus.RUNNING);
              
              console.log(`‚úÖ [${stepIndex}] User clicked Done - resuming automation`);
              return { success: true };
            } catch (error) {
              // This shouldn't happen with pause modal (no cancel button), but handle it just in case
              console.log(`‚ö†Ô∏è [${stepIndex}] Error in pause step: ${error.message || error}`);
              
              const state = AUTOMATION_STATE.get();
              if (state) {
                state.paused = false;
              }
              paused = false;
              updateAutomationStatus(AutomationStatus.RUNNING);
              
              return { success: false, error: error.error || error.message || 'Pause step error' };
            }
            break;
            
          case 'checkpoint':
            if (window.__CHECKPOINT_DISABLED__ === true) {
              console.log(`‚úÖ [${stepIndex}] Checkpoint step skipped (citationscheckpoint=false)`);
              return { success: true, skipped: true };
            }
            if (window.__CHECKPOINT_ALLOWED__ === false) {
              console.log(`‚úÖ [${stepIndex}] Checkpoint step skipped (resumeIndex not 0)`);
              return { success: true, skipped: true };
            }
            console.log(`üéØ [${stepIndex}] Checkpoint step - showing checkpoint modal`);
            try {
              // Create checkpoint info object
              const checkpointInfo = {
                stepIndex: stepIndex,
                step: step
              };
              
              // Get domain for citation info (optional)
              const domain = extractBaseDomain(window.location.hostname);
              let citationInfo = { domain: domain, isUpdated: false };
              
              // Try to get citation update status (non-blocking)
              try {
                citationInfo = await checkCitationUpdateStatus(domain);
              } catch (err) {
                console.warn(`‚ö†Ô∏è [${stepIndex}] Could not check citation status:`, err);
                // Continue with default citationInfo
              }
              
              // Show checkpoint modal
              const modalResult = await showCheckpointModal(checkpointInfo, citationInfo);
              
              if (modalResult.proceed) {
                console.log(`‚úÖ [${stepIndex}] User chose to proceed from checkpoint at step ${stepIndex}`);
                
                // Update resume index (domain + current run) to next step so automation continues
                setResumeIndex(stepIndex + 1);
                console.log(`üîÑ [CHECKPOINT] Resume index updated to continue from step ${stepIndex + 1}`);
                
                showToast(`‚úÖ Continuing from checkpoint at step ${stepIndex + 1}`);
                
                // Return success to continue normally to next step
                return { 
                  success: true
                };
              } else {
                console.log(`‚ùå [${stepIndex}] User chose not to proceed from checkpoint`);
                showToast(`‚ùå Automation cancelled by user`);
                updateAutomationStatus(AutomationStatus.ABORTED, {
                  error: 'User cancelled checkpoint',
                  endTime: new Date()
                });
                return { success: false, error: 'User cancelled checkpoint', aborted: true };
              }
            } catch (error) {
              console.log(`‚ö†Ô∏è [${stepIndex}] Error in checkpoint step: ${error.message || error}`);
              return { success: false, error: error.error || error.message || 'Checkpoint step error' };
            }
            break;
            
          case 'waitForPopup':
            console.log(`‚è≥ [${stepIndex}] WaitForPopup step - waiting for popup state...`);
            try {
              const popupSelector = waitPopupContainer || selector;
              if (!popupSelector) {
                console.error(`‚ùå [${stepIndex}] waitForPopup requires waitPopupContainer or selector`);
                return { success: false, error: 'waitForPopup requires waitPopupContainer or selector' };
              }
              
              // Parse timeout from waitPopupTimeout/value parameter (default: 10000ms)
              let timeout = 10000; // Default timeout
              const timeoutSource = waitPopupTimeout ?? value;
              if (timeoutSource !== undefined && timeoutSource !== null && timeoutSource !== '') {
                const parsedTimeout = parseInt(timeoutSource, 10);
                if (!isNaN(parsedTimeout) && parsedTimeout > 0) {
                  timeout = parsedTimeout;
                } else {
                  console.warn(`‚ö†Ô∏è [${stepIndex}] Invalid waitPopupTimeout/value "${timeoutSource}", using default ${timeout}ms`);
                }
              }
              
              const desiredState = (waitPopupState || 'open').toLowerCase();
              console.log(`‚è≥ [${stepIndex}] Waiting for popup state "${desiredState}" on selector: ${popupSelector} (timeout: ${timeout}ms)`);

              const isPopupVisible = (el) => {
                if (!el) return false;
                const style = window.getComputedStyle(el);
                const rect = el.getBoundingClientRect();
                const hiddenByAttr = el.hasAttribute('hidden') || el.getAttribute('aria-hidden') === 'true';
                return rect.width > 0 &&
                       rect.height > 0 &&
                       style.display !== 'none' &&
                       style.visibility !== 'hidden' &&
                       style.opacity !== '0' &&
                       !hiddenByAttr;
              };

              const findPopupElement = (sel) => {
                if (!sel) return null;
                const direct = document.querySelector(sel);
                if (direct) return direct;
                if (typeof findElementEnhanced === 'function') {
                  try {
                    return findElementEnhanced(sel, {
                      searchIframes: true,
                      searchShadowDOM: true,
                      searchFrames: true
                    });
                  } catch (e) {
                    return null;
                  }
                }
                return null;
              };
              
              if (desiredState === 'open') {
                const startTime = Date.now();
                const checkInterval = 200;
                while (Date.now() - startTime < timeout) {
                  const popupElement = findPopupElement(popupSelector);
                  if (popupElement && isPopupVisible(popupElement)) {
                    console.log(`‚úÖ [${stepIndex}] Popup/modal appeared and is visible: ${popupSelector}`);
                    highlightElement(popupElement, stepIndex, 'Popup Found', '');
                    return { success: true };
                  }
                  await new Promise((r) => setTimeout(r, checkInterval));
                }
                console.warn(`‚ö†Ô∏è [${stepIndex}] Popup/modal not visible within timeout: ${popupSelector}`);
                return { success: false, error: `Popup not visible within ${timeout}ms: ${popupSelector}` };
              }
              
              if (desiredState === 'closed') {
                const startTime = Date.now();
                const checkInterval = 200;
                const relatedSelectors = (() => {
                  const list = [popupSelector];
                  if (popupSelector.endsWith('-content')) {
                    list.push(popupSelector.replace(/-content$/, ''));
                  }
                  if (popupSelector.endsWith('_content')) {
                    list.push(popupSelector.replace(/_content$/, ''));
                  }
                  return Array.from(new Set(list));
                })();

                while (Date.now() - startTime < timeout) {
                  const elements = relatedSelectors
                    .map(sel => ({ sel, el: findPopupElement(sel) }))
                    .filter(item => item.el);

                  const visibleElement = elements.find(item => isPopupVisible(item.el));
                  if (!visibleElement) {
                    console.log(`‚úÖ [${stepIndex}] Popup/modal closed (removed/hidden): ${relatedSelectors.join(', ')}`);
                    return { success: true };
                  }

                  console.log(`‚è≥ [${stepIndex}] Popup still visible: ${visibleElement.sel}`);
                  await new Promise((r) => setTimeout(r, checkInterval));
                }
                
                console.warn(`‚ö†Ô∏è [${stepIndex}] Popup/modal still present after ${timeout}ms: ${popupSelector}`);
                return { success: false, error: `Popup not closed within ${timeout}ms: ${popupSelector}` };
              }
              
              console.warn(`‚ö†Ô∏è [${stepIndex}] Invalid waitPopupState "${waitPopupState}", expected "open" or "closed"`);
              return { success: false, error: `Invalid waitPopupState: ${waitPopupState}` };
            } catch (error) {
              console.error(`‚ùå [${stepIndex}] Error in waitForPopup step:`, error);
              return { success: false, error: error.message || 'waitForPopup error' };
            }
            break;
            
          default:
            return { success: false, error: `Unknown action: ${action}` };
        }
        
        return { success: true };
      } catch (error) {
        return { success: false, error: error.message };
      }
    }

    // Checkpoint stepsToSkip: skip steps whose id is in checkpoint.stepsToSkip - only when citationscheckpoint=true
    // When citationscheckpoint=false, all steps are executable (no stepsToSkip)
    // GUARANTEE: Steps are only skipped when explicitly flagged: canSkip (per-step), stepsToSkip (checkpoint list), or user backward
    let stepsToSkip = [];
    try {
      const checkpointInfo = await findCheckpointStep(steps);
      if (checkpointInfo.found && checkpointInfo.step && checkpointInfo.step.enabled !== false && !window.__CHECKPOINT_DISABLED__) {
        const step = checkpointInfo.step;
        const listPlural = step.stepsToSkip;
        const listSingular = step.stepToSkip;
        const rawList = [];
        if (Array.isArray(listPlural)) rawList.push(...listPlural);
        if (Array.isArray(listSingular)) rawList.push(...listSingular);
        stepsToSkip = rawList.map(function(id) { return id != null ? String(id).trim() : ''; }).filter(Boolean);
        if (stepsToSkip.length > 0) {
          console.log('[CHECKPOINT] stepsToSkip active: will skip step ids:', stepsToSkip);
        }
      }
    } catch (e) {
      console.warn('[CHECKPOINT] Error reading stepsToSkip:', e);
    }

    // REFACTORED: Simple and reliable automation loop
    // Steps are never skipped unless: canSkip, stepsToSkip (when citationscheckpoint), or user backward
    const fromPageLoad = options.fromPageLoad === true;
    for (let i = startIndex; i < steps.length; i++) {
      try {
        if (i >= steps.length) break;

        // Exemption for 150ms race: when resuming from page load, add extra delay before first step
        if (fromPageLoad && i === startIndex) {
          const pageLoadInitialDelayMs = 400;
          console.log(`‚è≥ [PAGE LOAD] Extra ${pageLoadInitialDelayMs}ms before first step (avoids UI race)`);
          await delay(pageLoadInitialDelayMs);
        }

        // At the start of each iteration, check current index from storage
        // This allows forward/backward buttons to change the index while RUNNING
        // and the automation loop will adopt the new index
        if (automationRunning && !AUTOMATION_STATE.get()?.paused && !AUTOMATION_STATE.get()?.aborted) {
          try {
            const currentIndexResult = await new Promise((resolve) => {
              CHROME_API.storage.local.get([key], (result) => {
                if (CHROME_API.lastError) {
                  resolve({});
                } else {
                  resolve(result);
                }
              });
            });
            const currentIndexFromStorage = currentIndexResult[key] || 0;
            
            // If user changed the index via forward/backward, adopt the new index
            if (currentIndexFromStorage !== i && currentIndexFromStorage >= 0 && currentIndexFromStorage < steps.length) {
              console.log(`üîÑ [AUTOMATION] Index changed from ${i} to ${currentIndexFromStorage} - adopting new index`);
              i = currentIndexFromStorage - 1; // Will be incremented by for loop, so subtract 1
              continue; // Skip to next iteration with new index
            }
          } catch (err) {
            console.warn(`‚ö†Ô∏è Error reading current index from storage:`, err);
            // Continue with current index if storage read fails
          }
        }

        // REFACTORED: Execute step with enhanced retry logic for required fields
        const { action, selector, valueKey, value, waitTimeout, required = false, label, description } = steps[i];
        
        // Checkpoint stepsToSkip: skip this step if its id is in the checkpoint's stepsToSkip list (ids like "1769761341173", "1770590688390-hkcmt6l")
        const stepId = steps[i].id != null ? String(steps[i].id).trim() : String(i);
        const shouldSkipByList = stepsToSkip.length > 0 && (stepsToSkip.indexOf(stepId) !== -1 || stepsToSkip.indexOf(String(i)) !== -1);
        if (shouldSkipByList) {
          console.log(`‚è≠Ô∏è [${i}] Step id "${stepId}" is in checkpoint stepsToSkip - skipping`);
          const currentState = AUTOMATION_STATE.get();
          if (!currentState || !currentState.paused) {
            setResumeIndex(i + 1);
            console.log('‚úÖ [' + i + '] Step skipped (stepsToSkip), updated resume index to: ' + (i + 1));
            const visibleStepNumber = getVisibleStepNumberFromIndex(i, steps);
            const visibleTotalSteps = getVisibleTotalSteps(steps);
            reportAutomationStatus({
              currentStep: visibleStepNumber,
              totalSteps: visibleTotalSteps,
              currentLabel: steps[i].label || '',
              currentDescription: steps[i].description || '',
              currentAction: steps[i].action || '',
              status: 'step_updated'
            });
          }
          continue;
        }
        
        // Enhanced retry logic for required fields
        const maxRetries = required ? 5 : 3; // More retries for required fields
        const baseRetryDelay = required ? 3000 : 2000; // Longer delay for required fields
        const progressiveDelay = required ? 1000 : 250; // Progressive delay increase for required fields
        
        let stepSucceeded = false;
        let retryCount = 0;
        
        console.log(`üîç [${i}] Executing step: ${action} - "${selector}" - ${valueKey || value || ''} ${required ? '(REQUIRED)' : '(optional)'}`);
        
        // Optimistic resume index: persist i+1 (domain + current run) BEFORE executing step so that if the step
        // causes a page load (click, submit, fillAndEnter, etc.), the new page loads with
        // the correct next index and does not re-execute this step. On step failure we overwrite with i below.
        setResumeIndex(i + 1);
        console.log(`üìå [${i}] Optimistic resume index set to ${i + 1} (prevents re-execute on page load)`);
        
        // Retry loop for this step with enhanced logic
        let lastError = null; // Track last error for notification
        while (!stepSucceeded && retryCount < maxRetries) {
          try {
            // Check if automation was aborted
            if (AUTOMATION_STATE.isAborted() || !automationRunning) {
              console.log(`üõë [${i}] Automation aborted - stopping execution`);
              return;
            }
            
            // Check if automation is paused or aborted BEFORE executing step
            const state = AUTOMATION_STATE.get();
            if (state && (state.paused || state.aborted)) {
              if (state.aborted) {
                console.log(`üõë [${i}] Automation aborted - stopping execution`);
                return;
              }
              if (state.paused) {
                console.log(`‚è∏Ô∏è [${i}] Automation paused - waiting for resume`);
                // Wait for resume signal
                await new Promise((r) => {
                  resumeSignal = () => {
                    r();
                  };
                });
                // Check if aborted during pause
                if (AUTOMATION_STATE.isAborted() || !automationRunning) {
                  console.log(`üõë [${i}] Automation aborted during pause - stopping execution`);
                  return;
                }
                console.log(`‚ñ∂Ô∏è [${i}] Automation resumed - continuing step execution`);
              }
            }
            
            // Double-check paused/aborted state before executing step
            const preStepState = AUTOMATION_STATE.get();
            if (preStepState && (preStepState.paused || preStepState.aborted)) {
              console.log(`‚è∏Ô∏è [${i}] Step execution skipped - automation is paused or aborted`);
              continue; // Skip this step and check again in next iteration
            }
            
            // Execute the step with total steps for progress indicator
            const result = await executeStep(steps[i], i, steps.length);
            
            // Check if paused/aborted AFTER step execution
            const postStepState = AUTOMATION_STATE.get();
            if (postStepState && (postStepState.paused || postStepState.aborted)) {
              if (postStepState.aborted) {
                console.log(`üõë [${i}] Automation aborted after step - stopping execution`);
                return;
              }
              if (postStepState.paused) {
                console.log(`‚è∏Ô∏è [${i}] Automation paused after step - waiting for resume`);
                // Wait for resume signal
                await new Promise((r) => {
                  resumeSignal = () => {
                    r();
                  };
                });
                // Check if aborted during pause
                if (AUTOMATION_STATE.isAborted() || !automationRunning) {
                  console.log(`üõë [${i}] Automation aborted during pause - stopping execution`);
                  return;
                }
                console.log(`‚ñ∂Ô∏è [${i}] Automation resumed after step - continuing`);
              }
            }
            
            // Check if step was aborted (e.g., screenshot cancelled)
            if (result.aborted) {
              console.log(`üõë [${i}] Step aborted automation - stopping execution`);
              return;
            }
            
            // Check if checkpoint action was executed and user chose to proceed
            if (result.checkpoint && result.checkpointIndex !== undefined) {
              console.log(`üéØ [${i}] Checkpoint action executed - restarting from step ${result.checkpointIndex}`);
              stepSucceeded = true;
              // Update loop index to restart from checkpoint (skip all previous steps)
              i = result.checkpointIndex - 1; // Will be incremented by for loop, so subtract 1
              console.log(`üîÑ [CHECKPOINT] Restarting automation loop from step ${result.checkpointIndex} (skipping steps 0-${result.checkpointIndex - 1})`);
              continue; // Skip to next iteration starting from checkpoint
            }
            
            if (result.success) {
              stepSucceeded = true;
              const currentState = AUTOMATION_STATE.get();
              if (!currentState || !currentState.paused) {
                setResumeIndex(i + 1);
                console.log(`‚úÖ [${i}] Step succeeded, updated resume index to: ${i + 1}`);
                const visibleStepNumber = getVisibleStepNumberFromIndex(i, steps);
                const visibleTotalSteps = getVisibleTotalSteps(steps);
                reportAutomationStatus({
                  currentStep: visibleStepNumber,
                  totalSteps: visibleTotalSteps,
                  currentLabel: steps[i].label || "",
                  currentDescription: steps[i].description || "",
                  currentAction: steps[i].action || "",
                  status: 'step_updated'
                });
              } else {
                console.log(`‚è∏Ô∏è [${i}] Step succeeded but automation is paused - not updating counter`);
              }
            } else {
              // Execute once, then validate: only retry on execution error (exception), not on validation/logic failure
              lastError = result.error || 'Unknown error';
              console.warn(`‚ùå [${i}] Step failed (no retry - validation/result failure): ${lastError}`);
              stepSucceeded = false;
              break; // Exit retry loop; do not retry on result.success === false
            }
          } catch (error) {
            retryCount++;
            lastError = error.message || String(error); // Store error for notification
            const retryDelay = baseRetryDelay + (retryCount * progressiveDelay);
            console.error(`‚ùå [${i}] Step error (retry ${retryCount}/${maxRetries}):`, error);
            
            if (retryCount < maxRetries) {
              console.log(`‚è≥ [${i}] Waiting ${retryDelay}ms before retry... (${required ? 'required field' : 'optional field'})`);
              await delay(retryDelay);
            }
          }
        }
        
        // REFACTORED: If step failed (once or after retries), pause automation. Retries only happen on execution error.
        if (!stepSucceeded) {
          console.error(`‚ùå [${i}] Step failed${retryCount > 0 ? ` after ${retryCount} retry(ies)` : ''} - PAUSING automation`);
          
          // Send system notification for error (non-blocking)
          const stepAction = steps[i]?.action || 'unknown';
          const errorMessage = lastError 
            ? `Step ${i + 1} (${stepAction}) failed: ${lastError}. Automation has been paused.`
            : `Step ${i + 1} (${stepAction}) failed${retryCount > 0 ? ` after ${retryCount} retries` : ''}. Automation has been paused.`;
          sendSystemNotification("CB-PHAA Automation Error", errorMessage);
          
          // Save current index (domain + current run) and pause automation
          setResumeIndex(i);
          console.log(`üíæ [${i}] Saved resume index ${i} due to step failure`);
          
          // Pause automation
          automationRunning = false;
          automationStarting = false;
          
          // Set pause state
          if (window.__AUTOMATION_STATE__) {
            window.__AUTOMATION_STATE__.paused = true;
          }
          
          // Update automation status to paused
          const visibleStepNumber = getVisibleStepNumberFromIndex(i, steps);
          const totalStepsCount = getVisibleTotalSteps(steps);
          updateAutomationStatus(AutomationStatus.PAUSED, {
            currentStep: visibleStepNumber,
            totalSteps: totalStepsCount,
            error: retryCount > 0 ? `Step ${i + 1} failed after ${retryCount} retries` : `Step ${i + 1} failed`
          });
          
          // Report the failure and pause
          reportAutomationStatus({
            isRunning: false,
            isPaused: true,
            currentStep: visibleStepNumber,
            totalSteps: totalStepsCount,
            currentLabel: steps[i].label || "",
            currentDescription: steps[i].description || "",
            currentAction: steps[i].action || "",
            currentSelector: selector,
            status: "paused_step_failed"
          });
          
          showToast(`Step ${i + 1} failed${retryCount > 0 ? ` after ${retryCount} retry(ies)` : ''} - Automation PAUSED`);
          console.warn(`‚è∏Ô∏è Step ${i + 1} failed, automation PAUSED - use play button to resume`);
          
          // Wait for user resume
          await new Promise((r) => {
            resumeSignal = () => {
              r();
            };
          });
          
          // Check if automation was aborted during pause
          if (window.__AUTOMATION_STATE__ && window.__AUTOMATION_STATE__.aborted) {
            console.log("üõë Automation was aborted during pause");
            return;
          }
          
          // Resume automation
          console.log("‚ñ∂Ô∏è Automation resumed from pause");
          updateAutomationStatus(AutomationStatus.RUNNING);
          reportAutomationStatus({ isRunning: true, status: 'resumed' });
          
          // Restart automation from current step
          automationRunning = true;
          automationStarting = false;
        }

        // Short fixed pause between steps (step controller "delay" is applied inside executeStep, before each step)
        const betweenStepPauseMs = 150;
        if (betweenStepPauseMs > 0) {
          console.log(`‚è≥ [${i}] Pause ${betweenStepPauseMs}ms before next step...`);
          await delay(betweenStepPauseMs);
        }
        
        // Check if aborted during delay
        if (AUTOMATION_STATE.isAborted() || !automationRunning) {
          console.log(`üõë [${i}] Automation aborted during delay - stopping execution`);
          return;
        }
        
        // REFACTORED: Step execution is now handled by executeStep function above
        // All step execution logic has been moved to the executeStep function
        
      } catch (err) {
        console.error(`‚ùå [${i}] Error during action`, err);
      }
    }
    
    // Automation completed
    const visibleTotalSteps = getVisibleTotalSteps(steps);
    console.log(`üéâ [DEBUG] ===== AUTOMATION COMPLETED SUCCESSFULLY =====`);
    console.log(`   ‚Ä¢ Total steps processed: ${steps.length}`);
    console.log(`   ‚Ä¢ Final URL: ${window.location.href}`);
    console.log(`   ‚Ä¢ Completion time: ${new Date().toISOString()}`);
    console.log(`   ‚Ä¢ Duration: ${Date.now() - performance.timing.navigationStart}ms since page load`);
    console.log(`‚úÖ Automation completed successfully`);
    
    // Set completion flag to prevent restart/looping
    const completionKey = getTabSpecificCompletionKey();
    const completionData = {
      completed: true,
      completedAt: new Date().toISOString(),
      domain: extractBaseDomain(window.location.hostname),
      totalSteps: steps.length,
      finalUrl: window.location.href
    };
    
    chrome.storage.local.set({ [completionKey]: completionData }, () => {
      console.log(`üèÅ [COMPLETION] Set completion flag for domain: ${extractBaseDomain(window.location.hostname)}`);
    });
    
    showToast('Automation Complete');
    updateAutomationStatus(AutomationStatus.COMPLETED, {
      endTime: new Date(),
      isCompleted: true,
      currentStep: visibleTotalSteps
    });
    
    // Send system notification for completion (non-blocking)
    sendSystemNotification(
      "CB-PHAA Automation Complete",
      `Automation completed successfully! All ${visibleTotalSteps} steps have been processed.`
    );
    
    // Add delay to prevent immediate restart
    console.log(`‚è≥ [COMPLETION] Adding 5-second delay to prevent restart...`);
    await new Promise(resolve => setTimeout(resolve, 5000));
    console.log(`‚úÖ [COMPLETION] Delay completed - automation fully terminated`);
    
    // Increment citation count when automation completes successfully
    try {
      const eligibilityResponse = await new Promise((resolve) => {
        CHROME_API.runtime.sendMessage({ type: "CHECK_ELIGIBILITY" }, (response) => {
          if (CHROME_API.lastError) {
            console.warn("Chrome runtime error:", CHROME_API.lastError.message);
            resolve(null);
          } else {
            resolve(response);
          }
        });
      });

      if (eligibilityResponse && eligibilityResponse.success && eligibilityResponse.isEligible) {
        console.log(`üìà User is eligible for citation count increment: ${eligibilityResponse.reason}`);
        
        // Get user ID from storage
        const userData = await new Promise((resolve) => {
          CHROME_API.storage.local.get(["userId"], (result) => {
            if (CHROME_API.lastError) {
              console.warn("Storage error:", CHROME_API.lastError.message);
              resolve({});
            } else {
              resolve(result);
            }
          });
        });
        const userId = userData.userId;
        
        if (!userId) {
          console.warn("‚ö†Ô∏è No user ID found for citation increment - skipping increment but will still save citation_accumulation");
        } else {
          // Only proceed with citation increment if userId is available
          const incrementResponse = await new Promise((resolve) => {
          chrome.runtime.sendMessage({ type: "INCREMENT_CITATION", planDocId: userId }, (response) => {
            if (chrome.runtime.lastError) {
              console.warn("Citation increment error:", chrome.runtime.lastError.message);
              resolve(null);
            } else {
              resolve(response);
            }
          });
        });

        if (incrementResponse && incrementResponse.success) {
          console.log(`‚úÖ Citation count incremented successfully: ${incrementResponse.newCount}`);
        } else {
          console.warn("‚ö†Ô∏è Failed to increment citation count");
        }
        
        // Also increment daily citation accumulation document
        try {
          const accumulationResult = await new Promise((resolve) => {
            CHROME_API.runtime.sendMessage(
              { type: "INCREMENT_CITATION_ACCUMULATION", userId },
              (response) => {
                if (CHROME_API.runtime.lastError) {
                  console.warn(
                    "Citation accumulation increment error:",
                    CHROME_API.runtime.lastError.message
                  );
                  resolve(null);
                } else {
                  resolve(response);
                }
              }
            );
          });
          if (accumulationResult && accumulationResult.success) {
            console.log("‚úÖ [ACCUMULATION] Daily citation accumulation incremented");
          } else {
            console.warn("‚ö†Ô∏è [ACCUMULATION] Failed to increment daily citation accumulation");
          }
        } catch (e) {
          console.warn("‚ö†Ô∏è [ACCUMULATION] Exception while incrementing daily accumulation", e);
        }
        
        // Save automation accumulation with COMPLETE status
        try {
          const domainName = extractBaseDomain(window.location.hostname);
          
          // Get CampID from campaignData
          const campaignData = await new Promise((resolve) => {
            CHROME_API.storage.local.get(["CampaignData"], (result) => {
              if (CHROME_API.lastError) {
                console.warn("CampaignData storage error:", CHROME_API.lastError.message);
                resolve({});
              } else {
                resolve(result);
              }
            });
          });
          
          console.log("üìä [ACCUMULATION] CampaignData retrieved:", campaignData);
          console.log("üìä [ACCUMULATION] CampaignData.CampaignData:", campaignData.CampaignData);
          
          const campId = campaignData.CampaignData?.campaignData?.idBox || null;
          
          if (!campId) {
            console.warn("‚ö†Ô∏è [ACCUMULATION] No CampID found in CampaignData");
            console.warn("‚ö†Ô∏è [ACCUMULATION] Available keys in CampaignData:", campaignData.CampaignData ? Object.keys(campaignData.CampaignData) : "CampaignData is null/undefined");
            console.warn("‚ö†Ô∏è [ACCUMULATION] idBox value:", campaignData.CampaignData?.campaignData?.idBox);
          } else {
            console.log("‚úÖ [ACCUMULATION] CampID found:", campId);
          }
          
          const accumulationResponse = await new Promise((resolve) => {
            CHROME_API.runtime.sendMessage({ 
              type: "SAVE_AUTOMATION_ACCUMULATION", 
              userId: userId, 
              campId: campId,
              domainName: domainName, 
              status: "COMPLETE" 
            }, (response) => {
              if (CHROME_API.lastError) {
                console.warn("Accumulation save error:", CHROME_API.lastError.message);
                resolve(null);
              } else {
                resolve(response);
              }
            });
          });
          
          // Removed: citation accumulation save here (moved to always-run section below)
          
          // Note: Firestore connection test removed to prevent test document creation
        } catch (error) {
          console.error("‚ùå [ACCUMULATION] Error saving automation accumulation:", error);
        }
        } // End of if (userId) else block
      } else {
        console.log(`‚è≠Ô∏è User not eligible for citation increment: ${eligibilityResponse?.reason || 'Unknown reason'}`);
      }
    } catch (error) {
      console.error("Error during citation count increment:", error);
    }
    
    // Always save citation accumulation for Completed status, regardless of eligibility
    // Wait for page to be stable after last step execution to prevent interruption
    try {
      console.log(`‚è≥ [CITATION_ACCUMULATION] Waiting for page to stabilize after last step execution...`);
      
      // Helper function to check if page is loaded and stable
      const isPageReadyForSave = () => {
        // Check document ready state
        if (document.readyState !== 'complete') {
          console.log(`‚è≥ [CITATION_ACCUMULATION] Document not complete: ${document.readyState}`);
          return false;
        }
        
        // Check for common loading indicators
        const loadingIndicators = document.querySelectorAll('[class*="loading"], [class*="spinner"], [class*="loader"], .loading, .spinner, .loader');
        if (loadingIndicators.length > 0) {
          console.log(`‚è≥ [CITATION_ACCUMULATION] Loading indicators found: ${loadingIndicators.length}`);
          return false;
        }
        
        return true;
      };
      
      // Wait for page to be stable with retry logic
      const waitForPageStable = async (maxWaitTime = 10000, checkInterval = 500, minWaitTime = 2000) => {
        const startTime = Date.now();
        let stableCount = 0;
        const requiredStableChecks = 3; // Need 3 consecutive stable checks
        
        return new Promise((resolve) => {
          const checkStability = () => {
            const elapsed = Date.now() - startTime;
            
            // Ensure minimum wait time
            if (elapsed < minWaitTime) {
              console.log(`‚è≥ [CITATION_ACCUMULATION] Minimum wait time not reached (${elapsed}ms/${minWaitTime}ms)...`);
              setTimeout(checkStability, checkInterval);
              return;
            }
            
            // Check if max wait time exceeded
            if (elapsed > maxWaitTime) {
              console.log(`‚è∞ [CITATION_ACCUMULATION] Maximum wait time reached (${elapsed}ms), proceeding with save...`);
              resolve(true);
              return;
            }
            
            // Check if page is stable
            if (isPageReadyForSave()) {
              stableCount++;
              console.log(`‚úÖ [CITATION_ACCUMULATION] Page stable check ${stableCount}/${requiredStableChecks} (${elapsed}ms elapsed)`);
              
              if (stableCount >= requiredStableChecks) {
                console.log(`‚úÖ [CITATION_ACCUMULATION] Page is stable and ready for save (${elapsed}ms)`);
                resolve(true);
                return;
              }
            } else {
              stableCount = 0; // Reset stable count if page is not stable
              console.log(`‚è≥ [CITATION_ACCUMULATION] Page not stable yet (${elapsed}ms elapsed)...`);
            }
            
            // Continue checking
            setTimeout(checkStability, checkInterval);
          };
          
          // Start checking after initial delay
          setTimeout(checkStability, checkInterval);
        });
      };
      
      // Wait for page to be stable before saving
      await waitForPageStable(10000, 500, 2000);
      console.log(`‚úÖ [CITATION_ACCUMULATION] Page is stable, proceeding with citation_accumulation save...`);
      
      const domainName = extractBaseDomain(window.location.hostname);
      
      // Get user ID from storage
      const userData = await new Promise((resolve) => {
        CHROME_API.storage.local.get(["userId"], (result) => {
          if (CHROME_API.lastError) {
            console.warn("Storage error while fetching userId:", CHROME_API.lastError.message);
            resolve({});
          } else {
            resolve(result);
          }
        });
      });
      const userId = userData.userId;
      
      if (!userId) {
        console.warn("‚ö†Ô∏è [CITATION_ACCUMULATION] Skipping save: userId not found");
      } else {
        // Get CampID from campaignData
        const campaignData = await new Promise((resolve) => {
          CHROME_API.storage.local.get(["CampaignData"], (result) => {
            if (CHROME_API.lastError) {
              console.warn("CampaignData storage error:", CHROME_API.lastError.message);
              resolve({});
            } else {
              resolve(result);
            }
          });
        });
        const campId = campaignData.CampaignData?.campaignData?.idBox || null;
        const fallbackCampId = campId || `unknown_${Date.now()}`;
        
        console.log(`üìä [CITATION_ACCUMULATION] Final save (Completed). Params:`, { userId, campaignID: fallbackCampId, domainName, index: steps.length - 1 });
        
        const citationAccumulationResponse = await new Promise((resolve) => {
          CHROME_API.runtime.sendMessage({ 
            type: "SAVE_CITATION_ACCUMULATION", 
            userId: userId,
            campaignID: fallbackCampId,
            domainName: domainName,
            status: "Completed",
            index: steps.length - 1
          }, (response) => {
            if (CHROME_API.lastError) {
              console.error("‚ùå [CITATION_ACCUMULATION] Chrome API error:", CHROME_API.lastError.message);
              resolve({ success: false, error: CHROME_API.lastError.message });
            } else {
              resolve(response);
            }
          });
        });
        
        if (citationAccumulationResponse && citationAccumulationResponse.success) {
          console.log("‚úÖ [CITATION_ACCUMULATION] Completed citation accumulation saved:", citationAccumulationResponse.accumulationId);
        } else {
          console.warn("‚ö†Ô∏è [CITATION_ACCUMULATION] Failed to save completed accumulation:", citationAccumulationResponse?.error);
        }
      }
    } catch (e) {
      console.error("‚ùå [CITATION_ACCUMULATION] Exception while saving completed accumulation:", e);
    }
    
    // Set automation status and clean up
    automationRunning = false;
    automationStarting = false;
    notifyPopupOfAutomationStatus(false);
    
    // Clean up progress indicator
    const progressIndicator = document.getElementById('automation-progress');
    if (progressIndicator) {
      progressIndicator.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 5px;">
          <div style="background: #4CAF50; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px;"></div>
          <strong>Automation Complete!</strong>
        </div>
        <div style="font-size: 12px; opacity: 0.9;">
          All steps completed successfully
        </div>
      `;
      setTimeout(() => progressIndicator.remove(), 3000);
    }
    
    // Clear resume index (domain + current run) after completion
    clearResumeIndex();
    console.log(`üßπ Reset resume index to 0 after completion for domain ${extractBaseDomain(window.location.hostname)}`);
    
    // Reset page title
    document.title = originalTitle || document.title.replace(/^[‚ñ∂Ô∏è‚è∏Ô∏èüõë]\s*/, '');
    
    console.log(`üèÅ [DEBUG] ===== AUTOMATION ENDED =====`);
  }

  // Helper function to get tab-specific resume index key
  function getTabSpecificResumeIndexKey() {
    const domain = extractBaseDomain(window.location.hostname);
    // Use domain-only tracking instead of tab-specific to avoid confusion
    return `resumeIndex_${domain}`;
  }

  // Current-run resume index: survives domain change so we don't rollback to step 1 on navigation
  const RESUME_INDEX_CURRENT_RUN_KEY = 'resumeIndex_currentRun';

  function setResumeIndex(value) {
    const domainKey = getTabSpecificResumeIndexKey();
    const payload = { [domainKey]: value, [RESUME_INDEX_CURRENT_RUN_KEY]: value };
    if (typeof CHROME_API !== 'undefined' && CHROME_API.storage && CHROME_API.storage.local) {
      CHROME_API.storage.local.set(payload, function() {
        if (CHROME_API.runtime && CHROME_API.runtime.lastError) {
          console.warn('Resume index write error:', CHROME_API.runtime.lastError.message);
        }
      });
    } else if (chrome && chrome.storage && chrome.storage.local) {
      chrome.storage.local.set(payload, function() {
        if (chrome.runtime && chrome.runtime.lastError) {
          console.warn('Resume index write error:', chrome.runtime.lastError.message);
        }
      });
    }
  }

  function setResumeIndexAndWait(value) {
    const domainKey = getTabSpecificResumeIndexKey();
    const payload = { [domainKey]: value, [RESUME_INDEX_CURRENT_RUN_KEY]: value };
    return new Promise(function(resolve) {
      if (typeof CHROME_API !== 'undefined' && CHROME_API.storage && CHROME_API.storage.local) {
        CHROME_API.storage.local.set(payload, function() {
          if (CHROME_API.runtime && CHROME_API.runtime.lastError) {
            console.warn('Resume index write error:', CHROME_API.runtime.lastError.message);
          }
          resolve();
        });
      } else if (chrome && chrome.storage && chrome.storage.local) {
        chrome.storage.local.set(payload, function() {
          if (chrome.runtime && chrome.runtime.lastError) {
            console.warn('Resume index write error:', chrome.runtime.lastError.message);
          }
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  function clearResumeIndex() {
    setResumeIndex(0);
  }

  // Handle page load and check for resume
  async function handlePageLoad() {
    // CRITICAL: Validate URL before any operations to prevent crashes
    if (!isValidPage()) {
      console.log('üö´ [PAGE LOAD] Skipping - invalid page type');
      return;
    }
    
    console.log(`üîç [PAGE LOAD] Checking for resume index:`);
    console.log(`   ‚Ä¢ URL: ${window.location.href}`);
    console.log(`   ‚Ä¢ Domain: ${window.location.hostname}`);

    // Add error handling for chrome API calls
    try {
      await getCurrentTabId();
    } catch (error) {
      console.error('üö´ [PAGE LOAD] Error getting tab ID:', error);
      return;
    }
    
    const key = getTabSpecificResumeIndexKey();
    
    // Reset automation state on page load (except for abort/pause states)
    if (window.__AUTOMATION_STATE__) {
      // Only reset running states, preserve abort/pause states
      if (!window.__AUTOMATION_STATE__.aborted && !window.__AUTOMATION_STATE__.paused) {
        window.__AUTOMATION_STATE__.status = AutomationStatus.IDLE;
        window.__AUTOMATION_STATE__.isCompleted = false;
        console.log(`üîÑ [PAGE LOAD] Reset automation state to IDLE`);
      }
    }

    // Add error handling for chrome.storage calls
    try {
      if (!chrome || !chrome.storage || !chrome.storage.local) {
        console.warn('üö´ [PAGE LOAD] Chrome storage API not available');
        return;
      }
      
      chrome.storage.local.get([key, RESUME_INDEX_CURRENT_RUN_KEY, 'autoStartEnabled', 'CampaignData', '__AILOQ_VERIFICATION_REDIRECT__', '__AILOQ_VERIFICATION_START_TIME__', '__AILOQ_VERIFICATION_TARGET_URL__', '__AILOQ_VERIFICATION_EXTRACTED_VALUE__'], async (result) => {
        // Check for Chrome API errors
        if (chrome.runtime.lastError) {
          console.error('üö´ [PAGE LOAD] Chrome storage error:', chrome.runtime.lastError.message);
          return;
        }
        const domainIndex = result[key] || 0;
        const currentRunIndex = result[RESUME_INDEX_CURRENT_RUN_KEY] || 0;
        const resumeIndex = Math.max(domainIndex, currentRunIndex);
        const autoStartEnabled = result.autoStartEnabled !== undefined ? result.autoStartEnabled : true; // Default to true for backward compatibility
        const ailoqRedirect = result.__AILOQ_VERIFICATION_REDIRECT__;
        const ailoqStartTime = result.__AILOQ_VERIFICATION_START_TIME__;
        const ailoqTargetUrl = result.__AILOQ_VERIFICATION_TARGET_URL__;
        const ailoqExtractedValue = result.__AILOQ_VERIFICATION_EXTRACTED_VALUE__;
        
        console.log(`üîç [PAGE LOAD] Resume index: ${resumeIndex} (domain: ${domainIndex}, currentRun: ${currentRunIndex})`);
        console.log(`üîç [PAGE LOAD] Auto-start enabled: ${autoStartEnabled}`);
        
        // Check if this is a redirect from ailoqLikeVerification
        if (ailoqRedirect && ailoqStartTime) {
          console.log(`üîÑ [PAGE LOAD] ailoqLikeVerification redirect detected - waiting for page to fully load...`);
          console.log(`   ‚Ä¢ Target URL: ${ailoqTargetUrl}`);
          console.log(`   ‚Ä¢ Extracted value: ${ailoqExtractedValue}`);
          
          // Wait for page to be fully loaded and stable before proceeding
          const waitForPageStable = async () => {
            const maxWaitTime = 30000; // 30 seconds maximum
            const checkInterval = 250; // Check every 250ms (faster since delays are lower)
            const minWaitTime = 2000; // Minimum 2 seconds wait
            const requiredStableChecks = 5; // Need 5 consecutive stable checks
            let stableCount = 0;
            let lastUrl = window.location.href;
            let lastContentHash = '';
            let lastTitle = document.title;
            
            // Function to generate content hash
            const getContentHash = () => {
              const bodyText = document.body ? document.body.innerText : '';
              const url = window.location.href;
              const title = document.title;
              const content = bodyText + url + title;
              let hash = 0;
              if (content.length === 0) return '0';
              for (let i = 0; i < content.length; i++) {
                const char = content.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
              }
              return Math.abs(hash).toString(36).substring(0, 20);
            };
            
            // Function to check if page is stable
            const isPageStable = () => {
              const currentHash = getContentHash();
              const currentUrl = window.location.href;
              const currentTitle = document.title;
              
              // Check if URL matches target or contains extracted value
              const urlMatches = ailoqTargetUrl && currentUrl.includes(ailoqTargetUrl.split('/').pop()) ||
                                ailoqExtractedValue && currentUrl.includes(ailoqExtractedValue);
              
              if (!urlMatches && ailoqTargetUrl) {
                console.log(`‚è≥ [PAGE LOAD] Not yet on target URL (current: ${currentUrl}, target: ${ailoqTargetUrl})`);
                return false;
              }
              
              // Check if content has changed recently
              const contentChanged = currentHash !== lastContentHash;
              const urlChanged = currentUrl !== lastUrl;
              const titleChanged = currentTitle !== lastTitle;
              
              if (contentChanged || urlChanged || titleChanged) {
                if (contentChanged) {
                  console.log(`üîÑ [PAGE LOAD] Content hash changed`);
                  lastContentHash = currentHash;
                }
                if (urlChanged) {
                  console.log(`üîÑ [PAGE LOAD] URL changed: ${lastUrl} ‚Üí ${currentUrl}`);
                  lastUrl = currentUrl;
                }
                if (titleChanged) {
                  console.log(`üîÑ [PAGE LOAD] Title changed: ${lastTitle} ‚Üí ${currentTitle}`);
                  lastTitle = currentTitle;
                }
                stableCount = 0; // Reset on change
                return false;
              }
              
              // Check document ready state
              if (document.readyState !== 'complete') {
                console.log(`‚è≥ [PAGE LOAD] Document not complete: ${document.readyState}`);
                return false;
              }
              
              // Check for loading indicators
              const loadingIndicators = document.querySelectorAll('[class*="loading"], [class*="spinner"], [class*="loader"], .loading, .spinner, .loader');
              if (loadingIndicators.length > 0) {
                console.log(`‚è≥ [PAGE LOAD] Loading indicators found: ${loadingIndicators.length}`);
                return false;
              }
              
              return true;
            };
            
            return new Promise((resolve) => {
              const checkPageLoad = () => {
                const elapsed = Date.now() - ailoqStartTime;
                
                // Check timeout
                if (elapsed > maxWaitTime) {
                  console.log(`‚è∞ [PAGE LOAD] Maximum wait time reached (${elapsed}ms), continuing...`);
                  // Clear redirect flag
                  chrome.storage.local.remove(['__AILOQ_VERIFICATION_REDIRECT__', '__AILOQ_VERIFICATION_START_TIME__', '__AILOQ_VERIFICATION_TARGET_URL__', '__AILOQ_VERIFICATION_EXTRACTED_VALUE__'], () => {
                    console.log(`‚úÖ [PAGE LOAD] Cleared ailoqLikeVerification redirect flags`);
                  });
                  resolve(true);
                  return;
                }
                
                // Ensure minimum wait time
                if (elapsed < minWaitTime) {
                  setTimeout(checkPageLoad, checkInterval);
                  return;
                }
                
                // Check if page is stable
                if (isPageStable()) {
                  stableCount++;
                  console.log(`‚úÖ [PAGE LOAD] Page stable check ${stableCount}/${requiredStableChecks} (${elapsed}ms elapsed)`);
                  
                  if (stableCount >= requiredStableChecks) {
                    console.log(`‚úÖ [PAGE LOAD] Page load completed and stable (${elapsed}ms) - ready to continue automation`);
                    // Clear redirect flag
                    chrome.storage.local.remove(['__AILOQ_VERIFICATION_REDIRECT__', '__AILOQ_VERIFICATION_START_TIME__', '__AILOQ_VERIFICATION_TARGET_URL__', '__AILOQ_VERIFICATION_EXTRACTED_VALUE__'], () => {
                      console.log(`‚úÖ [PAGE LOAD] Cleared ailoqLikeVerification redirect flags`);
                    });
                    resolve(true);
                    return;
                  }
                } else {
                  stableCount = 0; // Reset if not stable
                }
                
                // Continue checking
                setTimeout(checkPageLoad, checkInterval);
              };
              
              // Start checking after initial delay
              setTimeout(checkPageLoad, checkInterval);
            });
          };
          
          // Wait for page to be stable, then proceed with automation
          waitForPageStable().then(() => {
            console.log(`üöÄ [PAGE LOAD] ailoqLikeVerification redirect complete - proceeding with automation`);
            proceedWithAutomation();
          });
          
          return; // Don't proceed yet, wait for page stability
        }
        
        // Normal page load flow (no redirect)
        proceedWithAutomation();
        
        async function proceedWithAutomation() {
          // Check if automation was previously aborted or paused
          const state = window.__AUTOMATION_STATE__;
          if (state && (state.aborted || state.paused)) {
            console.log(`‚è∏Ô∏è [PAGE LOAD] Automation was ${state.aborted ? 'aborted' : 'paused'}, waiting for manual resume`);
            return;
          }
          
          // Check if auto-start is enabled
          if (!autoStartEnabled) {
            console.log(`‚è∏Ô∏è [PAGE LOAD] Auto-start is disabled, skipping automation start`);
            return;
          }

          // On page load: only sync to checkpoint when we haven't progressed past it
          // Flow: execute -> update resumeIndex -> pageLoad -> check resumeIndex -> execute from resumeIndex
          // Do NOT overwrite resumeIndex when we've already passed the checkpoint (prevents loop)
          const domain = extractBaseDomain(window.location.hostname);
          let effectiveResumeIndex = resumeIndex;
          try {
            if (!window.__CHECKPOINT_DISABLED__) {
              const steps = await loadSteps();
              if (steps && steps.length > 0) {
                const checkpointInfo = await findCheckpointStep(steps);
                if (checkpointInfo.found && resumeIndex < checkpointInfo.stepIndex) {
                  await setResumeIndexAndWait(checkpointInfo.stepIndex);
                  effectiveResumeIndex = checkpointInfo.stepIndex;
                  console.log(`üîç [PAGE LOAD] Checkpoint sync: resume was ${resumeIndex} (before checkpoint), set to ${checkpointInfo.stepIndex}`);
                } else if (checkpointInfo.found && resumeIndex >= checkpointInfo.stepIndex) {
                  console.log(`üîç [PAGE LOAD] Keeping resume index ${resumeIndex} (already past checkpoint at ${checkpointInfo.stepIndex})`);
                }
              }
            }
          } catch (e) {
            console.warn('[PAGE LOAD] Checkpoint sync skipped:', e.message || e);
          }

          console.log(`üöÄ [PAGE LOAD] Starting automation from resume index ${effectiveResumeIndex}...`);
          // Exemption for 150ms race: wait for page + DOM/UI stability before starting
          // Ensures no steps are skipped due to page load or UI delay (only canSkip/stepsToSkip skip)
          const waitForPageStable = () => new Promise((resolve) => {
            const minStableMs = 800;
            const maxWaitMs = 15000;
            const checkInterval = 100;
            let elapsed = 0;
            const check = () => {
              const ready = document.readyState === 'complete';
              if (ready && elapsed >= minStableMs) {
                console.log(`‚úÖ [PAGE LOAD] Page stable (ready + ${elapsed}ms) - starting automation`);
                resolve();
                return;
              }
              if (elapsed >= maxWaitMs) {
                console.log(`‚è∞ [PAGE LOAD] Max wait ${maxWaitMs}ms - proceeding anyway`);
                resolve();
                return;
              }
              elapsed += checkInterval;
              setTimeout(check, checkInterval);
            };
            check();
          });
          waitForPageStable().then(() => runAutomation(false, { fromPageLoad: true }));
        }
      });
    } catch (error) {
      console.error('üö´ [PAGE LOAD] Error accessing chrome.storage:', error);
      return;
    }
  }

  // Wait for DOM and trigger page load handler
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', handlePageLoad);
  } else {
    handlePageLoad();
  }

  // Enhanced NextButtonSave detection
  function isNextButtonSave(step) {
    return step.valueKey === 'NextButtonSave' || 
           (step.action === 'click' && step.label && step.label.toLowerCase().includes('next'));
  }

  // Page change detection for NextButtonSave
  let originalUrl = window.location.href;
  let originalTitle = document.title;
  let urlCheckInterval = null;
  let domObserver = null;

  function checkUrlChange() {
    if (window.__NEXT_BUTTON_SAVE_PENDING__) {
      if (window.location.href !== originalUrl || document.title !== originalTitle) {
        console.log(`üîÑ [NextButtonSave] Page navigation detected!`);
        console.log(`   ‚Ä¢ URL changed: ${originalUrl} ‚Üí ${window.location.href}`);
        console.log(`   ‚Ä¢ Title changed: ${originalTitle} ‚Üí ${document.title}`);
        
        originalUrl = window.location.href;
        originalTitle = document.title;
        
        // Reset the start time for the new page
        window.__NEXT_BUTTON_SAVE_START_TIME__ = Date.now();
        
        console.log(`üîÑ [NextButtonSave] Page navigation confirmed, waiting for new page to load...`);
        
        // Don't immediately continue - let the waitForPageLoad function handle the timing
        // This ensures we wait for the new page to fully load before continuing
      }
    }
  }

  // DOM change detection as backup for NextButtonSave
  function checkDomChange() {
    if (window.__NEXT_BUTTON_SAVE_PENDING__) {
      console.log(`üîÑ DOM change detected while NextButtonSave is pending, checking for navigation...`);
      checkUrlChange();
    }
  }

  // Start change detection only when NextButtonSave is pending
  function startChangeDetection() {
    // Only start if not already running
    if (urlCheckInterval || domObserver) return;
    
    // Start URL checking interval
    urlCheckInterval = setInterval(checkUrlChange, 1000);
    
    // Start DOM observer
    if (document.body) {
      domObserver = new MutationObserver(checkDomChange);
      domObserver.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: false
      });
    }
  }

  // Stop change detection when not needed
  function stopChangeDetection() {
    if (urlCheckInterval) {
      clearInterval(urlCheckInterval);
      urlCheckInterval = null;
    }
    if (domObserver) {
      domObserver.disconnect();
      domObserver = null;
    }
  }

  // Watch for NextButtonSave state changes
  const originalNextButtonSavePending = window.__NEXT_BUTTON_SAVE_PENDING__;
  Object.defineProperty(window, '__NEXT_BUTTON_SAVE_PENDING__', {
    get: function() {
      return this._nextButtonSavePending || false;
    },
    set: function(value) {
      this._nextButtonSavePending = value;
      if (value) {
        startChangeDetection();
      } else {
        stopChangeDetection();
      }
    },
    configurable: true
  });
  
  // Initialize based on current state
  if (originalNextButtonSavePending) {
    window.__NEXT_BUTTON_SAVE_PENDING__ = originalNextButtonSavePending;
  }

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    stopChangeDetection();
  });

  // Manual reset function for testing
  window.resetAutomationForTesting = function() {
    automationRunning = false;
    automationStarting = false;
    window.__AUTOMATION_STATE__ = null;
    window.__NEXT_BUTTON_SAVE_PENDING__ = false;
    window.__NEXT_BUTTON_SAVE_STEP__ = null;
    clearResumeIndex();
    console.log(`‚úÖ Reset automation state and cleared resume index (domain + current run)`);
  };

  // Debug function for testing tab ID
  window.debugTabId = function() {
    console.log(`üîç [DEBUG] Current tab ID: ${currentTabId}`);
    console.log(`üîç [DEBUG] Storage key: ${getTabSpecificResumeIndexKey()}`);
    
    chrome.storage.local.get(null, (data) => {
      const resumeKeys = Object.keys(data).filter(k => k.startsWith('resumeIndex_'));
      console.log(`üîç [DEBUG] All resume keys:`, resumeKeys);
      
      resumeKeys.forEach(key => {
        console.log(`   ${key}: ${data[key]}`);
      });
    });
  };

  // Debug function for missing elements
  window.debugMissingElement = function(selector) {
    console.log(`üîç [DEBUG] Searching for missing element: ${selector}`);
    
    const element = document.querySelector(selector);
    console.log(`   Direct query result:`, element);
    
    if (!element) {
      console.log(`   üîç Searching in iframes...`);
      const iframes = document.querySelectorAll('iframe');
      iframes.forEach((iframe, index) => {
        try {
          const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
          const iframeElement = iframeDoc.querySelector(selector);
          console.log(`     Iframe ${index}:`, iframeElement);
        } catch (e) {
          console.log(`     Iframe ${index}: Access denied (cross-origin)`);
        }
      });
    } else {
      console.log(`   ‚úÖ Element found!`);
      console.log(`     Tag: ${element.tagName}`);
      console.log(`     Visible: ${element.offsetParent !== null}`);
      console.log(`     Style display: ${getComputedStyle(element).display}`);
      console.log(`     Style visibility: ${getComputedStyle(element).visibility}`);
    }
  };

  // Debug function to check CampaignData alternatives  
  window.debugCampaignData = function() {
    console.log(`üîç [DEBUG] Checking CampaignData for alternatives:`);
    
    const alternativeKeys = ['firstnameAlternative', 'lastnameAlternative', 'image1alternative', 'logoalternative'];
    
    alternativeKeys.forEach(key => {
      const value = flatData[key];
      console.log(`   ${key}: ${value ? `"${value}"` : '‚ùå Not found'}`);
    });
    
    console.log(`\nüîç [DEBUG] All CampaignData keys:`);
    Object.keys(flatData).forEach(key => {
      if (key.includes('Alternative') || key.includes('Box')) {
        console.log(`   ${key}: "${flatData[key]}"`);
      }
    });
  };

  // Export chrome.storage.local data as a JSON file
  window.exportChromeStorageLocalToJson = function(fileName = 'chrome-storage-local.json', keys = null) {
    try {
      const storageKeys = Array.isArray(keys) && keys.length > 0 ? keys : null;
      const query = storageKeys ? storageKeys : null;
      CHROME_API.storage.local.get(query, (result) => {
        if (CHROME_API.lastError) {
          console.error('‚ùå [EXPORT] Error reading chrome.storage.local:', CHROME_API.lastError.message);
          return;
        }
        const json = JSON.stringify(result, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        link.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        console.log(`‚úÖ [EXPORT] Download started: ${fileName}`);
      });
    } catch (error) {
      console.error('‚ùå [EXPORT] Failed to export chrome.storage.local:', error);
    }
  };

  // Debug function for ID selectors
  window.debugIdSelector = function(selector) {
    console.log(`üîç [DEBUG] Testing ID selector: ${selector}`);
    
    // Test original selector
    const originalEl = document.querySelector(selector);
    console.log(`   Original: ${originalEl ? '‚úÖ Found' : '‚ùå Not found'}`);
    
    // Test escaped selector (for dots in IDs)
    const escapedSelector = selector.replace(/\./g, '\\.');
    const escapedEl = document.querySelector(escapedSelector);
    console.log(`   Escaped: ${escapedEl ? '‚úÖ Found' : '‚ùå Not found'}`);
    
    // Test attribute selector
    const attrSelector = `[id="${selector.replace('#', '')}"]`;
    const attrEl = document.querySelector(attrSelector);
    console.log(`   Attribute: ${attrEl ? '‚úÖ Found' : '‚ùå Not found'}`);
    
    if (originalEl) console.log('‚úÖ Original selector works!');
    else if (escapedEl) console.log('‚úÖ Escaped selector works! Use escaped version.');
    else if (attrEl) console.log('‚úÖ Attribute selector works! Use attribute version.');
    else console.log('‚ùå No selector variation found the element.');
  };

  // Debug function specifically for NextButtonSave selectors
  window.debugNextButtonSave = function() {
    console.log(`üîç [DEBUG] Testing NextButtonSave selectors on current page:`);
    
    const selectors = [
      '.peButton.ctaRegister.small.fl',  // Step 0
      '.MuiButton-label',                // Step 2, 6, 8
      // Add more NextButtonSave selectors as needed
    ];
    
    selectors.forEach(selector => {
      const el = document.querySelector(selector);
      console.log(`   ${selector}: ${el ? '‚úÖ Found' : '‚ùå Not found'}`);
      if (el) {
        console.log(`     Text: "${el.textContent.trim()}"`);
        console.log(`     Visible: ${el.offsetParent !== null}`);
      }
    });
  }; 

})(window);
     
     
     